# file opened: drive_n.asm
   1  0000                      device ZXSPECTRUM128
   2  0000
   3  0000              bank1           equ 0x7ffd
   4  0000              bankm           equ 0x5B5c
   5  0000              xdpb_ptrs       equ 0xe2a0              ; This is the same on the +3e, +3 or +2A
   6  0000              bordcr          equ $5c48
   7  0000
   8  0000                  org     0xc000 - (3*1024)
   9  B400
  10  B400              start:
  11  B400                  display $
  12  B400
  13  B400 C3 08 B4         jp      1F
  14  B403
  15  B403 EE BB            defw   d_host                   ; Addresses so we can poke in IP address
  16  B405 1C BC            defw   d_port                   ; and port of server if needed
  17  B407              disk_type:
  18  B407 00               defb   0                        ; Disk type
  19  B408
  20  B408              1:
  21  B408                  ; Set up the stack and save HL' so we can return to BASIC
  22  B408
  23  B408 F3               di
  24  B409 ED 73 5B B6      ld   (old_sp), sp               ; Move stack so it doesn't get paged out
  25  B40D 31 C1 B6         ld   sp, tmp_stack              ; when calling +3DOS
  26  B410 D9               exx
  27  B411 22 1A B6         ld   (temp_hl), hl              ; Save HL' as it's needed if returning to BASIC
  28  B414 D9               exx
  29  B415 FB               ei
  30  B416
  31  B416 CD A0 B4         call saveBorder                 ; Save border colour so we can restore it later
  32  B419
  33  B419                  ; Load WiFi config + init ESP
  34  B419
  35  B419 3A 1C B6         ld   a, (wifiConnected)
  36  B41C B7               or   a
  37  B41D 20 0B            jr   nz, 1F
  38  B41F              ;        call text_init
  39  B41F CD B7 B8         call loadWiFiConfig
  40  B422 CD FB B8         call initWiFi
  41  B425 3E 01            ld   a, 1                           ; Flag wifi as connected
  42  B427 32 1C B6         ld   (wifiConnected), a
  43  B42A
  44  B42A              1:
  45  B42A                  ; Set up XDPB for drive 'N:'
  46  B42A
  47  B42A 3E 4E            ld      a, 'N'
  48  B42C CD 7F B5         call    getXDPBPtr              ; Return the pointer to XDPB for drive N
  49  B42F
  50  B42F F3               di
  51  B430 3E 07            ld      a, 7
  52  B432 CD D5 B5         call    ram_page_in
  53  B435
  54  B435 3E E6            ld      a, low xdpb             ; Set pointer to point to our XDPB
  55  B437 77               ld      (hl), a
  56  B438 23               inc     hl
  57  B439 3E B4            ld      a, high xdpb
  58  B43B 77               ld      (hl), a
  59  B43C 2B               dec     hl
  60  B43D
  61  B43D CD E2 B5         call    ram_page_out
  62  B440 FB               ei
  63  B441
  64  B441 DD 21 E6 B4      ld      ix, xdpb
  65  B445 3A 07 B4         ld      a, (disk_type)          ; 0 = Standard +3 format disk
  66  B448 21 53 B4         ld      hl, .return1
  67  B44B E5               push    hl
  68  B44C 21 78 01         ld      hl, dd_sel_format
  69  B44F E5               push    hl
  70  B450 C3 B1 B5         jp      dos_tos
  71  B453
  72  B453              .return1
  73  B453 C3 91 B4         jp      exit                    ; Drive N is now available
  74  B456
  75  B456              login:
  76  B456 AF               xor a
  77  B457 37               scf                                 ; Signal success
  78  B458 C9               ret
  79  B459
  80  B459              ;    B = Page for C000h (49152)...FFFFh (65535)
  81  B459              ;    C = Unit (0/1)
  82  B459              ;    D = Logical track, 0 base
  83  B459              ;    E = Logical sector, 0 base
  84  B459              ;   HL = Address of buffer
  85  B459              ;   IX = Address of XDPB
  86  B459              read:
  87  B459 DD E5            push ix
  88  B45B
  89  B45B 3E 05            ld   a, 5
  90  B45D 32 07 B6         ld   (ddl_parms+$06), a             ; Read command
  91  B460
  92  B460 E5               push hl
  93  B461 D5               push de
  94  B462 C5               push bc
  95  B463 CD 16 B5         call buildFloppyCmd                 ; Build command to ddl_parms
  96  B466 C1               pop  bc
  97  B467 D1               pop  de
  98  B468 E1               pop  hl
  99  B469
 100  B469 CD B2 B4         call floppyCmdToString              ; Convert to hex string
 101  B46C
 102  B46C 2A 02 B6         ld   hl, (ddl_parms+1)              ; buffer address for sector read
 103  B46F 22 C6 BB         ld   (data_pointer), hl
 104  B472
 105  B472 21 EE BB         ld   hl, d_host
 106  B475 11 CE BB         ld   de, d_path
 107  B478 01 1C BC         ld   bc, d_port
 108  B47B
 109  B47B CD 3C BB         call loadSector
 110  B47E 20 08            jr   nz, 1F
 111  B480
 112  B480 CD AC B4         call restoreBorder
 113  B483 DD E1            pop  ix                             ; Restore IX
 114  B485 AF               xor  a
 115  B486 37               scf                                 ; Signal success
 116  B487 C9               ret
 117  B488
 118  B488              1:
 119  B488 DD E1            pop  ix
 120  B48A              write:
 121  B48A CD AC B4         call restoreBorder
 122  B48D AF               xor  a
 123  B48E 3E 02            ld   a, 2                           ; Seek fail
 124  B490 C9               ret
 125  B491
 126  B491              exit:
 127  B491 F3               di
 128  B492 ED 7B 5B B6      ld      sp, (old_sp)
 129  B496 D9               exx
 130  B497 2A 1A B6         ld      hl, (temp_hl)
 131  B49A D9               exx
 132  B49B
 133  B49B CD AC B4         call    restoreBorder
 134  B49E
 135  B49E FB               ei
 136  B49F C9               ret
 137  B4A0
 138  B4A0              saveBorder:
 139  B4A0 3A 48 5C         ld      a, (bordcr)                 ; Restore border colour
 140  B4A3 E6 38            and     $38
 141  B4A5 0F               rrca
 142  B4A6 0F               rrca
 143  B4A7 0F               rrca
 144  B4A8 32 1D B6         ld      (border), a
 145  B4AB C9               ret
 146  B4AC
 147  B4AC              restoreBorder:
 148  B4AC 3A 1D B6         ld      a, (border)
 149  B4AF D3 FE            out     (-2), a
 150  B4B1 C9               ret
 151  B4B2
 152  B4B2              floppyCmdToString:
 153  B4B2 21 07 B6         ld   hl, ddl_parms+6
 154  B4B5 01 09 00         ld   bc, 0x09
 155  B4B8 11 CE BB         ld   de, d_path
 156  B4BB CD C1 B4         call bytesToHex
 157  B4BE AF               xor  a                              ; Null terminate string
 158  B4BF 77               ld   (hl), a
 159  B4C0 C9               ret
 160  B4C1
 161  B4C1              bytesToHex:
 162  B4C1 7E           1:  ld   a, (hl)
 163  B4C2 C5               push bc
 164  B4C3 CD D2 B4         call hexToBuf
 165  B4C6 C1               pop  bc
 166  B4C7 23               inc  hl
 167  B4C8 0B               dec  bc
 168  B4C9 78               ld   a, b
 169  B4CA B1               or   c
 170  B4CB C8               ret  z
 171  B4CC 3E 20            ld   a, ' '
 172  B4CE 12               ld   (de), a
 173  B4CF 13               inc  de
 174  B4D0 18 EF            jr   1B
 175  B4D2
 176  B4D2              ; Entry:
 177  B4D2              ;   A = Hex value
 178  B4D2              ;  DE = Output buffer
 179  B4D2              hexToBuf:
 180  B4D2 4F               ld   c, a
 181  B4D3 1F               rra
 182  B4D4 1F               rra
 183  B4D5 1F               rra
 184  B4D6 1F               rra
 185  B4D7 CD DB B4         call 1f
 186  B4DA 79               ld   a, c
 187  B4DB E6 0F        1:  and  0x0f
 188  B4DD C6 90            add  a, 0x90
 189  B4DF 27               daa
 190  B4E0 CE 40            adc  a, 0x40
 191  B4E2 27               daa
 192  B4E3 12               ld   (de), a
 193  B4E4 13               inc  de
 194  B4E5 C9               ret
 195  B4E6
 196  B4E6              xdpb:
 197  B4E6 00 00 00...      defs $1b, 0
 198  B501
 199  B501              .l17f6
 200  B501 04 4E 00         defb    $04,'N',$00         ; flags,drive,unit
 201  B504 00 00 00 00      defb    $00,$00,$00,$00     ; last access,filesopen
 202  B508 00 00 00 00      defw    $0000,$0000         ; #free direntries,last used
 203  B50C 1E B6 2E B6      defw    chksm_a,alloc_a     ; checksum vector,alloc bitmap
 204  B510 56 B4            defw    login               ; login disk
 205  B512 59 B4            defw    read                ; read sector
 206  B514 8A B4            defw    write               ; write sector
 207  B516
 208  B516              ; Convert logical track / sector to physical
 209  B516              ; Entry:
 210  B516              ;   DE = Logical Track / Sector
 211  B516              ;    C = Unit
 212  B516
 213  B516              buildFloppyCmd:
 214  B516 CD 41 B5         call    l1b9c                   ; setup basic parameter block data
 215  B519 7B               ld      a,e
 216  B51A DD 86 14         add     a,(ix+$14)
 217  B51D 5F               ld      e,a                     ; E=physical sector number
 218  B51E D5               push    de                      ; save physical track & sector numbers
 219  B51F 7B               ld      a,e
 220  B520 32 0B B6         ld      (ddl_parms+$0a),a       ; store 1st sector ID
 221  B523 DD 6E 0F         ld      l,(ix+$0f)
 222  B526 63               ld      h,e
 223  B527 22 0C B6         ld      (ddl_parms+$0b),hl      ; store sector size & last(=1st) sector ID
 224  B52A DD 7E 17         ld      a,(ix+$17)
 225  B52D 32 0E B6         ld      (ddl_parms+$0d),a       ; store gap length
 226  B530 60               ld      h,b
 227  B531 6A               ld      l,d
 228  B532 22 09 B6         ld      (ddl_parms+8),hl        ; store track & side numbers
 229  B535 3E 09            ld      a,$09
 230  B537 32 06 B6         ld      (ddl_parms+5),a         ; store # command bytes
 231  B53A 21 0F B6         ld      hl,ddl_parms+$0e
 232  B53D 36 FF            ld      (hl),$ff                ; store dummy data length
 233  B53F D1               pop     de
 234  B540 C9               ret
 235  B541
 236  B541              ; Subroutine to setup some of the parameter block for sector read/writes
 237  B541              ; (except # command bytes & additional command bytes)
 238  B541
 239  B541 22 02 B6     l1b9c   ld      (ddl_parms+1),hl        ; store buffer address
 240  B544 6F               ld      l,a
 241  B545 78               ld      a,b
 242  B546 32 01 B6         ld      (ddl_parms),a           ; store buffer page
 243  B549 CD 5A B5         call    l1bb5                   ; C=physical side & unit byte
 244  B54C 61               ld      h,c
 245  B54D 22 07 B6         ld      (ddl_parms+6),hl        ; store command & unit byte
 246  B550 DD 6E 15         ld      l,(ix+$15)
 247  B553 DD 66 16         ld      h,(ix+$16)
 248  B556 22 04 B6         ld      (ddl_parms+3),hl        ; store sector size as # bytes to transfer
 249  B559 C9               ret
 250  B55A
 251  B55A              ; Subroutine to return physical side (B) and track (D) given logical track (D)
 252  B55A              ; Physical side is also ORed with unit number in C
 253  B55A
 254  B55A DD 7E 11     l1bb5   ld      a,(ix+$11)
 255  B55D E6 7F            and     $7f                     ; A=sidedness
 256  B55F 06 00            ld      b,$00                   ; side 0
 257  B561 C8               ret     z                       ; exit if single-sided (physical=logical)
 258  B562
 259  B562 3D               dec     a
 260  B563 20 08            jr      nz,l1bc8                ; move on if double-sided: successive sides
 261  B565
 262  B565 7A               ld      a,d
 263  B566 1F               rra                             ; for alternate sides, halve track
 264  B567 57               ld      d,a
 265  B568 78               ld      a,b
 266  B569 17               rla                             ; with side=remainder
 267  B56A 47               ld      b,a
 268  B56B 18 0C            jr      l1bd4                   ; move on to OR into unit number
 269  B56D
 270  B56D 7A           l1bc8   ld      a,d
 271  B56E DD 96 12         sub     (ix+$12)                ; subtract # tracks
 272  B571 38 06            jr      c,l1bd4                 ; if < # tracks, physical=logical so move on
 273  B573 DD 96 12         sub     (ix+$12)                ; on successive side, tracks count back down
 274  B576 2F               cpl
 275  B577 57               ld      d,a
 276  B578 04               inc     b                       ; and use side 1
 277  B579
 278  B579 78           l1bd4   ld      a,b                     ; A = side (0 or 1)
 279  B57A 87               add     a,a                     ; A*= 2
 280  B57B 87               add     a,a
 281  B57C B1               or      c                       ; OR in unit number
 282  B57D 4F               ld      c,a                     ; update unit number with side bit as bit 1
 283  B57E C9               ret
 284  B57F
 285  B57F              ; ----------------------------------------------------------------------------
 286  B57F              ; Get the address of the pointer to an XDPB for a given drive letter
 287  B57F              ; ----------------------------------------------------------------------------
 288  B57F              ; Entry:
 289  B57F              ;   A = Drive letter, 'A'...'P'
 290  B57F              ; Exit
 291  B57F              ;   HL = Address in page 7 of pointer, or 0 if error
 292  B57F              ; ----------------------------------------------------------------------------
 293  B57F              getXDPBPtr:
 294  B57F F5               push    af
 295  B580 3E 07            ld      a, 7
 296  B582 CD D5 B5         call    ram_page_in
 297  B585 F1               pop     af
 298  B586 CD 8D B5         call    .getPtr
 299  B589 CD E2 B5         call    ram_page_out
 300  B58C C9               ret
 301  B58D
 302  B58D              .getPtr
 303  B58D 21 A0 E2         ld      hl,xdpb_ptrs
 304  B590 D6 41            sub     'A'
 305  B592 38 0D            jr      c, .error         ; error if <A
 306  B594 FE 10            cp      $10
 307  B596 30 09            jr      nc, .error        ; error if >P
 308  B598 87               add     a,a
 309  B599 C6 A0            add     a, low xdpb_ptrs
 310  B59B 6F               ld      l,a
 311  B59C CE E2            adc     a, high xdpb_ptrs
 312  B59E 95               sub     l
 313  B59F 67               ld      h, a             ; HL=xdpb_ptrs+2*drive
 314  B5A0 C9               ret
 315  B5A1              .error:
 316  B5A1 21 00 00         ld      hl, 0
 317  B5A4 C9               ret
 318  B5A5
 319  B5A5              ; Entry
 320  B5A5              ;   IX = +3dos routine to call
 321  B5A5              dos_ix:
 322  B5A5 F3               di
 323  B5A6 CD C1 B5         call dos_in
 324  B5A9 CD EB B5         call call_ix                        ; Call routine in IX
 325  B5AC CD ED B5         call dos_out
 326  B5AF FB               ei
 327  B5B0 C9               ret
 328  B5B1
 329  B5B1              dos_tos:
 330  B5B1 CD C1 B5         call dos_in
 331  B5B4 D9               exx                  ; preserve parameters
 332  B5B5 E1               pop  hl               ; address of the DOS routine
 333  B5B6 11 BD B5         ld   de,dos_tos_return ; return address from the DOS routine
 334  B5B9 D5               push de              ; force the return later
 335  B5BA E5               push hl              ; address of the DOS routine
 336  B5BB D9               exx                  ; restore parameters
 337  B5BC C9               ret                  ; call routine in TOS, then continue at dos.ix.return
 338  B5BD
 339  B5BD              dos_tos_return:
 340  B5BD CD ED B5         call dos_out
 341  B5C0 C9               ret
 342  B5C1
 343  B5C1              ; ----------------------------------------------------------------------------
 344  B5C1              ; Page in +3dos
 345  B5C1              ; ----------------------------------------------------------------------------
 346  B5C1              dos_in:
 347  B5C1 F5               push af
 348  B5C2 C5               push bc              ; temp save registers while switching
 349  B5C3 01 FD 7F         ld   bc,bank1        ; port used for horiz. ROM switch and RAM paging
 350  B5C6 3A 5C 5B         ld   a,(bankm)       ; RAM/ROM switching system variable
 351  B5C9 CB A7            res  4,a             ; and DOS ROM
 352  B5CB F6 07            or   7               ; set bits 0-3: RAM 7
 353  B5CD 32 5C 5B         ld   (bankm),a       ; keep system variables up to date
 354  B5D0 ED 79            out  (c),a           ; RAM page 7 to top and DOS ROM
 355  B5D2 C1               pop  bc
 356  B5D3 F1               pop  af
 357  B5D4 C9               ret
 358  B5D5
 359  B5D5              ; A = RAM page
 360  B5D5              ram_page_in:
 361  B5D5 5F               ld      e, a
 362  B5D6 01 FD 7F         ld      bc, $7ffd
 363  B5D9 3A 5C 5B         ld      a, (bankm)
 364  B5DC E6 F8            and     %11111000       ; Lose RAM bits
 365  B5DE B3               or      e               ; Or in RAM page
 366  B5DF ED 79            out     (c), a
 367  B5E1 C9               ret
 368  B5E2
 369  B5E2              ram_page_out:
 370  B5E2 01 FD 7F         ld      bc, $7ffd
 371  B5E5 3A 5C 5B         ld      a, (bankm)
 372  B5E8 ED 79            out     (c), a          ; restore memory configuration
 373  B5EA C9               ret
 374  B5EB
 375  B5EB              call_ix:
 376  B5EB DD E9            jp   (ix)                           ; Jump to IX and return
 377  B5ED
 378  B5ED              ; ----------------------------------------------------------------------------
 379  B5ED              ; Page out +3DOS
 380  B5ED              ; ----------------------------------------------------------------------------
 381  B5ED              dos_out:
 382  B5ED F5               push af
 383  B5EE C5               push bc
 384  B5EF 3A 5C 5B         ld   a,(bankm)
 385  B5F2 E6 F8            and  %11111000           ; reset bits 0-3: RAM 0
 386  B5F4 CB E7            set  4,a                 ; switch to ROM 3 (48 BASIC)
 387  B5F6 01 FD 7F         ld   bc,bank1
 388  B5F9 32 5C 5B         ld   (bankm),a
 389  B5FC ED 79            out  (c),a               ; switch back to RAM page 0 and 48 BASIC
 390  B5FE C1               pop  bc
 391  B5FF F1               pop  af
 392  B600 C9               ret
 393  B601
 394  B601              ; dosError:
 395  B601              ;     ld   (0x4000), a
 396  B601              ;     ld   a, 2
 397  B601              ;     out  (-2), a
 398  B601              ;     ret
 399  B601
 400  B601              ; Data
 401  B601
 402  B601              ; Space for floppy emulation command
 403  B601              ddl_parms
 404  B601 00 00 00...      defs    $6
 405  B607
 406  B607              dd_cmd
 407  B607 00 00 00...      defs    $13
 408  B61A
 409  B61A              temp_hl:
 410  B61A 00 00            defw    0
 411  B61C
 412  B61C              wifiConnected:
 413  B61C 00               defb    0
 414  B61D
 415  B61D              border:
 416  B61D 00               defb    0
 417  B61E
 418  B61E              chksm_a
 419  B61E 00 00 00...      defs $10, 0
 420  B62E
 421  B62E              alloc_a
 422  B62E 00 00 00...      defs $2d, 0
 423  B65B
 424  B65B              old_sp:
 425  B65B 00 00            defw 0
 426  B65D
 427  B65D 00 00 00...      defs 100
 428  B6C1              tmp_stack:
 429  B6C1 00 00            defw 0
 430  B6C3
 431  B6C3                  include "p3dos.asm"
# file opened: p3dos.asm
   1+ B6C3              ; ZX Spectrum +3DOS
   2+ B6C3
   3+ B6C3              ; By Marcos Cruz (programandala.net)
   4+ B6C3
   5+ B6C3              ; Credit:
   6+ B6C3              ;
   7+ B6C3              ; This file is Part 27 of Chapter 8 of the ZX Spectrum +3
   8+ B6C3              ; manual, transcribed by Russell Marks et al. and published in
   9+ B6C3              ; HTML format in <http://worldofspectrum.org>.  I simply
  10+ B6C3              ; converted it to be usable as Z80 source.
  11+ B6C3
  12+ B6C3              ; --------------------------------------------------------------
  13+ B6C3              ; Change history
  14+ B6C3
  15+ B6C3              ; 2015-01-12: Start.
  16+ B6C3              ;
  17+ B6C3              ; 2015-07-13: Add labels for DOS GET 1346 and DOS SET 1346.
  18+ B6C3              ; Fix typos (also in the original HTML document).
  19+ B6C3              ;
  20+ B6C3              ; 2017-02-06: Add all symbols for low-level "DD" entry points.
  21+ B6C3              ; Improve the credit note.
  22+ B6C3
  23+ B6C3              ; --------------------------------------------------------------
  24+ B6C3
  25+ B6C3              ; Part 27
  26+ B6C3              ; Guide to +3DOS
  27+ B6C3              ;
  28+ B6C3              ; Subjects covered...
  29+ B6C3              ;
  30+ B6C3              ;         ROMs
  31+ B6C3              ;         +3DOS interface
  32+ B6C3              ;         File attributes and headers
  33+ B6C3              ;         Disk format and specification
  34+ B6C3              ;         Tracks and sectors
  35+ B6C3              ;         Disk parameter blocks
  36+ B6C3              ;         CP/M file compatibility
  37+ B6C3              ;         Changing disks
  38+ B6C3              ;         Logical to physical drive mapping
  39+ B6C3              ;         +3DOS messages and requirements
  40+ B6C3              ;         +3DOS routines
  41+ B6C3              ;
  42+ B6C3              ;
  43+ B6C3              ; This section describes +3DOS - the disk operating system of the
  44+ B6C3              ; +3. The information will probably be of most interest to people
  45+ B6C3              ; familiar with assembly language (machine code) programming (see part
  46+ B6C3              ; 26 of this chapter for more information on this subject). What follows
  47+ B6C3              ; is highly technical, and should not be used by the uninitiated.
  48+ B6C3              ;
  49+ B6C3              ; The operating software of the +3 is, in effect, held in four ROMs
  50+ B6C3              ; (though the information is actually contained in just two ICs). All
  51+ B6C3              ; four ROMs are addressed between 0000h and 3FFFh, although only one is
  52+ B6C3              ; switched in at a time.
  53+ B6C3              ;
  54+ B6C3              ; ROM 0 is the 'editor' ROM and is the one entered when the +3 is first
  55+ B6C3              ; switched on. This controls the high level 'menuing' and editing
  56+ B6C3              ; functions.
  57+ B6C3              ;
  58+ B6C3              ; ROM 1 is the 'syntax' ROM and handles the high level control of +3
  59+ B6C3              ; BASIC. It contains the code for the BASIC parts of most of the disk
  60+ B6C3              ; based commands.
  61+ B6C3              ;
  62+ B6C3              ; ROM 3 is the '48 BASIC' ROM and is virtually identical to the ROM used
  63+ B6C3              ; in the very first Spectrum. The only real area where it is different
  64+ B6C3              ; is in the code executed when an interrupt occurs. If non-zero, a
  65+ B6C3              ; 'ticker' variable is decremented every second interrupt, and when it
  66+ B6C3              ; reaches zero, the disk motor is switched off. This variable is held in
  67+ B6C3              ; page 7 along with some of the editor and DOS variables. Page 7 will
  68+ B6C3              ; only be switched in (and this variable decremented) if bit 4 in the
  69+ B6C3              ; FLAGS system variable is set - this is used by the software to
  70+ B6C3              ; identify whether it is running 48 BASIC or +3 BASIC. When 48 BASIC is
  71+ B6C3              ; selected (from the main menu or by the SPECTRUM command), this bit is
  72+ B6C3              ; reset so that this page-switching and ticker-decrementing won't
  73+ B6C3              ; happen. However, if bit 4 in the FLAGS system variable is subsequently
  74+ B6C3              ; set by your own program, this process will start again while interrupt
  75+ B6C3              ; mode 1 is still selected.
  76+ B6C3              ;
  77+ B6C3              ; The keypad scanning routines of the Spectrum 128 and +2 have been
  78+ B6C3              ; removed from ROM 3 in the +3.
  79+ B6C3              ;
  80+ B6C3              ; A 'bug' in the original 48 BASIC ROM has been fixed in the +3. When a
  81+ B6C3              ; non-maskable interrupt (NMI) occurs, a jump is made to location
  82+ B6C3              ; 66h. This now checks the contents of the NMIADD system variable. If it
  83+ B6C3              ; is zero, a RETN is executed, otherwise a jump is made to the routine
  84+ B6C3              ; address held in NMIADD. The NMI code in ROM 2 consists of just a RETN.
  85+ B6C3              ;
  86+ B6C3              ; ROM 3 not only provides the 48 BASIC mode for program compatibility,
  87+ B6C3              ; but executes the majority of +3 BASIC commands that don't make use of
  88+ B6C3              ; the more advanced hardware of the +3.
  89+ B6C3              ;
  90+ B6C3              ; The fourth ROM (ROM 2) holds +3DOS - the disk operating system. This
  91+ B6C3              ; is the subject of this section. Unlike the other ROMs, which are
  92+ B6C3              ; unlikely to be of much use for assembler programmers (except the 48
  93+ B6C3              ; BASIC ROM perhaps), the +3DOS ROM has a wealth of routines that may
  94+ B6C3              ; well be of use in your own programs. We strongly recommend that any
  95+ B6C3              ; software that uses the disk drives makes use of these routines as they
  96+ B6C3              ; provide most of the facilities that one could wish for (more than are
  97+ B6C3              ; currently used by BASIC, in fact). Furthermore, the routines should
  98+ B6C3              ; only be accessed via the jump block. This not only makes it easier to
  99+ B6C3              ; write software that can be adapted to and from the AMSTRAD CPC range
 100+ B6C3              ; of computers, but also affords upwards compatibility for the
 101+ B6C3              ; future. The entry points for each routine are held in a jump table at
 102+ B6C3              ; address 0100h (256) in the ROM. Part 26 of this chapter gave a couple
 103+ B6C3              ; of examples of the way in which these routines can be called.
 104+ B6C3              ;
 105+ B6C3              ; +3DOS provides the following facilities:
 106+ B6C3              ;
 107+ B6C3              ;         - Support for one or two floppy disk drives and a RAMdisk.
 108+ B6C3              ;         - CP/M Plus and CP/M 2.2 file compatibility.
 109+ B6C3              ;         - AMSTRAD CPC range and PCW range file and media
 110+ B6C3              ;             compatibility.
 111+ B6C3              ;         - Up to 16 files open at the same time.
 112+ B6C3              ;         - Reading and writing files to or from any page in memory.
 113+ B6C3              ;         - Byte level random access.
 114+ B6C3              ;         - Deleting disk files; renaming disk files; changing disk
 115+ B6C3              ;             files' attributes.
 116+ B6C3              ;         - Selecting the default drive and user.
 117+ B6C3              ;         - Booting a game or operating system.
 118+ B6C3              ;         - Low level access to floppy disk driver.
 119+ B6C3              ;         - Optional mapping of two logical drives (A: or B:) onto one
 120+ B6C3              ;             physical drive (unit 0).
 121+ B6C3              ;
 122+ B6C3              ;
 123+ B6C3              ; +3DOS interface
 124+ B6C3              ;
 125+ B6C3              ; +3DOS's interface is a set of routines accessed via a jump block. The
 126+ B6C3              ; routines provided fall into three categories:
 127+ B6C3              ;
 128+ B6C3              ;         - Essential filing system routines.
 129+ B6C3              ;         - Additional routines for games and operating systems.
 130+ B6C3              ;         - Low level floppy disk access routines for disk formatting,
 131+ B6C3              ;             copying, etc.
 132+ B6C3              ;
 133+ B6C3              ; The following is a list of the routines in each of these categories
 134+ B6C3              ; (together with brief descriptions of the routines' functions):
 135+ B6C3              ;
 136+ B6C3              ;
 137+ B6C3              ; Essential filing system routines
 138+ B6C3              ;
 139+ B6C3              ; NAME OF ROUTINE         FUNCTION
 140+ B6C3              ;
 141+ B6C3              ; DOS INITIALISE          Initialise +3DOS
 142+ B6C3              ; DOS VERSION             Get +3DOS issue and version numbers
 143+ B6C3              ; DOS OPEN                Create and/or open a file
 144+ B6C3              ; DOS CLOSE               Close a file
 145+ B6C3              ; DOS ABANDON             Abandon a file
 146+ B6C3              ; DOS REF HEAD            Point at the header data for this file
 147+ B6C3              ; DOS READ                Read bytes into memory
 148+ B6C3              ; DOS WRITE               Write bytes from memory
 149+ B6C3              ; DOS BYTE READ           Read a byte
 150+ B6C3              ; DOS BYTE WRITE          Write a byte
 151+ B6C3              ; DOS CATALOG             Catalog disk directory
 152+ B6C3              ; DOS FREE SPACE          Free space on disk
 153+ B6C3              ; DOS DELETE              Delete a file
 154+ B6C3              ; DOS RENAME              Rename a file
 155+ B6C3              ; DOS BOOT                Boot an operating system or other program
 156+ B6C3              ; DOS SET DRIVE           Set/get default drive
 157+ B6C3              ; DOS SET USER            Set/get default user number
 158+ B6C3              ;
 159+ B6C3              ;
 160+ B6C3              ; Additional routines for games and operating systems
 161+ B6C3              ;
 162+ B6C3              ; NAME OF ROUTINE         FUNCTION
 163+ B6C3              ;
 164+ B6C3              ; DOS GET POSITION        Get file pointer for random access
 165+ B6C3              ; DOS SET POSITION        Set file pointer for random access
 166+ B6C3              ; DOS GET EOF             Get end of file position for random access
 167+ B6C3              ; DOS GET 1346            Get memory usage in pages 1, 3, 4, 6
 168+ B6C3              ; DOS SET 1346            Re-allocate memory usage in pages 1, 3, 4, 6
 169+ B6C3              ; DOS FLUSH               Bring disk up to date
 170+ B6C3              ; DOS SET ACCESS          Change open file's access mode
 171+ B6C3              ; DOS SET ATTRIBUTES      Change a file's attributes
 172+ B6C3              ; DOS OPEN DRIVE          Open a drive as a single file
 173+ B6C3              ; DOS SET MESSAGE         Enable/disable error messages
 174+ B6C3              ; DOS REF XDPB            Point at XDPB for low level disk access
 175+ B6C3              ; DOS MAP B               Map B: onto unit 0 or 1
 176+ B6C3              ;
 177+ B6C3              ;
 178+ B6C3              ; Low level floppy disk driving routines
 179+ B6C3              ;
 180+ B6C3              ; NAME OF ROUTINE         FUNCTION
 181+ B6C3              ;
 182+ B6C3              ; DD INTERFACE            Is the floppy disk driver interface present?
 183+ B6C3              ; DD INIT                 Initialise disk driver
 184+ B6C3              ; DD SETUP                Specify drive parameters
 185+ B6C3              ; DD SET RETRY            Set try/retry count
 186+ B6C3              ; DD READ SECTOR          Read a sector
 187+ B6C3              ; DD WRITE SECTOR         Write a sector
 188+ B6C3              ; DD CHECK SECTOR         Check a sector
 189+ B6C3              ; DD FORMAT               Format a track
 190+ B6C3              ; DD READ ID              Read a sector identifier
 191+ B6C3              ; DD TEST UNSUITABLE      Test media suitability
 192+ B6C3              ; DD LOGIN                Log in disk, initialise XDPB
 193+ B6C3              ; DD SEL FORMAT           Pre-initialise XDPB for DD FORMAT
 194+ B6C3              ; DD ASK 1                Is unit 1 (external drive) present?
 195+ B6C3              ; DD DRIVE STATUS         Fetch drive status
 196+ B6C3              ; DD EQUIPMENT            What type of drive?
 197+ B6C3              ; DD ENCODE               Set intercept routine for copy protection
 198+ B6C3              ; DD L XDPB               Initialise an XDPB from a disk specification
 199+ B6C3              ; DD L DPB                Initialise a DPB from a disk specification
 200+ B6C3              ; DD L SEEK               uPD765A seek driver
 201+ B6C3              ; DD L READ               uPD765A read driver
 202+ B6C3              ; DD L WRITE              uPD765A write driver
 203+ B6C3              ; DD L ON MOTOR           Motor on, wait for motor-on time
 204+ B6C3              ; DD L T OFF MOTOR        Start the motor-off ticker
 205+ B6C3              ; DD L OFF MOTOR          Turn the motor off
 206+ B6C3              ;
 207+ B6C3              ;
 208+ B6C3              ; Games and other non-BASIC programs
 209+ B6C3              ;
 210+ B6C3              ; +3DOS provides facilities specifically for non-BASIC programs:
 211+ B6C3              ;
 212+ B6C3              ; - Use DOS BOOT to load a single bootstrap sector, then take over the
 213+ B6C3              ; whole machine (see the second example in part 26 of this chapter).
 214+ B6C3              ;
 215+ B6C3              ; - Claim some store from +3DOS using DOS SET 1346. This enables a
 216+ B6C3              ; non-BASIC program to take control of the machine but still use the
 217+ B6C3              ; facilities of +3DOS if required. If +3DOS is not required, then the
 218+ B6C3              ; non-BASIC program should call DD L OFF MOTOR to force the drive motor
 219+ B6C3              ; off and disable the motor ticker. Bit 4 in the FLAGS system variable
 220+ B6C3              ; should be reset to prevent any back switching/variable decrementing on
 221+ B6C3              ; interrupt.
 222+ B6C3              ;
 223+ B6C3              ; - A drive can be opened as a single file. This enables files and
 224+ B6C3              ; directories to be examined without going via the file structure.
 225+ B6C3              ;
 226+ B6C3              ;
 227+ B6C3              ; Using +3DOS without a floppy disk interface
 228+ B6C3              ;
 229+ B6C3              ; [This is the case on a +2A.]
 230+ B6C3              ;
 231+ B6C3              ; Even if the floppy disk interface were not present, +3DOS could still
 232+ B6C3              ; be used as follows:
 233+ B6C3              ;
 234+ B6C3              ;         - Only drive M: is available (the RAMdisk).
 235+ B6C3              ;         - The default drive for filenames is initialised to M: rather
 236+ B6C3              ;             than A:.
 237+ B6C3              ;         - Any attempt to use drives A: or B: will fail with error '22
 238+ B6C3              ;             - Drive not found'.
 239+ B6C3              ;         - As the sector cache is not required for use with the
 240+ B6C3              ;             RAMdisk, is increased to 64K (the whole of pages 1, 3, 4,
 241+ B6C3              ;             6). This will give 62K of data and 2K of directory (64
 242+ B6C3              ;             entries).
 243+ B6C3              ;         - The presence of the floppy disk interface can be determined
 244+ B6C3              ;             by calling DD INTERFACE. If the interface were not
 245+ B6C3              ;             present, then none of the other low level floppy disk
 246+ B6C3              ;             routines (DD... etc.) could be called; the effect of doing
 247+ B6C3              ;             so is undefined.
 248+ B6C3              ;
 249+ B6C3              ;
 250+ B6C3              ; File attributes
 251+ B6C3              ;
 252+ B6C3              ; Bit 7 of the name and type field characters are the file
 253+ B6C3              ; attributes. The top bits of the name field characters are denoted
 254+ B6C3              ; f1...f8. The top bits of the type field characters are denoted
 255+ B6C3              ; t1...t3. They have the following meanings:
 256+ B6C3              ;
 257+ B6C3              ;         f1...f4 - Available to the user
 258+ B6C3              ;         f5...f8 - Reserved (always 0)
 259+ B6C3              ;              t1 - 0 means file is read-write; 1 means file is
 260+ B6C3              ;                     read-only
 261+ B6C3              ;              t2 - 0 means not system file; 1 means system file
 262+ B6C3              ;              t3 - 0 means not archived; 1 means archived
 263+ B6C3              ;
 264+ B6C3              ; A read-only file cannot be written to, erased or renamed. System files
 265+ B6C3              ; can, optionally, be omitted from the directory catalog. The archive
 266+ B6C3              ; attribute is ignored by +3DOS.
 267+ B6C3              ;
 268+ B6C3              ; Newly created files have all attributes set to 0. An existing file's
 269+ B6C3              ; attributes can only be changed by DOS SET ATTRIBUTES (as used by
 270+ B6C3              ; BASIC's MOVE command).
 271+ B6C3              ;
 272+ B6C3              ;
 273+ B6C3              ; File headers
 274+ B6C3              ;
 275+ B6C3              ; Tape files have headers which contain some system information. +3DOS
 276+ B6C3              ; files may, or may not, have headers. All files created by BASIC's SAVE
 277+ B6C3              ; command will have headers.
 278+ B6C3              ;
 279+ B6C3              ; The +3DOS header mechanism provides a dedicated 8 byte area in each
 280+ B6C3              ; headed file reserved for BASIC's use. The remainder of the header is
 281+ B6C3              ; reserved for +3DOS. This 8 byte header is utilised in files created by
 282+ B6C3              ; BASIC commands (see DOS OPEN description).
 283+ B6C3              ;
 284+ B6C3              ; +3DOS files may have a single header in the first 128 bytes of the
 285+ B6C3              ; file - the header record. These headers are detected by a 'signature'
 286+ B6C3              ; and checksum. If the signature and checksum are as expected, then a
 287+ B6C3              ; header is present; if not, these is no header. Thus, it is possible,
 288+ B6C3              ; but unlikely, that a file without a header could be mistaken for one
 289+ B6C3              ; with a header.
 290+ B6C3              ;
 291+ B6C3              ; The format of the header record is as follows:
 292+ B6C3              ;
 293+ B6C3              ;         Bytes 0...7     - +3DOS signature - 'PLUS3DOS'
 294+ B6C3              ;         Byte 8          - 1Ah (26) Soft-EOF (end of file)
 295+ B6C3              ;         Byte 9          - Issue number
 296+ B6C3              ;         Byte 10         - Version number
 297+ B6C3              ;         Bytes 11...14   - Length of the file in bytes, 32 bit number,
 298+ B6C3              ;                             least significant byte in lowest address
 299+ B6C3              ;         Bytes 15...22   - +3 BASIC header data
 300+ B6C3              ;         Bytes 23...126  - Reserved (set to 0)
 301+ B6C3              ;         Byte 127        - Checksum (sum of bytes 0...126 modulo 256)
 302+ B6C3              ;
 303+ B6C3              ; The issue and version numbers are provided for any future
 304+ B6C3              ; expansion. The issue number must equal the software's issue number;
 305+ B6C3              ; the version number must be less than or equal to the software's
 306+ B6C3              ; version number.
 307+ B6C3              ;
 308+ B6C3              ; +3DOS performs all the necessary header 'house-keeping'. A pointer to
 309+ B6C3              ; +3 BASIC's 8 byte header area may be returned using DOS REF HEAD. It
 310+ B6C3              ; is never necessary to write directly to the 128 byte header.
 311+ B6C3              ;
 312+ B6C3              ; AMSDOS headers (as used on the AMSTRAD CPC range of computers) will
 313+ B6C3              ; not be recognised. AMSDOS files will be treated by +3DOS as
 314+ B6C3              ; headerless, and vice versa.
 315+ B6C3              ;
 316+ B6C3              ;
 317+ B6C3              ; Disk formats
 318+ B6C3              ;
 319+ B6C3              ; +3DOS supports exactly the same disk format as CP/M Plus and
 320+ B6C3              ; LocoScript on the AMSTRAD PCW range of computer/word processors
 321+ B6C3              ; (i.e. the first format listed below).
 322+ B6C3              ;
 323+ B6C3              ; The following formats are automatically detected when the disk is
 324+ B6C3              ; first accessed:
 325+ B6C3              ;
 326+ B6C3              ;         - AMSTRAD PCW range single track (e.g. as used on model
 327+ B6C3              ;             PCW8256)
 328+ B6C3              ;         - AMSTRAD PCW range double track (e.g. as used on model
 329+ B6C3              ;             PCW8512)
 330+ B6C3              ;         - AMSTRAD CPC range system format
 331+ B6C3              ;         - AMSTRAD CPC range vendor format
 332+ B6C3              ;         - AMSTRAD CPC range data only format
 333+ B6C3              ;
 334+ B6C3              ; Note that the AMSTRAD CPC range's IBM format is not supported.
 335+ B6C3              ;
 336+ B6C3              ; Other disk formats can be used by patching the XDPB for a drive. The
 337+ B6C3              ; XDPB is the same as for the first format listed above; it is not the
 338+ B6C3              ; same as on the CPC range.
 339+ B6C3              ;
 340+ B6C3              ; Disk formats are subject to the following restrictions:
 341+ B6C3              ;
 342+ B6C3              ;         - 512 byte sector size
 343+ B6C3              ;         - Maximum of 255 sectors per track
 344+ B6C3              ;         - Maximum of 255 tracks
 345+ B6C3              ;         - Maximum of 256 directory entries
 346+ B6C3              ;         - Maximum of 360 allocation units
 347+ B6C3              ;
 348+ B6C3              ;
 349+ B6C3              ; Logical tracks and sectors
 350+ B6C3              ;
 351+ B6C3              ; The disk driver routines require 'logical' tracks and sectors. These
 352+ B6C3              ; are used to hide information concerning the number of sides and the
 353+ B6C3              ; actual sector numbers from +3DOS, which knows nothing about them.
 354+ B6C3              ;
 355+ B6C3              ; Logical track numbers on a single sided disk are the same as physical
 356+ B6C3              ; track numbers.
 357+ B6C3              ;
 358+ B6C3              ; For double sided disks, two options are available:
 359+ B6C3              ;
 360+ B6C3              ; 1. Alternating sides...
 361+ B6C3              ;
 362+ B6C3              ;         side 0 track 0 = logical track 0
 363+ B6C3              ;         side 1 track 0 = logical track 1
 364+ B6C3              ;         side 0 track 1 = logical track 2
 365+ B6C3              ;         side 1 track 1 = logical track 3
 366+ B6C3              ;         ...to...
 367+ B6C3              ;         side 0 last track = logical track n-1
 368+ B6C3              ;         side 1 last track = logical track n
 369+ B6C3              ;
 370+ B6C3              ; 2. Successive sides...
 371+ B6C3              ;
 372+ B6C3              ;         side 0 track 0 = logical track 0
 373+ B6C3              ;         side 0 track 1 = logical track 1
 374+ B6C3              ;         side 0 track 2 = logical track 2
 375+ B6C3              ;         ...to...
 376+ B6C3              ;         side 0 last track = logical track n/2-1
 377+ B6C3              ;         ...and then...
 378+ B6C3              ;         side 1 last track-1 = logical track n/2
 379+ B6C3              ;         side 1 last track-2 = logical track n/2+1
 380+ B6C3              ;         side 1 last track-3 = logical track n/2+2
 381+ B6C3              ;         ...to...
 382+ B6C3              ;         side 1 track 0 = logical track n
 383+ B6C3              ;
 384+ B6C3              ; ...where n is the total number of logical tracks (i.e. 2 x number of
 385+ B6C3              ; tracks per side).
 386+ B6C3              ;
 387+ B6C3              ; Logical sectors hide the actual physical sector numbers. Logical
 388+ B6C3              ; sector numbers always start from 0.
 389+ B6C3              ;
 390+ B6C3              ;         Logical sector = physical sector - first sector
 391+ B6C3              ;
 392+ B6C3              ;
 393+ B6C3              ; Disk specification
 394+ B6C3              ;
 395+ B6C3              ; The PCW range disk format (used by the +3) is, in fact, a family of
 396+ B6C3              ; formats the precise member of which is defined in the 'disk
 397+ B6C3              ; specification' which is recorded on bytes 0...15 of sector 1, track 0
 398+ B6C3              ; side 0. The format used on the +3 is the same as disk type 0
 399+ B6C3              ; below. The sector holding this specification is also that used for a
 400+ B6C3              ; bootstrap program. An example of how it may be set up is shown in the
 401+ B6C3              ; second example in part 26 of this chapter.
 402+ B6C3              ;
 403+ B6C3              ; Byte 0          Disk type
 404+ B6C3              ;                         0 = Standard PCW range DD SS ST (and +3)
 405+ B6C3              ;                         1 = Standard CPC range DD SS ST system format
 406+ B6C3              ;                         2 = Standard CPC range DD SS ST data only format
 407+ B6C3              ;                         3 = Standard PCW range DD DS DT
 408+ B6C3              ;                         All other values reserved
 409+ B6C3              ;
 410+ B6C3              ; Byte 1          Bits 0...1 Sidedness
 411+ B6C3              ;                         0 = Single sided
 412+ B6C3              ;                         1 = Double sided (alternating sides)
 413+ B6C3              ;                         2 = Double sided (successive sides)
 414+ B6C3              ;                 Bits 2...6 Reserved (set to 0)
 415+ B6C3              ;                 Bit 7 Double track
 416+ B6C3              ;
 417+ B6C3              ; Byte 2          Number of tracks per side
 418+ B6C3              ;
 419+ B6C3              ; Byte 3          Number of sectors per track
 420+ B6C3              ;
 421+ B6C3              ; Byte 4          Log2(sector size) - 7
 422+ B6C3              ;
 423+ B6C3              ; Byte 5          Number of reserved tracks
 424+ B6C3              ;
 425+ B6C3              ; Byte 6          Log2(block size / 128)
 426+ B6C3              ;
 427+ B6C3              ; Byte 7          Number of directory blocks
 428+ B6C3              ;
 429+ B6C3              ; Byte 8          Gap length (read/write)
 430+ B6C3              ;
 431+ B6C3              ; Byte 9          Gap length (format)
 432+ B6C3              ;
 433+ B6C3              ; Bytes 10...14   Reserved
 434+ B6C3              ;
 435+ B6C3              ; Byte 15         Checksum (used only if disk is bootable)
 436+ B6C3              ;
 437+ B6C3              ;
 438+ B6C3              ; When a disk is logged on, the disk specification is used to initialise
 439+ B6C3              ; the relevant XDPB.
 440+ B6C3              ;
 441+ B6C3              ;
 442+ B6C3              ; Extended disk parameter blocks (XDPB)
 443+ B6C3              ;
 444+ B6C3              ; Associated with each (logical) drive is an extended disk parameter
 445+ B6C3              ; block (XDPB). This contains a standard DPB which is the same as that
 446+ B6C3              ; used by CP/M Plus. It also contains information required by +3DOS to
 447+ B6C3              ; support the different formats. It may be patched in order to use
 448+ B6C3              ; differently formatted disks (provided that the restrictions detailed
 449+ B6C3              ; in the previous table are obeyed).
 450+ B6C3              ;
 451+ B6C3              ; XDPB structure:
 452+ B6C3              ;
 453+ B6C3              ; Bytes 0...1     SPT records per track
 454+ B6C3              ; Byte 2          BSH log2(block size / 128)
 455+ B6C3              ; Byte 3          BLM block size / 128 - 1
 456+ B6C3              ; Byte 4          EXM extent mask
 457+ B6C3              ; Bytes 5...6     DSM last block number
 458+ B6C3              ; Bytes 7...8     DRM last directory entry number
 459+ B6C3              ; Byte 9          AL0 directory bit map
 460+ B6C3              ; Byte 10         AL1 directory bit map
 461+ B6C3              ; Bytes 11...12   CKS size of checksum vector (bit 15 = permanent)
 462+ B6C3              ; Bytes 13...14   OFF number of reserved tracks
 463+ B6C3              ; Byte 15         PSH log2(sector size / 128)
 464+ B6C3              ; Byte 16         PHM sector size / 128 - 1
 465+ B6C3              ; Byte 17         Bits 0...1 Sidedness
 466+ B6C3              ;                         0 = Single sided
 467+ B6C3              ;                         1 = Double sided (alternating sides)
 468+ B6C3              ;                         2 = Double sided (successive sides)
 469+ B6C3              ;                 Bits 2...6 Reserved (set to 0)
 470+ B6C3              ;                 Bit 7 Double track
 471+ B6C3              ; Byte 18         Number of tracks per side
 472+ B6C3              ; Byte 19         Number of sectors per track
 473+ B6C3              ; Byte 20         First sector number
 474+ B6C3              ; Bytes 21...22   Sector size
 475+ B6C3              ; Byte 23         Gap length (read/write)
 476+ B6C3              ; Byte 24         Gap length (format)
 477+ B6C3              ; Byte 25         Bit 7 Multi-track operation
 478+ B6C3              ;                         1 = multi-track
 479+ B6C3              ;                         0 = single track
 480+ B6C3              ;                 Bit 6 Modulation mode
 481+ B6C3              ;                         1 = MFM mode
 482+ B6C3              ;                         0 = FM mode
 483+ B6C3              ;                 Bit 5 Skip deleted data address mark
 484+ B6C3              ;                         1 = skip deleted data address mark
 485+ B6C3              ;                         0 = don't skip deleted address mark
 486+ B6C3              ;                 Bits 0...4 = 0
 487+ B6C3              ; Byte 26         Freeze flag
 488+ B6C3              ;                         00h (0) = auto-detect disk format
 489+ B6C3              ;                         FFh (255) = don't auto-detect disk format
 490+ B6C3              ;
 491+ B6C3              ; Byte 25 is normally set to 60h (96). Multi-track operation is not
 492+ B6C3              ; recommended.
 493+ B6C3              ;
 494+ B6C3              ; Setting the freeze flag (byte 26) prevents +3DOS from trying to
 495+ B6C3              ; determine the format of a disk. This should be used when patching an
 496+ B6C3              ; XDPB for a non-standard format.
 497+ B6C3              ;
 498+ B6C3              ; The XDPBs for the three main formats are as follows:
 499+ B6C3              ;
 500+ B6C3              ; AMSTRAD PCW range single track format (type 0)
 501+ B6C3              ; (As used by the +3)
 502+ B6C3              ;
 503+ B6C3              ; 36              SPT, records per track
 504+ B6C3              ; 3               BSH, block shift
 505+ B6C3              ; 7               BLM, block mask
 506+ B6C3              ; 0               EXM, extent mask
 507+ B6C3              ; 174             DSM, number of blocks - 1
 508+ B6C3              ; 63              DRM, number of directory entries - 1
 509+ B6C3              ; C0h (192)       AL0, 2 directory blocks
 510+ B6C3              ; 00h (0)         AL1
 511+ B6C3              ; 16              CKS, size of checksum vector
 512+ B6C3              ; 1               OFF, reserved tracks
 513+ B6C3              ; 2               PSH, physical sector shift
 514+ B6C3              ; 3               PHM, physical sector mask
 515+ B6C3              ;
 516+ B6C3              ; 0               Single sided
 517+ B6C3              ; 40              Tracks per side
 518+ B6C3              ; 9               Sectors per track
 519+ B6C3              ; 1               First sector number
 520+ B6C3              ; 512             Sector size
 521+ B6C3              ; 42              Gap length (read/write)
 522+ B6C3              ; 82              Gap length (format)
 523+ B6C3              ; 60h (96)        MFM mode, skip deleted data address mark
 524+ B6C3              ; 0               Do auto select format
 525+ B6C3              ;
 526+ B6C3              ;
 527+ B6C3              ; AMSTRAD CPC range SYSTEM format (type 1)
 528+ B6C3              ;
 529+ B6C3              ; 36              SPT, records per track
 530+ B6C3              ; 3               BSH, block shift
 531+ B6C3              ; 7               BLM, block mask
 532+ B6C3              ; 0               EXM, extent mask
 533+ B6C3              ; 170             DSM, number of blocks - 1
 534+ B6C3              ; 63              DRM, number of directory entries - 1
 535+ B6C3              ; C0h (192)       AL0, 2 directory blocks
 536+ B6C3              ; 00h (0)         AL1
 537+ B6C3              ; 16              CKS, size of checksum vector
 538+ B6C3              ; 2               OFF, reserved tracks
 539+ B6C3              ; 2               PSH, physical sector shift
 540+ B6C3              ; 3               PHM, physical sector mask
 541+ B6C3              ;
 542+ B6C3              ; 0               Single sided
 543+ B6C3              ; 40              Tracks per side
 544+ B6C3              ; 9               Sectors per track
 545+ B6C3              ; 41h (65)        First sector number
 546+ B6C3              ; 512             Sector size
 547+ B6C3              ; 42              Gap length (read/write)
 548+ B6C3              ; 82              Gap length (format)
 549+ B6C3              ; 60h (96)        MFM mode, skip deleted data address mark
 550+ B6C3              ; 0               Do auto select format
 551+ B6C3              ;
 552+ B6C3              ;
 553+ B6C3              ; AMSTRAD CPC range DATA ONLY format (type 2)
 554+ B6C3              ;
 555+ B6C3              ; 36              SPT, records per track
 556+ B6C3              ; 3               BSH, block shift
 557+ B6C3              ; 7               BLM, block mask
 558+ B6C3              ; 0               EXM, extent mask
 559+ B6C3              ; 179             DSM, number of blocks - 1
 560+ B6C3              ; 63              DRM, number of directory entries - 1
 561+ B6C3              ; C0h (192)       AL0, 2 directory blocks
 562+ B6C3              ; 00h (0)         AL1
 563+ B6C3              ; 16              CKS, size of checksum vector
 564+ B6C3              ; 0               OFF, reserved tracks
 565+ B6C3              ; 2               PSH, physical sector shift
 566+ B6C3              ; 3               PHM, physical sector mask
 567+ B6C3              ;
 568+ B6C3              ; 0               Single sided
 569+ B6C3              ; 40              Tracks per side
 570+ B6C3              ; 9               Sectors per track
 571+ B6C3              ; C1h (193)       First sector number
 572+ B6C3              ; 512             Sector size
 573+ B6C3              ; 42              Gap length (read/write)
 574+ B6C3              ; 82              Gap length (format)
 575+ B6C3              ; 60h (96)        MFM mode, skip deleted data address mark
 576+ B6C3              ; 0               Do auto select format
 577+ B6C3              ;
 578+ B6C3              ;
 579+ B6C3              ; CP/M File compatibility
 580+ B6C3              ;
 581+ B6C3              ; +3DOS uses the CP/M file structure, subject to the following
 582+ B6C3              ; restrictions:
 583+ B6C3              ;
 584+ B6C3              ;         - Maximum file size of 8 megabytes (CP/M Plus supports a
 585+ B6C3              ;             maximum of 32 megabytes).
 586+ B6C3              ;
 587+ B6C3              ;         - Maximum drive size of 8 megabytes (CP/M Plus supports a
 588+ B6C3              ;             maximum of 128 megabytes).
 589+ B6C3              ;
 590+ B6C3              ;         - Directory labels are ignored.
 591+ B6C3              ;
 592+ B6C3              ;         - No passwords. XFCBs will be erased, renamed, etc., along
 593+ B6C3              ;             with their file(s) but are otherwise ignored.
 594+ B6C3              ;
 595+ B6C3              ;         - No date and time stamps. SFCBs are initialised to zero when
 596+ B6C3              ;             a file is created, but are otherwise ignored.
 597+ B6C3              ;
 598+ B6C3              ;         - The archive file attribute is ignored, i.e. it is unaffected
 599+ B6C3              ;             by all routines except DOS SET ATTRIBUTES.
 600+ B6C3              ;
 601+ B6C3              ;
 602+ B6C3              ; File model
 603+ B6C3              ;
 604+ B6C3              ; A file is an array of bytes which may be of any length from 0 to 8
 605+ B6C3              ; megabytes. Associated with each open file is a 24 bit file
 606+ B6C3              ; pointer. The file pointer is the address of the next byte to be
 607+ B6C3              ; written or read. The file pointer is automatically advanced after each
 608+ B6C3              ; read or write operation, however, the user may set it to any value
 609+ B6C3              ; required for random access.
 610+ B6C3              ;
 611+ B6C3              ; The end of file position (EOF) is the lowest byte position that is
 612+ B6C3              ; greater than all written byte positions. Files without headers can
 613+ B6C3              ; only record their EOF position to the start of the next 128 byte
 614+ B6C3              ; record, i.e. ceiling(EOF/128). Files with headers have their EOF
 615+ B6C3              ; position recorded exactly.
 616+ B6C3              ;
 617+ B6C3              ; Writing a byte after the EOF position will extend the file and advance
 618+ B6C3              ; the EOF position.
 619+ B6C3              ;
 620+ B6C3              ; Reading a byte at (or beyond) the EOF position will return an EOF
 621+ B6C3              ; error.
 622+ B6C3              ;
 623+ B6C3              ; Reading an unwritten byte below the EOF position will either return a
 624+ B6C3              ; nonsensical byte or an EOF error. (Reading unwritten bytes is not
 625+ B6C3              ; recommended.)
 626+ B6C3              ;
 627+ B6C3              ;
 628+ B6C3              ; Changing disks
 629+ B6C3              ;
 630+ B6C3              ; Under +3DOS, a disk may be changed or removed whenever the drive is
 631+ B6C3              ; not being accessed (and there are no files open on that drive). There
 632+ B6C3              ; is no need to log in a disk.
 633+ B6C3              ;
 634+ B6C3              ; A disk should not be changed while there are files open on it. If,
 635+ B6C3              ; however, a disk is changed while there are still files open on it,
 636+ B6C3              ; then as soon as +3DOS detects this, the user will be prompted to
 637+ B6C3              ; insert the correct disk. +3DOS can only detect this changed when it
 638+ B6C3              ; reads the directory from the disk.
 639+ B6C3              ;
 640+ B6C3              ; Note that changing a disk while it is still being written to may
 641+ B6C3              ; corrupt the data on the disk.
 642+ B6C3              ;
 643+ B6C3              ;
 644+ B6C3              ; Logical to physical drive mapping
 645+ B6C3              ;
 646+ B6C3              ; If required, two logical drives (A: and B:) can be mapped onto a
 647+ B6C3              ; single physical drive (unit 0). This may be useful for single disk
 648+ B6C3              ; drive systems.
 649+ B6C3              ;
 650+ B6C3              ; To enable this mapping, the routine DOS MAP B is called, passing to it
 651+ B6C3              ; the address of a routine CHANGE DISK. Whenever unit 0 is accessed, a
 652+ B6C3              ; check is made to see if the disk in unit 0 is for the required logical
 653+ B6C3              ; drive. If not, then CHANGE DISK is called. CHANGE DISK is passed the
 654+ B6C3              ; address of a message and the required logical drive, and the user
 655+ B6C3              ; should be prompted with the message...
 656+ B6C3              ;
 657+ B6C3              ;         Please put the disk for x: into the drive then press any key
 658+ B6C3              ;
 659+ B6C3              ; ...(where x is the name of the logical drive, e.g. 'A:' or 'B:'). The
 660+ B6C3              ; routine should then wait for a key to be pressed before returning,
 661+ B6C3              ; after which it is assumed that the disk in unit 0 is for the required
 662+ B6C3              ; logical drive.
 663+ B6C3              ;
 664+ B6C3              ; DOS MAP B can also be used to re-map B onto unit 1. If unit 1 does not
 665+ B6C3              ; exist, then drive B: is disabled.
 666+ B6C3              ;
 667+ B6C3              ;
 668+ B6C3              ; +3DOS Error codes
 669+ B6C3              ;
 670+ B6C3              ; Many +3DOS routines can fail. This is indicated with 'carry' false and
 671+ B6C3              ; an error code in the A register. The error codes are...
 672+ B6C3              ;
 673+ B6C3              ; Recoverable disk errors:
 674+ B6C3              ;
 675+ B6C3              ; 0       Drive not ready
 676+ B6C3              ; 1       Disk is write protected
 677+ B6C3              ; 2       Seek fail
 678+ B6C3              ; 3       CRC data error
 679+ B6C3              ; 4       No data
 680+ B6C3              ; 5       Missing address mark
 681+ B6C3              ; 6       Unrecognised disk format
 682+ B6C3              ; 7       Unknown disk error
 683+ B6C3              ; 8       Disk changed whilst +3DOS was using it
 684+ B6C3              ; 9       Unsuitable media for drive
 685+ B6C3              ;
 686+ B6C3              ; Non-recoverable errors:
 687+ B6C3              ;
 688+ B6C3              ; 20      Bad filename
 689+ B6C3              ; 21      Bad parameter
 690+ B6C3              ; 22      Drive not found
 691+ B6C3              ; 23      File not found
 692+ B6C3              ; 24      File already exists
 693+ B6C3              ; 25      End of file
 694+ B6C3              ; 26      Disk full
 695+ B6C3              ; 27      Directory full
 696+ B6C3              ; 28      Read-only file
 697+ B6C3              ; 29      File number not open (or open with wrong access)
 698+ B6C3              ; 30      Access denied (file is in use already)
 699+ B6C3              ; 31      Cannot rename between drives
 700+ B6C3              ; 32      Extent missing (which should be there)
 701+ B6C3              ; 33      Uncached (software error)
 702+ B6C3              ; 34      File too big (trying to read or write past 8 megabytes)
 703+ B6C3              ; 35      Disk not bootable (boot sector is not acceptable to DOS BOOT)
 704+ B6C3              ; 36      Drive in use (trying to re-map or remove a drive with files
 705+ B6C3              ;           open)
 706+ B6C3              ;
 707+ B6C3              ; As an example, the report 'Unsuitable media for drive' is caused by
 708+ B6C3              ; trying to write to a single track disk in a double track drive, or
 709+ B6C3              ; trying to read or write a double track disk in a single track drive.
 710+ B6C3              ;
 711+ B6C3              ; The report 'Missing address mark' is the error returned when trying to
 712+ B6C3              ; access a disk that is not formatted (although this is not the sole
 713+ B6C3              ; reason for the error).
 714+ B6C3              ;
 715+ B6C3              ;
 716+ B6C3              ; +3DOS Messages
 717+ B6C3              ;
 718+ B6C3              ; If error messages are enabled (DOS SET MESSAGE) then, in the event of
 719+ B6C3              ; a recoverable disk error, +3DOS will pass the ALERT routine a message
 720+ B6C3              ; and the user should be prompted to '- Retry, Ignore or Cancel?' If the
 721+ B6C3              ; user replies 'R', then the disk operation is retried. If the reply is
 722+ B6C3              ; 'I', then the error is ignored, and if the reply is 'C', then the
 723+ B6C3              ; operation is cancelled and an error condition is returned to the
 724+ B6C3              ; caller. If error messages are disabled or if the error is not
 725+ B6C3              ; recoverable, then no message is displayed and an error condition is
 726+ B6C3              ; returned to the caller.
 727+ B6C3              ;
 728+ B6C3              ;
 729+ B6C3              ; Essential filing system routines
 730+ B6C3              ;
 731+ B6C3
 732+ B6C3              dos_initialise: equ 0x0100 ; (256)
 733+ B6C3
 734+ B6C3              ; Initialise +3DOS.
 735+ B6C3              ; Initialise disk drivers.
 736+ B6C3              ; Initialise cache and the RAMdisk.
 737+ B6C3              ; All files closed.
 738+ B6C3              ; All drives logged out.
 739+ B6C3              ; Default drive A: (if disk interface present), else M:.
 740+ B6C3              ; Default user 0.
 741+ B6C3              ; Retry count 15.
 742+ B6C3              ; Error messages disabled.
 743+ B6C3              ;
 744+ B6C3              ; ENTRY CONDITIONS
 745+ B6C3              ;         None
 746+ B6C3              ;
 747+ B6C3              ; EXIT CONDITIONS
 748+ B6C3              ;         If OK:
 749+ B6C3              ;                 Carry true
 750+ B6C3              ;                 A corrupt
 751+ B6C3              ;         Otherwise:
 752+ B6C3              ;                 Carry false
 753+ B6C3              ;                 A=Error code
 754+ B6C3              ;         Always:
 755+ B6C3              ;                 BC DE HL IX corrupt
 756+ B6C3              ;                 All other registers preserved
 757+ B6C3              ;
 758+ B6C3              ;
 759+ B6C3
 760+ B6C3              dos_version: equ 0x0103 ; (259)
 761+ B6C3
 762+ B6C3              ; Get the DOS issue and version numbers.
 763+ B6C3              ;
 764+ B6C3              ; ENTRY CONDITIONS
 765+ B6C3              ;         None
 766+ B6C3              ;
 767+ B6C3              ; EXIT CONDITIONS
 768+ B6C3              ;                 D=Issue
 769+ B6C3              ;                 E=Version (within issue)
 770+ B6C3              ;         Always:
 771+ B6C3              ;                 AF BC HL IX corrupt
 772+ B6C3              ;                 All other registers preserved
 773+ B6C3              ;
 774+ B6C3              ;
 775+ B6C3
 776+ B6C3              dos_open: equ 0x0106 ; (262)
 777+ B6C3
 778+ B6C3              ; Create and/or open a file
 779+ B6C3              ;
 780+ B6C3              ; There is a choice of action depending on whether or not the file
 781+ B6C3              ; already exists. The choices are 'open action' or 'create action', and
 782+ B6C3              ; are specified in DE. If the file already exists, then the open action
 783+ B6C3              ; is followed; otherwise the create action is followed.
 784+ B6C3              ;
 785+ B6C3              ; Open action
 786+ B6C3              ;
 787+ B6C3              ;         0. Error - File already exists.
 788+ B6C3              ;
 789+ B6C3              ;         1. Open the file, read the header (if any). Position file
 790+ B6C3              ;            pointer after header.
 791+ B6C3              ;
 792+ B6C3              ;         2. Open the file, ignore any header. Position file pointer at
 793+ B6C3              ;            000000h (0).
 794+ B6C3              ;
 795+ B6C3              ;         3. Assume given filename is 'filename.type'. Erase
 796+ B6C3              ;            'filename.BAK' (if it exists). Rename 'filename.type' to
 797+ B6C3              ;            'filename.BAK'. Follow create action.
 798+ B6C3              ;
 799+ B6C3              ;         4. Erase existing version. Follow create action.
 800+ B6C3              ;
 801+ B6C3              ; Create action
 802+ B6C3              ;
 803+ B6C3              ;         0. Error - File does not exist.
 804+ B6C3              ;
 805+ B6C3              ;         1. Create and open new file with a header. Position file
 806+ B6C3              ;            pointer after header.
 807+ B6C3              ;
 808+ B6C3              ;         2. Create and open new file without a header. Position file
 809+ B6C3              ;            pointer at 000000h (0).
 810+ B6C3              ;
 811+ B6C3              ; (Example: To simulate the tape action of... 'if the file exists open
 812+ B6C3              ; it, otherwise create it with a header', set open action = 1, create
 813+ B6C3              ; action = 1.)
 814+ B6C3              ;
 815+ B6C3              ; (Example: To open a file and report an error if it does not exist, set
 816+ B6C3              ; open action = 1, create action = 0.)
 817+ B6C3              ;
 818+ B6C3              ; (Example: To create a new file with a header, first renaming any
 819+ B6C3              ; existing version to '.BAK', set open action = 3, create action = 1.)
 820+ B6C3              ;
 821+ B6C3              ; Files with headers have their EOF position recorded as the smallest
 822+ B6C3              ; byte position greater than all written byte positions.
 823+ B6C3              ;
 824+ B6C3              ; Files without headers have their EOF position recorded as the byte at
 825+ B6C3              ; the start of the smallest 128 byte record position greater than all
 826+ B6C3              ; written record positions.
 827+ B6C3              ;
 828+ B6C3              ; Soft-EOF is the character 1Ah (26) and is nothing to do with the EOF
 829+ B6C3              ; position, only the routine DOS BYTE READ knows about soft-EOF.
 830+ B6C3              ;
 831+ B6C3              ; The header data area is 8 bytes long and may be used by the caller for
 832+ B6C3              ; any purpose whatsoever. If open action = 1, and the file exists (and
 833+ B6C3              ; has a header), then the header data is read from the file, otherwise
 834+ B6C3              ; the header data is zeroised. The header data is available even if the
 835+ B6C3              ; file does not have a header. Call DOS REF HEAD to access the header
 836+ B6C3              ; data.
 837+ B6C3              ;
 838+ B6C3              ; Note that +3 BASIC makes use of the first 7 of these 8 bytes as
 839+ B6C3              ; follows:
 840+ B6C3              ;
 841+ B6C3              ; +---------------+-------+-------+-------+-------+-------+-------+-------+
 842+ B6C3              ; | BYTE          |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
 843+ B6C3              ; +---------------+-------+-------+-------+-------+-------+-------+-------+
 844+ B6C3              ; | Program           0   file length     8000h or LINE   offset to prog  |
 845+ B6C3              ; | Numeric array     1   file length     xxx     name    xxx     xxx     |
 846+ B6C3              ; | Character array   2   file length     xxx     name    xxx     xxx     |
 847+ B6C3              ; | CODE or SCREEN$   3   file length     load address    xxx     xxx     |
 848+ B6C3              ; +-----------------------------------------------------------------------+
 849+ B6C3              ;
 850+ B6C3              ; (xxx = doesn't matter)
 851+ B6C3              ;
 852+ B6C3              ; If creating a file that will subsequently be LOADed within BASIC, then
 853+ B6C3              ; these bytes should be filled with the relevant values.
 854+ B6C3              ;
 855+ B6C3              ; If the file is opened with exclusive-write or exclusive-read-write
 856+ B6C3              ; access (and the file has a header), then the header is updated when
 857+ B6C3              ; the file is closed.
 858+ B6C3              ;
 859+ B6C3              ; A file that is already open for shared-read access on another file
 860+ B6C3              ; number may only be opened for shared-read access on this file number.
 861+ B6C3              ;
 862+ B6C3              ; A file that is already open for exclusive-read or exclusive-write or
 863+ B6C3              ; exclusive-read-write access on another file number may not be opened
 864+ B6C3              ; on this file number.
 865+ B6C3              ;
 866+ B6C3              ; ENTRY CONDITIONS
 867+ B6C3              ;         B = File number 0...15
 868+ B6C3              ;         C = Access mode required
 869+ B6C3              ;                 Bits 0...2 values:
 870+ B6C3              ;                         1 = exclusive-read
 871+ B6C3              ;                         2 = exclusive-write
 872+ B6C3              ;                         3 = exclusive-read-write
 873+ B6C3              ;                         5 = shared-read
 874+ B6C3              ;                 Bits 3...7 = 0 (reserved)
 875+ B6C3              ;         D = Create action
 876+ B6C3              ;         E = Open action
 877+ B6C3              ;         HL = Address of filename (no wildcards)
 878+ B6C3              ;
 879+ B6C3              ; EXIT CONDITIONS
 880+ B6C3              ;         If file newly created:
 881+ B6C3              ;                 Carry true
 882+ B6C3              ;                 Zero true
 883+ B6C3              ;                 A corrupt
 884+ B6C3              ;         If existing file opened:
 885+ B6C3              ;                 Carry true
 886+ B6C3              ;                 Zero false
 887+ B6C3              ;                 A corrupt
 888+ B6C3              ;         Otherwise:
 889+ B6C3              ;                 Carry false
 890+ B6C3              ;                 A = Error code
 891+ B6C3              ;         Always:
 892+ B6C3              ;                 BC DE HL IX corrupt
 893+ B6C3              ;                 All other registers preserved
 894+ B6C3              ;
 895+ B6C3              ;
 896+ B6C3
 897+ B6C3              dos_close: equ 0x0109 ; (265)
 898+ B6C3
 899+ B6C3              ; Close a file.
 900+ B6C3              ;
 901+ B6C3              ; Write the header (if there is one).
 902+ B6C3              ;
 903+ B6C3              ; Write any outstanding data.
 904+ B6C3              ;
 905+ B6C3              ; Update the directory.
 906+ B6C3              ;
 907+ B6C3              ; Release the file number.
 908+ B6C3              ;
 909+ B6C3              ; All opened files must eventually be closed (or abandoned). A file
 910+ B6C3              ; number cannot be reused until it is closed (or abandoned).
 911+ B6C3              ;
 912+ B6C3              ; ENTRY CONDITIONS
 913+ B6C3              ;         B = File number
 914+ B6C3              ;
 915+ B6C3              ; EXIT CONDITIONS
 916+ B6C3              ;         If OK:
 917+ B6C3              ;                 Carry true
 918+ B6C3              ;                 A corrupt
 919+ B6C3              ;         Otherwise:
 920+ B6C3              ;                 Carry false
 921+ B6C3              ;                 A = Error code
 922+ B6C3              ;         Always:
 923+ B6C3              ;                 BC DE HL IX corrupt
 924+ B6C3              ;                 All other registers preserved
 925+ B6C3              ;
 926+ B6C3              ;
 927+ B6C3
 928+ B6C3              dos_abandon: equ 0x010C ; (268)
 929+ B6C3
 930+ B6C3              ; Abandon a file.
 931+ B6C3              ;
 932+ B6C3              ; Similar to DOS CLOSE, except that any header, or data, or directory
 933+ B6C3              ; data yet to be written to disk is discarded. This routine should only
 934+ B6C3              ; be used to force a file closed in the event that DOS CLOSE is unable
 935+ B6C3              ; to close the file (for example, if the media is damaged or permanently
 936+ B6C3              ; changed or removed).
 937+ B6C3              ;
 938+ B6C3              ; ENTRY CONDITIONS
 939+ B6C3              ;         B = File number
 940+ B6C3              ;
 941+ B6C3              ; EXIT CONDITIONS
 942+ B6C3              ;         If OK:
 943+ B6C3              ;                 Carry true
 944+ B6C3              ;                 A corrupt
 945+ B6C3              ;         Otherwise:
 946+ B6C3              ;                 Carry false
 947+ B6C3              ;                 A = Error code
 948+ B6C3              ;         Always:
 949+ B6C3              ;                 BC DE HL IX corrupt
 950+ B6C3              ;                 All other registers preserved
 951+ B6C3              ;
 952+ B6C3              ;
 953+ B6C3
 954+ B6C3              dos_ref_head: equ 0x010F ; (271)
 955+ B6C3
 956+ B6C3              ; Point at the header data for this file.
 957+ B6C3              ;
 958+ B6C3              ; The header data area is 8 bytes long and may be used by the caller for
 959+ B6C3              ; any purpose whatsoever. It is available even if the file does not have
 960+ B6C3              ; a header; however, only files with a header and opened with write
 961+ B6C3              ; access will have the header data recorded on disk.
 962+ B6C3              ;
 963+ B6C3              ; Note that +3 BASIC uses these 8 bytes (see the note under DOS OPEN
 964+ B6C3              ; which gives the details). If creating a file that will subsequently be
 965+ B6C3              ; LOADed within BASIC, then those bytes should be filled with the
 966+ B6C3              ; relevant values.
 967+ B6C3              ;
 968+ B6C3              ; ENTRY CONDITIONS
 969+ B6C3              ;         B = File number
 970+ B6C3              ;
 971+ B6C3              ; EXIT CONDITIONS
 972+ B6C3              ;         If OK, but file doesn't have a header:
 973+ B6C3              ;                 Carry true
 974+ B6C3              ;                 Zero true
 975+ B6C3              ;                 A corrupt
 976+ B6C3              ;                 IX = Address of header data in page 7
 977+ B6C3              ;         If OK, file has a header:
 978+ B6C3              ;                 Carry true
 979+ B6C3              ;                 Zero false
 980+ B6C3              ;                 A corrupt
 981+ B6C3              ;                 IX = Address of header data in page 7
 982+ B6C3              ;         Otherwise:
 983+ B6C3              ;                 Carry false
 984+ B6C3              ;                 A = Error code
 985+ B6C3              ;                 IX corrupt
 986+ B6C3              ;         Always:
 987+ B6C3              ;                 BC DE HL corrupt
 988+ B6C3              ;                 All other registers preserved
 989+ B6C3              ;
 990+ B6C3              ;
 991+ B6C3
 992+ B6C3              dos_read: equ 0x0112 ; (274)
 993+ B6C3
 994+ B6C3              ; Read bytes from a file into memory.
 995+ B6C3              ;
 996+ B6C3              ; Advance the file pointer.
 997+ B6C3              ;
 998+ B6C3              ; The destination buffer is in the following memory configuration:
 999+ B6C3              ;
1000+ B6C3              ;         C000h...FFFFh (49152...65535)   - Page specified in C
1001+ B6C3              ;         8000h...BFFFh (32768...49151)   - Page 2
1002+ B6C3              ;         4000h...7FFFh (16384...32767)   - Page 5
1003+ B6C3              ;         0000h...3FFFh (0...16383)       - DOS ROM
1004+ B6C3              ;
1005+ B6C3              ; The routine does not consider soft-EOF.
1006+ B6C3              ;
1007+ B6C3              ; Reading EOF will produce an error.
1008+ B6C3              ;
1009+ B6C3              ; ENTRY CONDITIONS
1010+ B6C3              ;         B = File number
1011+ B6C3              ;         C = Page for C000h (49152)...FFFFh (65535)
1012+ B6C3              ;         DE = Number of bytes to read (0 means 64K)
1013+ B6C3              ;         HL = Address for bytes to be read
1014+ B6C3              ;
1015+ B6C3              ; EXIT CONDITIONS
1016+ B6C3              ;         If OK:
1017+ B6C3              ;                 Carry true
1018+ B6C3              ;                 A DE corrupt
1019+ B6C3              ;         Otherwise:
1020+ B6C3              ;                 Carry false
1021+ B6C3              ;                 A = Error code
1022+ B6C3              ;                 DE = Number of bytes remaining unread
1023+ B6C3              ;         Always:
1024+ B6C3              ;                 BC HL IX corrupt
1025+ B6C3              ;                 All other registers preserved
1026+ B6C3              ;
1027+ B6C3              ;
1028+ B6C3
1029+ B6C3              dos_write: equ 0x0115 ; (277)
1030+ B6C3
1031+ B6C3              ; Write bytes to a file from memory.
1032+ B6C3              ;
1033+ B6C3              ; Advance the file pointer.
1034+ B6C3              ;
1035+ B6C3              ; The source buffer is in the following memory configuration:
1036+ B6C3              ;
1037+ B6C3              ;         C000h...FFFFh (49152...65535)   - Page specified in C
1038+ B6C3              ;         8000h...BFFFh (32768...49151)   - Page 2
1039+ B6C3              ;         4000h...7FFFh (16384...32767)   - Page 5
1040+ B6C3              ;         0000h...3FFFh (0...16383)       - DOS ROM
1041+ B6C3              ;
1042+ B6C3              ; ENTRY CONDITIONS
1043+ B6C3              ;         B = File number
1044+ B6C3              ;         C = Page for C000h (49152)...FFFFh (65535)
1045+ B6C3              ;         DE = Number of bytes to write (0 means 64K)
1046+ B6C3              ;         HL = Address for bytes to write
1047+ B6C3              ;
1048+ B6C3              ; EXIT CONDITIONS
1049+ B6C3              ;         If OK:
1050+ B6C3              ;                 Carry true
1051+ B6C3              ;                 A DE corrupt
1052+ B6C3              ;         Otherwise:
1053+ B6C3              ;                 Carry false
1054+ B6C3              ;                 A = Error code
1055+ B6C3              ;                 DE = Number of bytes remaining unwritten
1056+ B6C3              ;         Always:
1057+ B6C3              ;                 BC HL IX corrupt
1058+ B6C3              ;                 All other registers preserved
1059+ B6C3              ;
1060+ B6C3              ;
1061+ B6C3
1062+ B6C3              dos_byte_read: equ 0x0118 ; (280)
1063+ B6C3
1064+ B6C3              ; Read a byte from a file.
1065+ B6C3              ;
1066+ B6C3              ; Advance the file pointer.
1067+ B6C3              ;
1068+ B6C3              ; Tests for soft-EOF (1Ah (26)). As this condition is not latched, it is
1069+ B6C3              ; possible to read past soft-EOF.
1070+ B6C3              ;
1071+ B6C3              ; EOF is latched.
1072+ B6C3              ;
1073+ B6C3              ; The caller must decide whether or not soft-EOF is of interest. This
1074+ B6C3              ; would normally be the case only when reading an ASCII file.
1075+ B6C3              ;
1076+ B6C3              ; Reading EOF will produce an error.
1077+ B6C3              ;
1078+ B6C3              ; ENTRY CONDITIONS
1079+ B6C3              ;         B = File number
1080+ B6C3              ;
1081+ B6C3              ; EXIT CONDITIONS
1082+ B6C3              ;         If OK - Byte <> 1Ah (26) (soft-EOF)
1083+ B6C3              ;                 Carry true
1084+ B6C3              ;                 Zero false
1085+ B6C3              ;                 A corrupt
1086+ B6C3              ;                 C = Byte
1087+ B6C3              ;         If OK - Byte = 1Ah (26) (soft-EOF)
1088+ B6C3              ;                 Carry true
1089+ B6C3              ;                 Zero true
1090+ B6C3              ;                 A corrupt
1091+ B6C3              ;                 C = Byte
1092+ B6C3              ;         Otherwise:
1093+ B6C3              ;                 Carry false
1094+ B6C3              ;                 A = Error code
1095+ B6C3              ;                 C corrupt
1096+ B6C3              ;         Always:
1097+ B6C3              ;                 B DE HL IX corrupt
1098+ B6C3              ;                 All other registers preserved
1099+ B6C3              ;
1100+ B6C3              ;
1101+ B6C3
1102+ B6C3              dos_byte_write: equ 0x011B ; (283)
1103+ B6C3
1104+ B6C3              ; Write a byte to a file.
1105+ B6C3              ;
1106+ B6C3              ; Advance the file pointer.
1107+ B6C3              ;
1108+ B6C3              ; ENTRY CONDITIONS
1109+ B6C3              ;         B = File number
1110+ B6C3              ;         C = Byte to write
1111+ B6C3              ;
1112+ B6C3              ; EXIT CONDITIONS
1113+ B6C3              ;         If OK:
1114+ B6C3              ;                 Carry true
1115+ B6C3              ;                 A corrupt
1116+ B6C3              ;         Otherwise:
1117+ B6C3              ;                 Carry false
1118+ B6C3              ;                 A = Error code
1119+ B6C3              ;         Always:
1120+ B6C3              ;                 BC DE HL IX corrupt
1121+ B6C3              ;                 All otehr registers preserved
1122+ B6C3              ;
1123+ B6C3              ;
1124+ B6C3
1125+ B6C3              dos_catalog: equ 0x011E ; (286)
1126+ B6C3
1127+ B6C3              ; Fills a buffer with part of the directory (sorted).
1128+ B6C3              ;
1129+ B6C3              ; The filename specifies the drive, user and a (possibly ambiguous)
1130+ B6C3              ; filename.
1131+ B6C3              ;
1132+ B6C3              ; Since the size of a directory is variable (and may be quite large),
1133+ B6C3              ; this routine permits the directory to be catalogued in a number of
1134+ B6C3              ; small sections. The caller passes a buffer pre-loaded with the first
1135+ B6C3              ; required filename, or zeroes for the start of the directory. The
1136+ B6C3              ; buffer is loaded with part (or all, if it fits) of the directory
1137+ B6C3              ; sorted in ASCII order. If more of the directory is required, this
1138+ B6C3              ; routine is re-called with the buffer re-initialised with the last file
1139+ B6C3              ; previously returned. This procedure is followed repeatedly until all
1140+ B6C3              ; of the directory has been catalogued.
1141+ B6C3              ;
1142+ B6C3              ; Note that +3DOS format disks (which are the same as single-sided,
1143+ B6C3              ; single track AMSTRAD PCW range format disks) may have a maximum of 64
1144+ B6C3              ; directory entries.
1145+ B6C3              ;
1146+ B6C3              ; Buffer format:
1147+ B6C3              ;
1148+ B6C3              ;         Entry 0
1149+ B6C3              ;         Entry 1
1150+ B6C3              ;         Entry 2
1151+ B6C3              ;         Entry 3
1152+ B6C3              ;         ...to...
1153+ B6C3              ;         Entry n
1154+ B6C3              ;
1155+ B6C3              ; Entry 0 must be preloaded with the first 'filename.type'
1156+ B6C3              ; required. Entry 1 will contain the first matching filename greater
1157+ B6C3              ; than the preloaded entry (if any). A zeroised preload entry is OK.
1158+ B6C3              ;
1159+ B6C3              ; If the buffer is too small for the directory, this routine can be
1160+ B6C3              ; called again with entry 0 replaced by entry n to fetch the next part
1161+ B6C3              ; of the directory.
1162+ B6C3              ;
1163+ B6C3              ; Entry format (13 bytes long):
1164+ B6C3              ;
1165+ B6C3              ;         Bytes 0...7     - Filename (ASCII) left justified, space
1166+ B6C3              ;                            filled
1167+ B6C3              ;         Bytes 6...10    - Type (ASCII) left justified, space filledd
1168+ B6C3              ;         Bytes 11...12   - Size in kilobytes (binary)
1169+ B6C3              ;
1170+ B6C3              ; The file size is the amount of disk space allocated to the file, not
1171+ B6C3              ; necessarily the same as the amount used by the file.
1172+ B6C3              ;
1173+ B6C3              ; ENTRY CONDITIONS
1174+ B6C3              ;         B = n+1, size of buffer in entries, >=2
1175+ B6C3              ;         C = Filter
1176+ B6C3              ;                 bit 0 = include system files (is set)
1177+ B6C3              ;                 bits 1...7 = 0 (reserved)
1178+ B6C3              ;         DE = Address of buffer (first entry initialised)
1179+ B6C3              ;         HL = Address of filename (wildcards permitted)
1180+ B6C3              ;
1181+ B6C3              ; EXIT CONDITIONS
1182+ B6C3              ;         If OK:
1183+ B6C3              ;                 Carry true
1184+ B6C3              ;                 A corrupt
1185+ B6C3              ;                 B = Number of completed entries in buffer, 0...n.
1186+ B6C3              ;                     (If B = n, there may be more to come).
1187+ B6C3              ;
1188+ B6C3              ;         Otherwise:
1189+ B6C3              ;                 Carry false
1190+ B6C3              ;                 A = Error code
1191+ B6C3              ;                 B corrupt
1192+ B6C3              ;         Always:
1193+ B6C3              ;                 C DE HL IX corrupt
1194+ B6C3              ;                 All other registers preserved
1195+ B6C3              ;
1196+ B6C3              ;
1197+ B6C3
1198+ B6C3              dos_free_space: equ 0x0121 ; (289)
1199+ B6C3
1200+ B6C3              ; How much free space is there on this drive?
1201+ B6C3              ;
1202+ B6C3              ; ENTRY CONDITIONS
1203+ B6C3              ;         A = Drive, ASCII 'A'...'P'
1204+ B6C3              ;
1205+ B6C3              ; EXIT CONDITIONS
1206+ B6C3              ;         If OK:
1207+ B6C3              ;                 Carry true
1208+ B6C3              ;                 A corrupt
1209+ B6C3              ;                 HL = Free space (in kilobytes)
1210+ B6C3              ;         Otherwise:
1211+ B6C3              ;                 Carry false
1212+ B6C3              ;                 A = Error code
1213+ B6C3              ;                 HL corrupt
1214+ B6C3              ;         Always:
1215+ B6C3              ;                 BC DE IX corrupt
1216+ B6C3              ;                 All other registers preserved
1217+ B6C3              ;
1218+ B6C3              ;
1219+ B6C3
1220+ B6C3              dos_delete: equ 0x0124 ; (292)
1221+ B6C3
1222+ B6C3              ; XXX This call is not documented in the WoS' HTML version of the +3 manual,
1223+ B6C3              ; but first guessed and finally confirmet it with the original Spanish manual.
1224+ B6C3
1225+ B6C3              ; Delete an existing file.
1226+ B6C3              ;
1227+ B6C3              ; File must not be open on any file number.
1228+ B6C3              ;
1229+ B6C3              ; ENTRY CONDITIONS HL = Address of filename (wildcards permitted)
1230+ B6C3              ;
1231+ B6C3              ; EXIT CONDITIONS If OK: Carry true A corrupt Otherwise: Carry false A = Error
1232+ B6C3              ; code Always: BC DE HL IX corrupt All other registers preserved
1233+ B6C3
1234+ B6C3              dos_rename: equ 0x0127 ; (295)
1235+ B6C3
1236+ B6C3              ; Rename an existing file.
1237+ B6C3              ;
1238+ B6C3              ; File must not be open on any file number. A file with the new filename
1239+ B6C3              ; must not exist. The new name must specify, or default to, the sme
1240+ B6C3              ; drive as the old name.
1241+ B6C3              ;
1242+ B6C3              ; ENTRY CONDITIONS
1243+ B6C3              ;         DE = Address of new filename (no wildcards)
1244+ B6C3              ;         HL = Address of old filename (no wildcards)
1245+ B6C3              ;
1246+ B6C3              ; EXIT CONDITIONS
1247+ B6C3              ;         If OK:
1248+ B6C3              ;                 Carry true
1249+ B6C3              ;                 A corrupt
1250+ B6C3              ;         Otherwise:
1251+ B6C3              ;                 Carry false
1252+ B6C3              ;                 A = Error code
1253+ B6C3              ;         Always:
1254+ B6C3              ;                 BC DE HL IX corrupt
1255+ B6C3              ;                 All other registers preserved
1256+ B6C3              ;
1257+ B6C3              ;
1258+ B6C3
1259+ B6C3              dos_boot: equ 0x012A ; (298)
1260+ B6C3
1261+ B6C3              ; Boot from disk.
1262+ B6C3              ;
1263+ B6C3              ; This routine loads a single bootstrap sector from the disk in drive A:
1264+ B6C3              ; into memory and enters it. This is for loading games or other
1265+ B6C3              ; operating systems.
1266+ B6C3              ;
1267+ B6C3              ; Bootstrap environment:
1268+ B6C3              ;
1269+ B6C3              ;         C000h...FFFFh (49152...65535)   - Page 3
1270+ B6C3              ;         8000h...BFFFh (32768...49151)   - Page 6
1271+ B6C3              ;         4000h...7FFFh (16384...32767)   - Page 7
1272+ B6C3              ;         0000h...3FFFh (0...16383)       - Page 4
1273+ B6C3              ;
1274+ B6C3              ; The bootstrap sector is on side 0, track 0, sector 1. It is loaded at
1275+ B6C3              ; FE00h (65024) and entered at FE10h (65040). Interrupts are disabled.
1276+ B6C3              ; SP is at FE00h (65024). The sum of all bytes in the sector must equal
1277+ B6C3              ; 3 MOD 256 (byte 15 can be set to the required value to achieve this).
1278+ B6C3              ;
1279+ B6C3              ; ENTRY CONDITIONS
1280+ B6C3              ;         None
1281+ B6C3              ;
1282+ B6C3              ; EXIT CONDITIONS
1283+ B6C3              ;         If OK:
1284+ B6C3              ;                 No exit (as the bootstrap will be entered)
1285+ B6C3              ;         Otherwise:
1286+ B6C3              ;                 Carry false
1287+ B6C3              ;                 A = Error code
1288+ B6C3              ;         Always:
1289+ B6C3              ;                 BC DE HL IX corrupt
1290+ B6C3              ;                 All other registers preserved
1291+ B6C3              ;
1292+ B6C3              ;
1293+ B6C3
1294+ B6C3              dos_set_drive: equ 0x012D ; (301)
1295+ B6C3
1296+ B6C3              ; Set the default drive (i.e. the drive implied by all filenames that do
1297+ B6C3              ; not specify a drive).
1298+ B6C3              ;
1299+ B6C3              ; The default drive is initially A:.
1300+ B6C3              ;
1301+ B6C3              ; Does not access the drive, but merely checks that there is a driver
1302+ B6C3              ; for it (which does not imply that the drive exists).
1303+ B6C3              ;
1304+ B6C3              ; This only affects routines that take filename parameters.
1305+ B6C3              ;
1306+ B6C3              ; ENTRY CONDITIONS
1307+ B6C3              ;         A = Drive, ASCII 'A'...'P' (FFh (255) = get default drive)
1308+ B6C3              ;
1309+ B6C3              ; EXIT CONDITIONS
1310+ B6C3              ;         If OK:
1311+ B6C3              ;                 Carry true
1312+ B6C3              ;                 A = Default drive
1313+ B6C3              ;         Otherwise:
1314+ B6C3              ;                 Carry false
1315+ B6C3              ;                 A = Error code
1316+ B6C3              ;         Always:
1317+ B6C3              ;                 BC DE HL IX corrupt
1318+ B6C3              ;                 All other registers preserved
1319+ B6C3              ;
1320+ B6C3              ;
1321+ B6C3
1322+ B6C3              dos_set_user: equ 0x0130 ; (304)
1323+ B6C3
1324+ B6C3              ; Set the default user area, i.e. the user area implied by all filenames
1325+ B6C3              ; that do not specify a user number.
1326+ B6C3              ;
1327+ B6C3              ; The default user number is intially 0.
1328+ B6C3              ;
1329+ B6C3              ; This only affects routines that take filename parameters.
1330+ B6C3              ;
1331+ B6C3              ; ENTRY CONDITIONS
1332+ B6C3              ;         A = User 0...15 (FFh (255) = get default user)
1333+ B6C3              ;
1334+ B6C3              ; EXIT CONDITIONS
1335+ B6C3              ;         If OK:
1336+ B6C3              ;                 Carry true
1337+ B6C3              ;                 A = Default user
1338+ B6C3              ;         Otherwise:
1339+ B6C3              ;                 Carry false
1340+ B6C3              ;                 A = Error code
1341+ B6C3              ;         Always:
1342+ B6C3              ;                 BC DE HL IX corrupt
1343+ B6C3              ;                 All other registers preserved
1344+ B6C3              ;
1345+ B6C3              ;
1346+ B6C3              ;
1347+ B6C3              ; Additional routines for games and operating systems
1348+ B6C3              ;
1349+ B6C3
1350+ B6C3              dos_get_position: equ 0x0133 ; (307)
1351+ B6C3
1352+ B6C3              ; Get the file pointer.
1353+ B6C3              ;
1354+ B6C3              ; ENTRY CONDITIONS
1355+ B6C3              ;         B = File number
1356+ B6C3              ;
1357+ B6C3              ; EXIT CONDITIONS
1358+ B6C3              ;         If OK:
1359+ B6C3              ;                 Carry true
1360+ B6C3              ;                 A corrupt
1361+ B6C3              ;                 E HL = File pointer 000000h...FFFFFFh (0...16777215)
1362+ B6C3              ;                 (E holds most significant byte; L holds leat
1363+ B6C3              ;                 significant byte)
1364+ B6C3              ;         Otherwise:
1365+ B6C3              ;                 Carry false
1366+ B6C3              ;                 A = Error code
1367+ B6C3              ;                 E HL corrupt
1368+ B6C3              ;         Always:
1369+ B6C3              ;                 BC D IX corrupt
1370+ B6C3              ;                 All other registers preserved
1371+ B6C3              ;
1372+ B6C3              ;
1373+ B6C3
1374+ B6C3              dos_set_position: equ 0x0136 ; (310)
1375+ B6C3
1376+ B6C3              ; Set the file pointer.
1377+ B6C3              ;
1378+ B6C3              ; Does not access the disk.
1379+ B6C3              ;
1380+ B6C3              ; Does not check (or care) if pointer is >= 8 megabytes.
1381+ B6C3              ;
1382+ B6C3              ; ENTRY CONDITIONS
1383+ B6C3              ;         B = File numbers
1384+ B6C3              ;         E HL = File pointer 000000h...FFFFFFh (0...16777215)
1385+ B6C3              ;         (E holds most significant byte; L holds leat
1386+ B6C3              ;         significant byte)
1387+ B6C3              ;
1388+ B6C3              ; EXIT CONDITIONS
1389+ B6C3              ;         If OK:
1390+ B6C3              ;                 Carry true
1391+ B6C3              ;                 A corrupt
1392+ B6C3              ;         Otherwise:
1393+ B6C3              ;                 Carry false
1394+ B6C3              ;                 A = Error code
1395+ B6C3              ;         Always:
1396+ B6C3              ;                 BC DE HL IX corrupt
1397+ B6C3              ;                 All other registers preserved
1398+ B6C3              ;
1399+ B6C3              ;
1400+ B6C3
1401+ B6C3              dos_get_eof: equ 0x0139 ; (313)
1402+ B6C3
1403+ B6C3              ; Get the end of file (EOF) file position greater than all written byte
1404+ B6C3              ; positions.
1405+ B6C3              ;
1406+ B6C3              ; Does not affect the file pointer.
1407+ B6C3              ;
1408+ B6C3              ; Does not consider soft-EOF.
1409+ B6C3              ;
1410+ B6C3              ; ENTRY CONDITIONS
1411+ B6C3              ;         B = File number
1412+ B6C3              ;
1413+ B6C3              ; EXIT CONDTITIONS
1414+ B6C3              ;         If OK:
1415+ B6C3              ;                 Carry true
1416+ B6C3              ;                 A corrupt
1417+ B6C3              ;                 E HL = File pointer 000000h...FFFFFFh (0...16777215)
1418+ B6C3              ;                 (E holds most significant byte; L holds leat
1419+ B6C3              ;                 significant byte)
1420+ B6C3              ;         Otherwise:
1421+ B6C3              ;                 Carry false
1422+ B6C3              ;                 A = Error code
1423+ B6C3              ;                 E HL Corrupt
1424+ B6C3              ;         Always:
1425+ B6C3              ;                 BC D IX corrupt
1426+ B6C3              ;                 All other registers preserved
1427+ B6C3              ;
1428+ B6C3              ;
1429+ B6C3              dos_get_1346: equ 0x013C ; (316)
1430+ B6C3              ;
1431+ B6C3              ; Get the current location of the cache and RAMdisk.
1432+ B6C3              ;
1433+ B6C3              ; Pages 1, 3, 4, 6 are considered as an array of 128 sector buffers
1434+ B6C3              ; (numbered 0...127), each of 512 bytes. The cache and RAMdisk occupy
1435+ B6C3              ; two separate (contiguous) areas of this array.
1436+ B6C3              ;
1437+ B6C3              ; Any unused sector buffers may be used by the caller.
1438+ B6C3              ;
1439+ B6C3              ; Note that the sizes may be smaller than those specified in DOS SET
1440+ B6C3              ; 1346, as there is an (unpublished) maximum size of cache and a minimum
1441+ B6C3              ; size of RAMdisk (4 sectors).
1442+ B6C3              ;
1443+ B6C3              ; ENTRY CONDITIONS
1444+ B6C3              ;         None
1445+ B6C3              ;
1446+ B6C3              ; EXIT CONDITIONS
1447+ B6C3              ;                 D = First buffer of cache
1448+ B6C3              ;                 E = Number of cache sector buffers
1449+ B6C3              ;                 H = First buffer of RAMdisk
1450+ B6C3              ;                 L = Number of RAMdisk sector buffers
1451+ B6C3              ;         Always:
1452+ B6C3              ;                 AF BC IX corrupt
1453+ B6C3              ;                 All other registers preserved
1454+ B6C3              ;
1455+ B6C3              ;
1456+ B6C3              dos_set_1346: equ 0x013F ; (319)
1457+ B6C3              ;
1458+ B6C3              ; Rebuild the sector cache and RAMdisk.
1459+ B6C3              ;
1460+ B6C3              ; This routine is used to make some store available to the user, or to
1461+ B6C3              ; return store to DOS.
1462+ B6C3              ;
1463+ B6C3              ; Note that if the RAMdisk is moved, ot its size is changed, then all
1464+ B6C3              ; files thereon are erased.
1465+ B6C3              ;
1466+ B6C3              ; Pages 1, 3, 4, 6 are considered as an array of 128 sector buffers
1467+ B6C3              ; (numbered 0...127), each of 512 bytes. The cache and RAMdisk occupy
1468+ B6C3              ; two separate (contiguous) areas of this array.
1469+ B6C3              ;
1470+ B6C3              ; The location and size of the cache and RAMdisk can be specified
1471+ B6C3              ; separately; any remaining buffers are unused by DOS and are available
1472+ B6C3              ; to the caller.
1473+ B6C3              ;
1474+ B6C3              ; Note that the sizes actually used may be smaller than those specified
1475+ B6C3              ; as in practice, there is a maximum cache size and a minimum size of
1476+ B6C3              ; RAMdisk (4 sectors).
1477+ B6C3              ;
1478+ B6C3              ; A cache size of 0 will still work but will seriously impair the floppy
1479+ B6C3              ; disk performance.
1480+ B6C3              ;
1481+ B6C3              ; This routine will fail if there are any files open on drive M:.
1482+ B6C3              ;
1483+ B6C3              ; ENTRY CONDITIONS
1484+ B6C3              ;         D = First buffer for cache
1485+ B6C3              ;         E = Number of cache sector buffers
1486+ B6C3              ;         H = First buffer for RAMdisk
1487+ B6C3              ;         L = Number of RAMdisk sector buffers
1488+ B6C3              ;         (Note that E + L <= 128)
1489+ B6C3              ;
1490+ B6C3              ; EXIT CONDITIONS
1491+ B6C3              ;         If OK:
1492+ B6C3              ;                 Carry true
1493+ B6C3              ;                 A corrupt
1494+ B6C3              ;         Otherwise:
1495+ B6C3              ;                 Carry false
1496+ B6C3              ;                 A = Error code
1497+ B6C3              ;         Always:
1498+ B6C3              ;                 BC DE HL IX corrupt
1499+ B6C3              ;                 All other registers preserved
1500+ B6C3              ;
1501+ B6C3              ;
1502+ B6C3
1503+ B6C3              dos_flush: equ 0x0142 ; (322)
1504+ B6C3
1505+ B6C3              ; Write any pending headers, data, directory entries for this drive.
1506+ B6C3              ;
1507+ B6C3              ; This routine ensures that the disk is up to date. It can be called at
1508+ B6C3              ; any time, even when files are open.
1509+ B6C3              ;
1510+ B6C3              ; ENTRY CONDITIONS
1511+ B6C3              ;         A = Drive, ASCII 'A'...'P'
1512+ B6C3              ;
1513+ B6C3              ; EXIT CONDITIONS
1514+ B6C3              ;         If OK:
1515+ B6C3              ;                 Carry true
1516+ B6C3              ;                 A corrupt
1517+ B6C3              ;         Otherwise:
1518+ B6C3              ;                 Carry false
1519+ B6C3              ;                 A = Error code
1520+ B6C3              ;         Always:
1521+ B6C3              ;                 BC DE HL IX corrupt
1522+ B6C3              ;                 All other registers preserved
1523+ B6C3              ;
1524+ B6C3              ;
1525+ B6C3
1526+ B6C3              dos_set_access: equ 0x0145 ; (325)
1527+ B6C3
1528+ B6C3              ; Try to change the access mode of an open file.
1529+ B6C3              ;
1530+ B6C3              ; This routine will fail if the file is already open, in an incompatible
1531+ B6C3              ; access mode, or if write access is required for a read-only file or
1532+ B6C3              ; disk.
1533+ B6C3              ;
1534+ B6C3              ; ENTRY CONDITIONS
1535+ B6C3              ;         B = File number
1536+ B6C3              ;         C = Access mode required
1537+ B6C3              ;                 Bits 0...2 values:
1538+ B6C3              ;                         1 = exclusive-read
1539+ B6C3              ;                         2 = exclusive-write
1540+ B6C3              ;                         3 = exclusive-read-write
1541+ B6C3              ;                         5 = shared-read
1542+ B6C3              ;                         (all other bit settings reserved)
1543+ B6C3              ;                 Bits 3...7 = 0 (reserved)
1544+ B6C3              ;
1545+ B6C3              ; EXIT CONDITIONS
1546+ B6C3              ;         If OK:
1547+ B6C3              ;                 Carry true
1548+ B6C3              ;                 A corrupt
1549+ B6C3              ;         Otherwise:
1550+ B6C3              ;                 Carry false
1551+ B6C3              ;                 A = Error code
1552+ B6C3              ;         Always:
1553+ B6C3              ;                 BC DE HL IX corrupt
1554+ B6C3              ;                 All other registers preserved
1555+ B6C3              ;
1556+ B6C3              ;
1557+ B6C3
1558+ B6C3              dos_set_attributes: equ 0x0148 ; (328)
1559+ B6C3
1560+ B6C3              ; Set a file's attributes.
1561+ B6C3              ;
1562+ B6C3              ; Only the file attributes f1'...f4', t1'...t3' can be set or
1563+ B6C3              ; cleared. The interface attributes f5'...f8' are always 0.
1564+ B6C3              ;
1565+ B6C3              ; This routine first sets the attributes specified in D, then clears
1566+ B6C3              ; those attributes specified in E, i.e. E has priority.
1567+ B6C3              ;
1568+ B6C3              ; ENTRY CONDITIONS
1569+ B6C3              ;         D = Attributes to set
1570+ B6C3              ;                 bit 0 = t3' Archive
1571+ B6C3              ;                 bit 1 = t2' System
1572+ B6C3              ;                 bit 2 = t1' Read-only
1573+ B6C3              ;                 bit 3 = f4'
1574+ B6C3              ;                 bit 4 = f3'
1575+ B6C3              ;                 bit 5 = f2'
1576+ B6C3              ;                 bit 6 = f1'
1577+ B6C3              ;         E = Attributes to clear
1578+ B6C3              ;                 bit 0 = t3' Archive
1579+ B6C3              ;                 bit 1 = t2' System
1580+ B6C3              ;                 bit 2 = t1' Read-only
1581+ B6C3              ;                 bit 3 = f4'
1582+ B6C3              ;                 bit 4 = f3'
1583+ B6C3              ;                 bit 5 = f2'
1584+ B6C3              ;                 bit 6 = f1'
1585+ B6C3              ;         HL = Address of filename (wildcards permitted)
1586+ B6C3              ;
1587+ B6C3              ; EXIT CONDITIONS
1588+ B6C3              ;         If OK:
1589+ B6C3              ;                 Carry true
1590+ B6C3              ;                 A corrupt
1591+ B6C3              ;         Otherwise:
1592+ B6C3              ;                 Carry false
1593+ B6C3              ;                 A = Error code
1594+ B6C3              ;         Always:
1595+ B6C3              ;                 BC DE HL IX corrupt
1596+ B6C3              ;                 All other registers preserved
1597+ B6C3              ;
1598+ B6C3              ;
1599+ B6C3
1600+ B6C3              dos_open_drive: equ 0x014B ; (331)
1601+ B6C3
1602+ B6C3              ; Open the disk in this drive as a single file.
1603+ B6C3              ;
1604+ B6C3              ; The whole disk is presented as a single file regardless of any real
1605+ B6C3              ; files on the disk. This routine can be used to examine/poke
1606+ B6C3              ; directories, files, etc. It should not be used by the uninitiated, the
1607+ B6C3              ; faint hearted, or by anyone who values their files!
1608+ B6C3              ;
1609+ B6C3              ; Sets file pointer to 000000h (0).
1610+ B6C3              ;
1611+ B6C3              ; If there are any files open on this drive from other file numbers with
1612+ B6C3              ; shared-read access, then the disk can only be opened with shared-read
1613+ B6C3              ; access from this file number.
1614+ B6C3              ;
1615+ B6C3              ; If there are any file open on this drive from other file numbers with
1616+ B6C3              ; exclusive access, then the disk cannot be opened from this file
1617+ B6C3              ; number.
1618+ B6C3              ;
1619+ B6C3              ; ENTRY CONDITIONS
1620+ B6C3              ;         A = Drive, ASCII 'A'...'P'
1621+ B6C3              ;         B = File number
1622+ B6C3              ;         C = Access mode required
1623+ B6C3              ;                 Bits 0...2 values:
1624+ B6C3              ;                         1 = exclusive-read
1625+ B6C3              ;                         2 = exclusive-write
1626+ B6C3              ;                         3 = exclusive-read-write
1627+ B6C3              ;                         5 = shared-read
1628+ B6C3              ;                         (all other bit settings reserved)
1629+ B6C3              ;                 Bits 3...7 = 0 (reserved)
1630+ B6C3              ;
1631+ B6C3              ; EXIT CONDITIONS
1632+ B6C3              ;         If OK:
1633+ B6C3              ;                 Carry true
1634+ B6C3              ;                 A corrupt
1635+ B6C3              ;         Otherwise:
1636+ B6C3              ;                 Carry false
1637+ B6C3              ;                 A = Error code
1638+ B6C3              ;         Always:
1639+ B6C3              ;                 BC DE HL corrupt
1640+ B6C3              ;                 All other registers preserved
1641+ B6C3              ;
1642+ B6C3              ;
1643+ B6C3
1644+ B6C3              dos_set_message: equ 0x014E ; (334)
1645+ B6C3
1646+ B6C3              ; Enable/disable disk error messages.
1647+ B6C3              ;
1648+ B6C3              ; This should be used to make +3DOS aware of your own ALERT subroutine.
1649+ B6C3              ; When +3DOS detects an error, it will call your ALERT subroutine,
1650+ B6C3              ; passing to it the values documented below. The ALERT subroutine should
1651+ B6C3              ; print the text of the message that +3DOS passes it, then should wait
1652+ B6C3              ; for the user to press a key. If the key is in the reply string (that
1653+ B6C3              ; +3DOS also passes - version V1.0 only), then a 'ret' should be made
1654+ B6C3              ; with A = 0, 1 or 2, or containing the character (depending on the
1655+ B6C3              ; version of +3DOS).
1656+ B6C3              ;
1657+ B6C3              ; ENTRY CONDITIONS
1658+ B6C3              ;         A = Enable/disable
1659+ B6C3              ;                 FFh (255) = enable
1660+ B6C3              ;                 00h (0) = disable
1661+ B6C3              ;         HL = Address of ALERT routine (if enabled)
1662+ B6C3              ;
1663+ B6C3              ; EXIT CONDITIONS
1664+ B6C3              ;         HL = address of previous ALERT routine (0 if none)
1665+ B6C3              ; Always:
1666+ B6C3              ;         AF BC DE IX corrupt
1667+ B6C3              ;         All other registers preserved
1668+ B6C3              ;
1669+ B6C3              ; NOTE
1670+ B6C3              ;
1671+ B6C3              ;         Note that if you are substituting your own ALERT subroutine,
1672+ B6C3              ;         the 'entry conditions' are the conditions passed to your
1673+ B6C3              ;         subroutine and the 'exit conditions' are the values that your
1674+ B6C3              ;         subroutine must produce and the registers you are allowed to
1675+ B6C3              ;         corrupt.
1676+ B6C3              ;
1677+ B6C3              ;         Note that there are two routine interfaces for ALERT. The
1678+ B6C3              ;         first, (which is used in machines with +3DOS version V1.0)
1679+ B6C3              ;         should have the entry and exit conditions shown ahead.
1680+ B6C3              ;
1681+ B6C3              ;         ALERT (VERSION V1.0 ONLY)
1682+ B6C3              ;
1683+ B6C3              ;         ENTRY CONDITIONS
1684+ B6C3              ;                 DE = Address of reply string (in page 7) terminated by
1685+ B6C3              ;                         FFh (255)
1686+ B6C3              ;                 HL = Address of error message (in page 7) terminated
1687+ B6C3              ;                         by FFh (255)
1688+ B6C3              ;
1689+ B6C3              ;         EXIT CONDITIONS
1690+ B6C3              ;                         A = Reply character
1691+ B6C3              ;                 Always:
1692+ B6C3              ;                         F BC DE HL IX corrupt
1693+ B6C3              ;                         All other registers preserved
1694+ B6C3              ;
1695+ B6C3              ;         The second version of ALERT, which allows the user to provide
1696+ B6C3              ;         non-UK error messages and is generally more flexible, is
1697+ B6C3              ;         present in +3DOS versions V1.1 and upwards.
1698+ B6C3              ;
1699+ B6C3              ;         ALERT (VERSION V1.1 AND ABOVE)
1700+ B6C3              ;
1701+ B6C3              ;         ENTRY CONDITIONS
1702+ B6C3              ;                 B = Error number
1703+ B6C3              ;                 C = Drive, ASCII 'A'...'P'
1704+ B6C3              ;                 D = Logical track (if required for message)
1705+ B6C3              ;                 E = Logical sector (if required for message)
1706+ B6C3              ;                 HL = Address of UK error message (page 7) terminated
1707+ B6C3              ;                         by FFh (255)
1708+ B6C3              ;
1709+ B6C3              ;         EXIT CONDITIONS
1710+ B6C3              ;                         A = Reply
1711+ B6C3              ;                                 0 = cancel
1712+ B6C3              ;                                 1 = retry
1713+ B6C3              ;                                 2 = ignore
1714+ B6C3              ;                 Always:
1715+ B6C3              ;                         F BC DE HL IX corrupt
1716+ B6C3              ;                         All other registers preserved
1717+ B6C3              ;
1718+ B6C3              ;         If you provide an ALERT function, you should have two
1719+ B6C3              ;         subroutines (or one with switchable entry and exit
1720+ B6C3              ;         conditions), and check the +3DOS version number before
1721+ B6C3              ;         deciding which one to use.
1722+ B6C3              ;
1723+ B6C3              ;
1724+ B6C3
1725+ B6C3              dos_ref_xdpb: equ 0x0151 ; (337)
1726+ B6C3
1727+ B6C3              ; Point at the XDPB for this drive. (The XDPB is required by the floppy
1728+ B6C3              ; disk driver routines.)
1729+ B6C3              ;
1730+ B6C3              ; ENTRY CONDITIONS
1731+ B6C3              ;         A = Drive, ASCII 'A'...'P'
1732+ B6C3              ;
1733+ B6C3              ; EXIT CONDITIONS
1734+ B6C3              ;         If OK:
1735+ B6C3              ;                 Carry true
1736+ B6C3              ;                 A corrupt
1737+ B6C3              ;                 IX = Address of XDPB
1738+ B6C3              ;         Otherwise:
1739+ B6C3              ;                 Carry false
1740+ B6C3              ;                 A = Error code
1741+ B6C3              ;                 IX corrupt
1742+ B6C3              ;         Always:
1743+ B6C3              ;                 BC DE HL corrupt
1744+ B6C3              ;                 All other registers preserved
1745+ B6C3              ;
1746+ B6C3              ;
1747+ B6C3
1748+ B6C3              dos_map_b: equ 0x0154 ; (340)
1749+ B6C3
1750+ B6C3              ; Map drive B: to unit 0 or unit 1. (This routine will fail if drive B:
1751+ B6C3              ; has files open.)
1752+ B6C3              ;
1753+ B6C3              ; If mapping B: to unit 0, then each time unit 0 is accessed, a check is
1754+ B6C3              ; made that the drive mapping is correct. If it isn't, then a reverse
1755+ B6C3              ; call to CHANGE DISK is made, to ask the user to change the disk in
1756+ B6C3              ; unit 0.
1757+ B6C3              ;
1758+ B6C3              ; If mapping B: to unit 1, then if unit 1 does not exist, drive B: is
1759+ B6C3              ; disabled.
1760+ B6C3              ;
1761+ B6C3              ; ENTRY CONDITIONS
1762+ B6C3              ;         C = Unit (0/1)
1763+ B6C3              ;         HL = Address of CHANGE DISK routine if unit = 0
1764+ B6C3              ;
1765+ B6C3              ; EXIT CONDITIONS
1766+ B6C3              ;         If OK:
1767+ B6C3              ;                 Carry true
1768+ B6C3              ;                 A corrupt
1769+ B6C3              ;                 HL = Address of previous CHANGE DISK routine (0 if
1770+ B6C3              ;                         none)
1771+ B6C3              ;         Otherwise:
1772+ B6C3              ;                 Carry false
1773+ B6C3              ;                 A HL corrupt
1774+ B6C3              ;         Always
1775+ B6C3              ;                 BC DE IX corrupt
1776+ B6C3              ;                 All other registers preserved
1777+ B6C3              ;
1778+ B6C3              ; NOTE
1779+ B6C3              ;         The definition of the subroutine CHANGE DISK is as shown
1780+ B6C3              ;         ahead. Note that if you are substituting your own CHANGE DISK
1781+ B6C3              ;         subroutine, the 'entry conditions' are the conditions passed
1782+ B6C3              ;         to your subroutine, and the 'exit conditions' are registers
1783+ B6C3              ;         you are allowed to corrupt.
1784+ B6C3              ;
1785+ B6C3              ;         CHANGE DISK
1786+ B6C3              ;
1787+ B6C3              ;         Ask the user to change the disk in unit 0.
1788+ B6C3              ;
1789+ B6C3              ;         Wait for the user to acknowledge the change.
1790+ B6C3              ;
1791+ B6C3              ;         ENTRY CONDITIONS
1792+ B6C3              ;                 A = Logical drive, ASCII 'A'...'P'
1793+ B6C3              ;                 HL = Address of message (page 7) terminated by FFh
1794+ B6C3              ;                         (255)
1795+ B6C3              ;
1796+ B6C3              ;         EXIT CONDITIONS
1797+ B6C3              ;                 Always:
1798+ B6C3              ;                         AF BC DE HL IX corrupt
1799+ B6C3              ;                         All other registers preserved
1800+ B6C3              ;
1801+ B6C3              ;
1802+ B6C3              ;
1803+ B6C3              ; Low level floppy disk driving routines
1804+ B6C3              ;
1805+ B6C3              ; The following are the floppy disk driver routines. The unit number is
1806+ B6C3              ; 0...3 for the uPD765A. On the +3, unit 0 is drive A: and unit 1 is
1807+ B6C3              ; drive B:, or optionally, both A: and B: may be mapped onto unit 0.
1808+ B6C3              ; Units 2 and 3 are not used.
1809+ B6C3              ;
1810+ B6C3              ; With the exception of DD INTERFACE, none of these routines may be
1811+ B6C3              ; called if the floppy disk interface is not present.
1812+ B6C3              ;
1813+ B6C3              ; All routines assume that interrupts are enabled on entry, and will
1814+ B6C3              ; still be enabled on exit.
1815+ B6C3              ;
1816+ B6C3
1817+ B6C3              dd_interface: equ 0x0157 ; (343)
1818+ B6C3
1819+ B6C3              ; Is the floppy disk drive interface present? (This information is also
1820+ B6C3              ; held by BASIC in bit 4 of the FLAGS3 system variable.)
1821+ B6C3              ;
1822+ B6C3              ; ENTRY CONDITIONS
1823+ B6C3              ;         None
1824+ B6C3              ;
1825+ B6C3              ; EXIT CONDITIONS
1826+ B6C3              ;         If present:
1827+ B6C3              ;                 Carry true
1828+ B6C3              ;         Otherwise:
1829+ B6C3              ;                 Carry false
1830+ B6C3              ;         Always:
1831+ B6C3              ;                 A BC DE HL IX corrupt
1832+ B6C3              ;                 All other registers preserved
1833+ B6C3              ;
1834+ B6C3
1835+ B6C3              dd_init: equ 0x015a ; (346)
1836+ B6C3
1837+ B6C3              ; Initialise the disk driver.
1838+ B6C3              ;
1839+ B6C3              ; ENTRY CONDITIONS
1840+ B6C3              ;         None
1841+ B6C3              ;
1842+ B6C3              ; EXIT CONDITIONS
1843+ B6C3              ;         Always:
1844+ B6C3              ;                 AF BC DE HL IX corrupt
1845+ B6C3              ;                 All other registers preserved
1846+ B6C3              ;
1847+ B6C3
1848+ B6C3              dd_setup: equ 0x015d ; (349)
1849+ B6C3
1850+ B6C3              ; Set up disk parameters.
1851+ B6C3              ;
1852+ B6C3              ; Send a specify command.
1853+ B6C3              ;
1854+ B6C3              ; Parameter block format:
1855+ B6C3              ;
1856+ B6C3              ;         Byte 0 - Motor on time (in 100 mS units)
1857+ B6C3              ;         Byte 1 - Motor off time (in 100 mS units)
1858+ B6C3              ;         Byte 2 - Write off time (in 10 uS units)
1859+ B6C3              ;         Byte 3 - Head settle time (in mS units)
1860+ B6C3              ;         Byte 4 - Step rate (in mS units)
1861+ B6C3              ;         Byte 5 - Head unload time (in 32 mS units, 32...480)
1862+ B6C3              ;         Byte 6 - (Head load time x 2) + 1, (in 4 mS units, 4...508)
1863+ B6C3              ;
1864+ B6C3              ; ENTRY CONDITIONS
1865+ B6C3              ;         HL = Address of parameter block
1866+ B6C3              ;
1867+ B6C3              ; EXIT CONDITIONS
1868+ B6C3              ;         Always:
1869+ B6C3              ;                 AF BC DE HL IX corrupt
1870+ B6C3              ;                 All other registers preserved
1871+ B6C3              ;
1872+ B6C3
1873+ B6C3              dd_set_retry: equ 0x0160 ; (352)
1874+ B6C3
1875+ B6C3              ; Set the try and retry count. (A value of 1 will try the operation
1876+ B6C3              ; once, i.e. no retry.)
1877+ B6C3              ;
1878+ B6C3              ; ENTRY CONDITIONS
1879+ B6C3              ;         A = Try/retry count >= 1
1880+ B6C3              ;
1881+ B6C3              ; EXIT CONDITIONS
1882+ B6C3              ;         Always:
1883+ B6C3              ;                 AF BC DE HL IX corrupt
1884+ B6C3              ;                 All other registers preserved
1885+ B6C3              ;
1886+ B6C3
1887+ B6C3              dd_read_sector: equ 0x0163 ; (355)
1888+ B6C3
1889+ B6C3              ; Read a sector.
1890+ B6C3              ;
1891+ B6C3              ; ENTRY CONDITIONS
1892+ B6C3              ;         B = Page for C000h (49152)...FFFFh (65535)
1893+ B6C3              ;         C = Unit (0/1)
1894+ B6C3              ;         D = Logical track, 0 base
1895+ B6C3              ;         E = Logical sector, 0 base
1896+ B6C3              ;         HL = Address of buffer
1897+ B6C3              ;         IX = Address of XDPB
1898+ B6C3              ;
1899+ B6C3              ; EXIT CONDITIONS
1900+ B6C3              ;         If OK:
1901+ B6C3              ;                 Carry true
1902+ B6C3              ;                 A corrupt
1903+ B6C3              ;         Otherwise:
1904+ B6C3              ;                 Carry false
1905+ B6C3              ;                 A = Error code
1906+ B6C3              ;         Always:
1907+ B6C3              ;                 BC DE HL IX corrupt
1908+ B6C3              ;                 All other registers preserved
1909+ B6C3              ;
1910+ B6C3
1911+ B6C3              dd_write_sector: equ 0x0166 ; (358)
1912+ B6C3
1913+ B6C3              ; Write a sector.
1914+ B6C3              ;
1915+ B6C3              ; ENTRY CONDITIONS
1916+ B6C3              ;         B = Page for C000h (49152)...FFFFh (65535)
1917+ B6C3              ;         C = Unit (0/1)
1918+ B6C3              ;         D = Logical track, 0 base
1919+ B6C3              ;         E = Logical sector, 0 base
1920+ B6C3              ;         HL = Address of buffer
1921+ B6C3              ;         IX = Address of XDPB
1922+ B6C3              ;
1923+ B6C3              ; EXIT CONDITIONS
1924+ B6C3              ;         If OK:
1925+ B6C3              ;                 Carry true
1926+ B6C3              ;                 A corrupt
1927+ B6C3              ;         Otherwise:
1928+ B6C3              ;                 Carry false
1929+ B6C3              ;                 A = Error code
1930+ B6C3              ;         Always:
1931+ B6C3              ;                 BC DE HL IX corrupt
1932+ B6C3              ;                 All other registers preserved
1933+ B6C3              ;
1934+ B6C3
1935+ B6C3              dd_check_sector: equ 0x0169 ; (361)
1936+ B6C3
1937+ B6C3              ; Check a sector. (Uses the uPD765A scan equal command.)
1938+ B6C3              ;
1939+ B6C3              ; Checks that the sector on disk is the same as the copy in memory.
1940+ B6C3              ;
1941+ B6C3              ; Note that FFh (255) on disk or in memory always matches anything (see
1942+ B6C3              ; uPD765A specification for further details).
1943+ B6C3              ;
1944+ B6C3              ; ENTRY CONDITIONS
1945+ B6C3              ;         B = Page for C000h (49152)...FFFFh (65535)
1946+ B6C3              ;         C = Unit (0/1)
1947+ B6C3              ;         D = Logical track, 0 base
1948+ B6C3              ;         E = Logical sector, 0 base
1949+ B6C3              ;         HL = Address of copy of sector
1950+ B6C3              ;         IX = Address of XDPB
1951+ B6C3              ;
1952+ B6C3              ; EXIT CONDITIONS
1953+ B6C3              ;         If OK (equal):
1954+ B6C3              ;                 Carry true
1955+ B6C3              ;                 Zero true
1956+ B6C3              ;                 A corrupt
1957+ B6C3              ;         If OK (not equal):
1958+ B6C3              ;                 Carry true
1959+ B6C3              ;                 Zero false
1960+ B6C3              ;                 A corrupt
1961+ B6C3              ;         Otherwise:
1962+ B6C3              ;                 Carry false
1963+ B6C3              ;                 A = Error code
1964+ B6C3              ;         Always:
1965+ B6C3              ;                 BC DE HL IX corrupt
1966+ B6C3              ;                 All other registers preserved
1967+ B6C3              ;
1968+ B6C3
1969+ B6C3              dd_format: equ 0x016c ; (364)
1970+ B6C3
1971+ B6C3              ; Format a track. (Uses the uPD765A format track command.)
1972+ B6C3              ;
1973+ B6C3              ; Buffer contains 4 bytes for each sector as follows:
1974+ B6C3              ;
1975+ B6C3              ;         C - Track number        (0...39)
1976+ B6C3              ;         H - Head number         (always 0 on the +3's single-sided
1977+ B6C3              ;                                 drives)
1978+ B6C3              ;         R - Sector number       (0...255)
1979+ B6C3              ;         N - Log2(sector size)-7 (2 for 512 byte sectors)
1980+ B6C3              ;
1981+ B6C3              ; ENTRY CONDITIONS
1982+ B6C3              ;         B = Page for C000h (49152)...FFFFh (65535)
1983+ B6C3              ;         C = Unit (0/1)
1984+ B6C3              ;         D = Logical track, 0 base
1985+ B6C3              ;         E = Filler byte, usually E5h (229)
1986+ B6C3              ;         HL = Address of format buffer
1987+ B6C3              ;         IX = Address of XDPB
1988+ B6C3              ;
1989+ B6C3              ; EXIT CONDITIONS
1990+ B6C3              ;         If OK:
1991+ B6C3              ;                 Carry true
1992+ B6C3              ;                 A corrupt
1993+ B6C3              ;         Otherwise:
1994+ B6C3              ;                 Carry false
1995+ B6C3              ;                 A = Error code
1996+ B6C3              ;         Always:
1997+ B6C3              ;                 BC DE HL IX corrupt
1998+ B6C3              ;                 All other registers preserved
1999+ B6C3              ;
2000+ B6C3
2001+ B6C3              dd_read_id: equ 0x016f ; (367)
2002+ B6C3
2003+ B6C3              ; Read a sector identifier.
2004+ B6C3              ;
2005+ B6C3              ; ENTRY CONDITIONS
2006+ B6C3              ;         C = Unit (0/1)
2007+ B6C3              ;         D = Logical track, 0 base
2008+ B6C3              ;         IX = Address of XDPB
2009+ B6C3              ;
2010+ B6C3              ; EXIT CONDITIONS
2011+ B6C3              ;         If OK:
2012+ B6C3              ;                 Carry true
2013+ B6C3              ;                 A = Sector number from identifier
2014+ B6C3              ;         Otherwise:
2015+ B6C3              ;                 Carry false
2016+ B6C3              ;                 A = Error code
2017+ B6C3              ;         Always:
2018+ B6C3              ;                 HL = Address of result buffer in page 7
2019+ B6C3              ;                 BC DE IX corrupt
2020+ B6C3              ;                 All other registers preserved
2021+ B6C3              ;
2022+ B6C3
2023+ B6C3              dd_test_unsuitable: equ 0x0172 ; (370)
2024+ B6C3
2025+ B6C3              ; Check that disk is suitable to write to.
2026+ B6C3              ;
2027+ B6C3              ; A single track disk will not work in a double track drive, and vice
2028+ B6C3              ; versa.
2029+ B6C3              ;
2030+ B6C3              ; ENTRY CONDITIONS
2031+ B6C3              ;         C = Unit (0/1)
2032+ B6C3              ;         IX = Address of XDPB
2033+ B6C3              ;
2034+ B6C3              ; EXIT CONDITIONS
2035+ B6C3              ;         If suitable:
2036+ B6C3              ;                 Carry true
2037+ B6C3              ;                 A corrupt
2038+ B6C3              ;         Otherwise:
2039+ B6C3              ;                 Carry false
2040+ B6C3              ;                 A = Error code
2041+ B6C3              ;         Always:
2042+ B6C3              ;                 BC DE HL IX corrupt
2043+ B6C3              ;                 All other registers preserved
2044+ B6C3              ;
2045+ B6C3
2046+ B6C3              dd_login: equ 0x0175 ; (373)
2047+ B6C3
2048+ B6C3              ; Log in a new disk.
2049+ B6C3              ;
2050+ B6C3              ; Initialise the XDPB.
2051+ B6C3              ;
2052+ B6C3              ; This routine does not affect or consider the freeze flag.
2053+ B6C3              ;
2054+ B6C3              ; ENTRY CONDITIONS
2055+ B6C3              ;         C = Unit (0/1)
2056+ B6C3              ;         IX = Address of destination XDPB
2057+ B6C3              ;
2058+ B6C3              ; EXIT CONDITIONS
2059+ B6C3              ;         If OK:
2060+ B6C3              ;                 Carry true
2061+ B6C3              ;                 A = Disk type
2062+ B6C3              ;                 DE = Size of allocation vector
2063+ B6C3              ;                 HL = Size of hash table
2064+ B6C3              ;         Otherwise:
2065+ B6C3              ;                 Carry false
2066+ B6C3              ;                 A = Error code
2067+ B6C3              ;                 DE HL corrupt
2068+ B6C3              ;         Always:
2069+ B6C3              ;                 BC IX corrupt
2070+ B6C3              ;                 All other registers preserved
2071+ B6C3              ;
2072+ B6C3
2073+ B6C3              dd_sel_format: equ 0x0178 ; (376)
2074+ B6C3
2075+ B6C3              ; Initialise an XDPB for a standard format.
2076+ B6C3              ;
2077+ B6C3              ; This routine does not affect or consider the freeze flag.
2078+ B6C3              ;
2079+ B6C3              ; ENTRY CONDITIONS
2080+ B6C3              ;         A = Disk type
2081+ B6C3              ;                 0 = Spectrum +3 format (AMSTRAD PCW range - DD SS ST)
2082+ B6C3              ;                 1 = AMSTRAD CPC range system format
2083+ B6C3              ;                 2 = AMSTRAD CPC range data-only format
2084+ B6C3              ;                 3 = AMSTRAD PCW range - DD SS DT
2085+ B6C3              ;                 (other values = error)
2086+ B6C3              ;         IX = Address of XDPB
2087+ B6C3              ;
2088+ B6C3              ; EXIT CONDITIONS
2089+ B6C3              ;         If OK:
2090+ B6C3              ;                 Carry true
2091+ B6C3              ;                 A = Disk type
2092+ B6C3              ;                 DE = Size of 2 bit allocation vector
2093+ B6C3              ;                 HL = Size of hash table
2094+ B6C3              ;         Otherwise:
2095+ B6C3              ;                 Carry false
2096+ B6C3              ;                 A = Error code
2097+ B6C3              ;                 DE HL corrupt
2098+ B6C3              ;         Always:
2099+ B6C3              ;                 BC IX corrupt
2100+ B6C3              ;                 All other registers preserved
2101+ B6C3              ;
2102+ B6C3
2103+ B6C3              dd_ask_1: equ 0x017b ; (379)
2104+ B6C3
2105+ B6C3              ; Check to see if unit 1 is present. (BASIC holds this information in
2106+ B6C3              ; bit 5 of the FLAGS3 system variable.)
2107+ B6C3              ;
2108+ B6C3              ; Turn motor on.
2109+ B6C3              ;
2110+ B6C3              ; Fetch drive status.
2111+ B6C3              ;
2112+ B6C3              ; If unit 1 is not-ready and write-protected, then unit 1 is missing.
2113+ B6C3              ; Start motor off timeout.
2114+ B6C3              ;
2115+ B6C3              ; Note that this routine can be fooled by disks which are almost, but
2116+ B6C3              ; not quite, inserted in the drive.
2117+ B6C3              ;
2118+ B6C3              ; This routine assumes that when a disk is not in the drive, then
2119+ B6C3              ; write-protect is true. This is indeed the case for 3 inch and 8 inch
2120+ B6C3              ; disk drives, but is not the case for 5 1/4 inch disk drives.
2121+ B6C3              ;
2122+ B6C3              ; ENTRY CONDITIONS
2123+ B6C3              ;         None
2124+ B6C3              ;
2125+ B6C3              ; EXIT CONDITIONS
2126+ B6C3              ;         If unit 1 present:
2127+ B6C3              ;                 Carry true
2128+ B6C3              ;         Otherwise:
2129+ B6C3              ;                 Carry false
2130+ B6C3              ;         Always:
2131+ B6C3              ;                 A BC DE HL IX corrupt
2132+ B6C3              ;                 All other registers preserved
2133+ B6C3              ;
2134+ B6C3
2135+ B6C3              dd_drive_status: equ 0x017e ; (382)
2136+ B6C3
2137+ B6C3              ; Issue a sense drive status command.
2138+ B6C3              ;
2139+ B6C3              ; ENTRY CONDITIONS
2140+ B6C3              ;         C = Unit/head
2141+ B6C3              ;                 bits 0...1 = unit
2142+ B6C3              ;                 bit 2 = head
2143+ B6C3              ;                 bits 3...7 = 0
2144+ B6C3              ;
2145+ B6C3              ; EXIT CONDITIONS
2146+ B6C3              ;                 A = ST3 (Status register 3 of uPD765A)
2147+ B6C3              ;         Always:
2148+ B6C3              ;                 F BC DE HL IX corrupt
2149+ B6C3              ;                 All other registers preserved
2150+ B6C3              ;
2151+ B6C3
2152+ B6C3              dd_equipment: equ 0x0181 ; (385)
2153+ B6C3
2154+ B6C3              ; Ask what type of drive this is (i.e. single/double track,
2155+ B6C3              ; single/double sided).
2156+ B6C3              ;
2157+ B6C3              ; Track information can only be determined once a disk has been seen and
2158+ B6C3              ; had its type identified during logging in.
2159+ B6C3              ;
2160+ B6C3              ; Side information can only be detected after a double sided disk has
2161+ B6C3              ; been seen and has its type identified during logging in.
2162+ B6C3              ;
2163+ B6C3              ; ENTRY CONDITIONS
2164+ B6C3              ;         C = Unit (0/1)
2165+ B6C3              ;         IX = Address of XDPB
2166+ B6C3              ;
2167+ B6C3              ; EXIT CONDITIONS
2168+ B6C3              ;                 A = Side/track information
2169+ B6C3              ;                         bits 0...1 = side information
2170+ B6C3              ;                                 0 = unknown
2171+ B6C3              ;                                 1 = single sided
2172+ B6C3              ;                                 2 = double sided
2173+ B6C3              ;                         bits 2...3 = track information
2174+ B6C3              ;                                 0 = unknown
2175+ B6C3              ;                                 1 = single track
2176+ B6C3              ;                                 2 = double track
2177+ B6C3              ;         Always:
2178+ B6C3              ;                 F BC DE HL IX corrupt
2179+ B6C3              ;                 All other registers preserved
2180+ B6C3              ;
2181+ B6C3
2182+ B6C3              dd_encode: equ 0x0184 ; (388)
2183+ B6C3
2184+ B6C3              ; Set the copy protection ENCODE subroutine.
2185+ B6C3              ;
2186+ B6C3              ; Copy protected disks have some of their track and sector numbers
2187+ B6C3              ; encoded on disk. Before each disk access, the ENCODE subroutine is
2188+ B6C3              ; called to encode the physical track and sector numbers.
2189+ B6C3              ;
2190+ B6C3              ; These encoded track and sector numbers must match those in the sector
2191+ B6C3              ; identifier.
2192+ B6C3              ;
2193+ B6C3              ; Note that tracks 0...2 on either side of a disk should not be encoded.
2194+ B6C3              ;
2195+ B6C3              ; ENTRY CONDTIONS
2196+ B6C3              ;         A = Enable/disable
2197+ B6C3              ;                 00h (0) = disable
2198+ B6C3              ;                 FFh (255) = enable
2199+ B6C3              ;         HL = (If enabled) address of ENCODE subroutine
2200+ B6C3              ;
2201+ B6C3              ; EXIT CONDITIONS
2202+ B6C3              ;                 HL = Address of previous ENCODE subroutine (0 if none)
2203+ B6C3              ;         Always:
2204+ B6C3              ;                 AF BC DE IX corrupt
2205+ B6C3              ;                 All other registers preserved
2206+ B6C3              ;
2207+ B6C3              ; NOTE
2208+ B6C3              ;         The definition of the subroutine ENCODE is as shown ahead.
2209+ B6C3              ;         Note that if you are substituting your own ENCODE subroutine,
2210+ B6C3              ;         the 'entry conditions' are the conditions passed to your
2211+ B6C3              ;         subroutine, and the 'exit conditions' are the values that your
2212+ B6C3              ;         subroutine must produce and the registers you are allowed to
2213+ B6C3              ;         corrupt.
2214+ B6C3              ;
2215+ B6C3              ;         ENCODE
2216+ B6C3              ;
2217+ B6C3              ;         ENTRY CONDITIONS
2218+ B6C3              ;                 C = Unit/side
2219+ B6C3              ;                         bits 0...1 = unit
2220+ B6C3              ;                         bit 2 = side
2221+ B6C3              ;                         bits 3...7 = 0
2222+ B6C3              ;                 D = Physical track
2223+ B6C3              ;                 E = Physical sector
2224+ B6C3              ;                 IX = Address of DPB
2225+ B6C3              ;
2226+ B6C3              ;         EXIT CONDITIONS
2227+ B6C3              ;                         D = Encoded physical track
2228+ B6C3              ;                         E = Encoded physical sector
2229+ B6C3              ;                 Always:
2230+ B6C3              ;                         AF corrupt
2231+ B6C3              ;                         All other registers preserved
2232+ B6C3              ;
2233+ B6C3
2234+ B6C3              dd_l_xdpb: equ 0x0187 ; (391)
2235+ B6C3
2236+ B6C3              ; Initialise an XDPB for a given format.
2237+ B6C3              ;
2238+ B6C3              ; This routine does not affect or consider the freeze flag.
2239+ B6C3              ;
2240+ B6C3              ; ENTRY CONDITIONS
2241+ B6C3              ;         IX = Address of destination XDPB
2242+ B6C3              ;         HL = Address of source disk specification
2243+ B6C3              ;
2244+ B6C3              ; EXIT CONDITIONS
2245+ B6C3              ;         If OK:
2246+ B6C3              ;                 Carry true
2247+ B6C3              ;                 A = Disk type recorded on disk
2248+ B6C3              ;                 DE = Size of allocation vector
2249+ B6C3              ;                 HL = Size of hash table
2250+ B6C3              ;         If bad format:
2251+ B6C3              ;                 Carry false
2252+ B6C3              ;                 A = Error code
2253+ B6C3              ;                 DE HL corrupt
2254+ B6C3              ;         Always:
2255+ B6C3              ;                 BC IX corrupt
2256+ B6C3              ;                 All other registers preserved
2257+ B6C3              ;
2258+ B6C3
2259+ B6C3              dd_l_dpb: equ 0x018a ; (394)
2260+ B6C3
2261+ B6C3              ; Initialise a DPB for a given format.
2262+ B6C3              ;
2263+ B6C3              ; This routine does not affect or consider the freeze flag.
2264+ B6C3              ;
2265+ B6C3              ; ENTRY CONDITIONS
2266+ B6C3              ;         IX = Address of destination DPB
2267+ B6C3              ;         HL = Address of source disk specification
2268+ B6C3              ;
2269+ B6C3              ; EXIT CONDITIONS
2270+ B6C3              ;         If OK:
2271+ B6C3              ;                 Carry true
2272+ B6C3              ;                 A = Disk type recorded on disk
2273+ B6C3              ;                 DE = Size of allocation vector
2274+ B6C3              ;                 HL = Size of hash table
2275+ B6C3              ;         If bad format:
2276+ B6C3              ;                 Carry false
2277+ B6C3              ;                 A = Error code
2278+ B6C3              ;                 DE HL corrupt
2279+ B6C3              ;         Always:
2280+ B6C3              ;                 BC IX corrupt
2281+ B6C3              ;                 All other registers preserved
2282+ B6C3              ;
2283+ B6C3
2284+ B6C3              dd_l_seek: equ 0x018d ; (397)
2285+ B6C3
2286+ B6C3              ; Seek to required track.
2287+ B6C3              ;
2288+ B6C3              ; Retry if fails.
2289+ B6C3              ;
2290+ B6C3              ; ENTRY CONDITIONS
2291+ B6C3              ;         C = Unit/head
2292+ B6C3              ;                 bits 0...1 = unit
2293+ B6C3              ;                 bit 2 = head
2294+ B6C3              ;                 bits 3...7 = 0
2295+ B6C3              ;         D = Track
2296+ B6C3              ;         IX = Address of XDPB
2297+ B6C3              ;
2298+ B6C3              ; EXIT CONDITIONS
2299+ B6C3              ;         If OK:
2300+ B6C3              ;                 Carry true
2301+ B6C3              ;                 A corrupt
2302+ B6C3              ;         Otherwise:
2303+ B6C3              ;                 Carry false
2304+ B6C3              ;                 A = Error report
2305+ B6C3              ;         Always:
2306+ B6C3              ;                 BC DE HL IX corrupt
2307+ B6C3              ;                 All other registers preserved
2308+ B6C3              ;
2309+ B6C3
2310+ B6C3              dd_l_read: equ 0x0190 ; (400)
2311+ B6C3
2312+ B6C3              ; Low level uPD765A read command.
2313+ B6C3              ;
2314+ B6C3              ; Read data.
2315+ B6C3              ;
2316+ B6C3              ; Read deleted data.
2317+ B6C3              ;
2318+ B6C3              ; Read a track.
2319+ B6C3              ;
2320+ B6C3              ; Parameter block format:
2321+ B6C3              ;
2322+ B6C3              ;         Byte 0          - Page for C000h (49152)...FFFFh (65535)
2323+ B6C3              ;         Bytes 1...2     - Address of buffer
2324+ B6C3              ;         Bytes 3...4     - Number of bytes to transfer
2325+ B6C3              ;         Byte 5          - Number of command bytes
2326+ B6C3              ;         Bytes 6...      - Command bytes
2327+ B6C3              ;
2328+ B6C3              ; Writes commands.
2329+ B6C3              ;
2330+ B6C3              ; Reads data.
2331+ B6C3              ;
2332+ B6C3              ; Reads results.
2333+ B6C3              ;
2334+ B6C3              ; Motor must be running.
2335+ B6C3              ;
2336+ B6C3              ; ENTRY CONDITIONS
2337+ B6C3              ;         HL = Address of parameter block
2338+ B6C3              ;
2339+ B6C3              ; EXIT CONDITIONS
2340+ B6C3              ;                 HL = Address of result buffer in page 7
2341+ B6C3              ;         Always:
2342+ B6C3              ;                 AF BC DE IX corrupt
2343+ B6C3              ;                 All other registers preserved
2344+ B6C3              ;
2345+ B6C3
2346+ B6C3              dd_l_write: equ 0x0193 ; (403)
2347+ B6C3
2348+ B6C3              ; Low level uPD765A write command.
2349+ B6C3              ;
2350+ B6C3              ; Write data.
2351+ B6C3              ;
2352+ B6C3              ; Write deleted data.
2353+ B6C3              ;
2354+ B6C3              ; Format a track.
2355+ B6C3              ;
2356+ B6C3              ; Scan equal.
2357+ B6C3              ;
2358+ B6C3              ; Scan low or equal.
2359+ B6C3              ;
2360+ B6C3              ; Scan high or equal.
2361+ B6C3              ;
2362+ B6C3              ; Parameter block format:
2363+ B6C3              ;
2364+ B6C3              ;         Byte 0          - Page for C000h (49152)...FFFFh (65535)
2365+ B6C3              ;         Bytes 1...2     - Address of buffer
2366+ B6C3              ;         Bytes 3...4     - Number of bytes to transfer
2367+ B6C3              ;         Byte 5          - Number of command bytes
2368+ B6C3              ;         Bytes 6...      - Command bytes
2369+ B6C3              ;
2370+ B6C3              ; Writes commands.
2371+ B6C3              ;
2372+ B6C3              ; Writes data.
2373+ B6C3              ;
2374+ B6C3              ; Reads results.
2375+ B6C3              ;
2376+ B6C3              ; Motor must be running.
2377+ B6C3              ;
2378+ B6C3              ; ENTRY CONDITIONS
2379+ B6C3              ;         HL = Address of parameter block
2380+ B6C3              ;
2381+ B6C3              ; EXIT CONDITIONS
2382+ B6C3              ;                 HL = Address of result buffer in page 7
2383+ B6C3              ;         Always:
2384+ B6C3              ;                 AF BC DE IX corrupt
2385+ B6C3              ;                 All other registers preserved
2386+ B6C3              ;
2387+ B6C3
2388+ B6C3              dd_l_on_motor: equ 0x0196 ; (406)
2389+ B6C3
2390+ B6C3              ; Turn on the motor.
2391+ B6C3              ;
2392+ B6C3              ; Wait for the motor on time as set by DD SETUP.
2393+ B6C3              ;
2394+ B6C3              ; ENTRY CONDITIONS
2395+ B6C3              ;         None
2396+ B6C3              ;
2397+ B6C3              ; EXIT CONDITIONS
2398+ B6C3              ;         Always:
2399+ B6C3              ;                 AF BC DE HL IX corrupt
2400+ B6C3              ;                 All other registers preserved
2401+ B6C3              ;
2402+ B6C3
2403+ B6C3              dd_l_t_off_motor: equ 0x0199 ; (409)
2404+ B6C3
2405+ B6C3              ; Start the motor off time-out.
2406+ B6C3              ;
2407+ B6C3              ; ENTRY CONDITIONS
2408+ B6C3              ;         None
2409+ B6C3              ;
2410+ B6C3              ; EXIT CONDITIONS
2411+ B6C3              ;         Always:
2412+ B6C3              ;                 AF BC DE HL IX corrupt
2413+ B6C3              ;                 All other registers preserved
2414+ B6C3              ;
2415+ B6C3
2416+ B6C3              dd_l_off_motor: equ 0x019c ; (412)
2417+ B6C3
2418+ B6C3              ; Turn off the motor.
2419+ B6C3              ;
2420+ B6C3              ; ENTRY CONDITIONS
2421+ B6C3              ;         None
2422+ B6C3              ;
2423+ B6C3              ; EXIT CONDITIONS
2424+ B6C3              ;         Always:
2425+ B6C3              ;                 AF BC DE HL IX corrupt
2426+ B6C3              ;                 All other registers preserved
2427+ B6C3
2428+ B6C3              ; +3DOS constants
2429+ B6C3              OPEN_ACTION_ERROR_EXISTS            equ 0
2430+ B6C3              OPEN_ACTION_READ_HEADER             equ 1
2431+ B6C3              OPEN_ACTION_IGNORE_HEADER           equ 2
2432+ B6C3              OPEN_ACTION_MAKE_BACKUP             equ 3
2433+ B6C3              OPEN_ACTION_OVERWRITE               equ 4
2434+ B6C3
2435+ B6C3              CREATE_ACTION_DONT_CREATE           equ 0
2436+ B6C3              CREATE_ACTION_WITH_HEADER           equ 1
2437+ B6C3              CREATE_ACTION_WITHOUT_HEADER        equ 2
2438+ B6C3
2439+ B6C3              FILE_TYPE_BASIC                     equ 0
2440+ B6C3              FILE_TYPE_NUM_ARRAY                 equ 1
2441+ B6C3              FILE_TYPE_CHR_ARRAY                 equ 2
2442+ B6C3              FILE_TYPE_BYTES                     equ 3
2443+ B6C3
2444+ B6C3              ACCESS_MODE_EXCLUSIVE_READ          equ 1
2445+ B6C3              ACCESS_MODE_EXCLUSIVE_WRITE         equ 2
2446+ B6C3              ACCESS_MODE_EXCLUSIVE_READ_WRITE    equ 3
2447+ B6C3              ACCESS_MODE_SHARED                  equ 5
2448+ B6C3
2449+ B6C3              ; +3E extensions
2450+ B6C3
2451+ B6C3              ide_version             equ     $00A0
2452+ B6C3              ide_interface           equ     $00A3
2453+ B6C3              ide_init                equ     $00A6
2454+ B6C3              ide_drive               equ     $00A9
2455+ B6C3              ide_sector_read         equ     $00AC
2456+ B6C3              ide_sector_write        equ     $00AF
2457+ B6C3              ide_format              equ     $00B2
2458+ B6C3              ide_partition_find      equ     $00B5
2459+ B6C3              ide_partition_new       equ     $00B8
2460+ B6C3              ide_partition_init      equ     $00BB
2461+ B6C3              ide_partition_erase     equ     $00BE
2462+ B6C3              ide_partition_rename    equ     $00C1
2463+ B6C3              ide_partition_read      equ     $00C4
2464+ B6C3              ide_partition_write     equ     $00C7
2465+ B6C3              ide_partition_winfo     equ     $00CA
2466+ B6C3              ide_partition_open      equ     $00CD
2467+ B6C3              ide_partition_close     equ     $00D0
2468+ B6C3              ide_partition_getinfo   equ     $00D3
2469+ B6C3              ide_partition_setinfo   equ     $00D6
2470+ B6C3              ide_swap_open           equ     $00D9
2471+ B6C3              ide_swap_close          equ     $00DC
2472+ B6C3              ide_swap_out            equ     $00DF
2473+ B6C3              ide_swap_in             equ     $00E2
2474+ B6C3              ide_swap_ex             equ     $00E5
2475+ B6C3              ide_swap_pos            equ     $00E8
2476+ B6C3              ide_swap_move           equ     $00EB
2477+ B6C3              ide_swap_resize         equ     $00EE
2478+ B6C3              ide_dos_map             equ     $00F1
2479+ B6C3              ide_dos_unmap           equ     $00F4
2480+ B6C3              ide_dos_mapping         equ     $00F7
2481+ B6C3              ide_dos_unpermanent     equ     $00FA
2482+ B6C3              ide_snapload            equ     $00FD
2483+ B6C3
2484+ B6C3              ide_access_data         equ     $019F
2485+ B6C3              ide_identify            equ     $01A2
2486+ B6C3              ide_partitiions         equ     $01A5
2487+ B6C3
# file closed: p3dos.asm
 432  B6C3                  include "prtwifi.asm"
# file opened: prtwifi.asm
   1+ B6C3              ; ==============================================================================================
   2+ B6C3              ; RS232 through +3 printer port, 57600, 8N1, +CTS, -RTS
   3+ B6C3              ; 57600bps (17,3611s)
   4+ B6C3              ; 61.57813T on ZX 128k, 61T will take 17.19811s, error -0.9% (58146bps)
   5+ B6C3              ; 60.76389T on ZX 48k,  61T will take 17.42857s, error +0.4% (57377bps)
   6+ B6C3              ;
   7+ B6C3              ; Based on some *amazing* work here: https://cygnus.speccy.cz/popis_zx-spectrum_dg192k_rs232.php
   8+ B6C3              ; ==============================================================================================
   9+ B6C3
  10+ B6C3              ; --------------------------------------
  11+ B6C3              ; 0xFFD: Printer port data latch (Write)
  12+ B6C3              ; --------------------------------------
  13+ B6C3              ;         Bit 7   TX
  14+ B6C3              ;         Bit 0   CTS
  15+ B6C3              ; --------------------------------------
  16+ B6C3              ; 0xFFD: Printer port busy (Read)
  17+ B6C3              ; --------------------------------------
  18+ B6C3              ;         Bit 0   RX
  19+ B6C3              ; --------------------------------------
  20+ B6C3
  21+ B6C3              uartBegin:
  22+ B6C3 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC
  23+ B6C6 3E 80            ld   a, 0x80                ; 7T    TX = 1, CTS = 0 (allow sending)
  24+ B6C8 ED 79            out  (c), a                 ; 12T
  25+ B6CA
  26+ B6CA FB               ei                          ; Re-enable interrupts, just in case
  27+ B6CB 3E 32            ld   a, 50                  ; Flush anything left in TX buffer, by keeping CTS low
  28+ B6CD 76           1:  halt                        ; for ~1 second
  29+ B6CE 3D               dec  a
  30+ B6CF 20 FC            jr   nz, 1B
  31+ B6D1 F3               di                          ; Timing critical now, so diable interrupts
  32+ B6D2
  33+ B6D2 3E 81            ld   a, 0x81                ; 7T    TX = 1, CTS = 1 (stop sending)
  34+ B6D4 ED 79            out  (c), a                 ; 12T
  35+ B6D6
  36+ B6D6 DD 7E 00         ld   a, (ix + 0)            ; 19T   Wait at least one bit
  37+ B6D9 DD 7E 00         ld   a, (ix + 0)            ; 19T
  38+ B6DC DD 7E 00         ld   a, (ix + 0)            ; 19T
  39+ B6DF C9               ret                         ; 10T
  40+ B6E0
  41+ B6E0              uartWriteByte:
  42+ B6E0 F3               di
  43+ B6E1
  44+ B6E1 01 FD 0F         ld   bc, 0xFFD              ; 10T Printer port to BC
  45+ B6E4 26 08            ld   h, 8                   ; 7T H serves as an 8-bit counter
  46+ B6E6 6F               ld   l, a                   ; 4T copy data from A to L
  47+ B6E7
  48+ B6E7 00               nop                         ; 4T
  49+ B6E8 00               nop                         ; 4T
  50+ B6E9 00               nop                         ; 4T
  51+ B6EA 00               nop                         ; 4T
  52+ B6EB
  53+ B6EB              ; start bit
  54+ B6EB 3E 01            ld   a, 1                   ; TX = 1 (Start bit), CTS = 0 (allow sending - why, we're sending?! - maybe should be 0x81?)
  55+ B6ED ED 79            out  (c), a                 ; 12T write to port
  56+ B6EF
  57+ B6EF 00               nop                         ; 4T
  58+ B6F0 00               nop                         ; 4T
  59+ B6F1 00               nop                         ; 4T
  60+ B6F2 00               nop                         ; 4T
  61+ B6F3
  62+ B6F3              ; data bits
  63+ B6F3              txLoop:
  64+ B6F3 3E 00            ld   a, 0                   ; 7T delay
  65+ B6F5 3E 00            ld   a, 0                   ; 7T delay
  66+ B6F7
  67+ B6F7 CB 0D            rrc  l                      ; 8T next bit at bit position 7
  68+ B6F9 3E 01            ld   a, 1                   ; 7T prepare a mask
  69+ B6FB B5               or   l                      ; 4T add a mask
  70+ B6FC
  71+ B6FC              ; from the beginning start bit 12 + 8 + 8 + 7 + 7 + 8 + 7 + 4 = 61T
  72+ B6FC              ; from last bit 12 + 4 + 12 + 7 + 7 + 8 + 7 + 4 = 61T
  73+ B6FC
  74+ B6FC ED 79            out  (c), a                 ; 12T write to port
  75+ B6FE 25               dec  h                      ; 4T bit counter
  76+ B6FF 20 F2            jr   nz, txLoop             ; 12 / 7T repeat
  77+ B701
  78+ B701              ; stop bit
  79+ B701 DD 7E 00         ld   a, (ix + 0)            ; 19T delay
  80+ B704 23               inc  hl                     ; 6T delay
  81+ B705 2B               dec  hl                     ; 6T delay
  82+ B706 3E 81            ld   a, 0x81                ; 7T, keep bit 0 (CTS) and 7 (TX - stop bit) high (stop sending)
  83+ B708
  84+ B708              ; since the last out in the cycle 12 + 4 + 7 + 19 + 6 + 6 + 7 = 61T
  85+ B708
  86+ B708 ED 79            out   (c), a                ; 12T write to port
  87+ B70A FB               ei
  88+ B70B C9               ret                         ; 10T extends the stop bit duration
  89+ B70C
  90+ B70C              uartReadBlocking:
  91+ B70C F3               di
  92+ B70D
  93+ B70D AF               xor  a                      ; Reset read error count
  94+ B70E 32 5C B7         ld   (readErrors), a
  95+ B711
  96+ B711 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC
  97+ B714
  98+ B714              ; Check that RX is idle
  99+ B714
 100+ B714              rxRetry:
 101+ B714 ED 78            in   a, (c)                 ; 12T   reads the port, sets the sign flag according to MSB
 102+ B716 E6 01            and  1                      ; 7T
 103+ B718 CA 50 B7         jp   z, rxError             ; 10T   error, RxD should be in log. 1 (idle state / stop bit)
 104+ B71B
 105+ B71B              ; detection delay 12 + 7 + 10 = 29T
 106+ B71B
 107+ B71B 3E 80            ld   a, 0x80                ; 7T    TX = 1, CTS = 0
 108+ B71D ED 79            out  (c), a                 ; 12T   Assert CTS to get a byte from the ESP
 109+ B71F
 110+ B71F              ; Wait for the start bit
 111+ B71F
 112+ B71F              rxWFSB:
 113+ B71F ED 78        1:  in   a, (c)                 ; 12T   read port
 114+ B721 0F               rrca                        ; 4T    bit 0 to carry flag
 115+ B722 DA 1F B7         jp   c, 1B                  ; 10T   Repeat to start bit
 116+ B725
 117+ B725              ; waiting loop 12 + 4 + 10 = 26T
 118+ B725
 119+ B725              ; Immediately de-assert CTS to stop the ESP transmitting another byte
 120+ B725              ; while we process this one
 121+ B725
 122+ B725 3E 81            ld   a, 0x81                ; 7T    TX = 1, CTS = 1
 123+ B727 ED 79            out  (c), a                 ; 12T
 124+ B729
 125+ B729              ; start bit started, waiting for bit 0
 126+ B729              ; the wait length is chosen so that bit 0 is somewhere in its middle
 127+ B729              ; at least 15T has passed from the edge of the start bit, at most 41T, we take an average of 28T
 128+ B729              ; you still have to wait 1.5 x 61T - 28T = 63.5T (of which 11T for another IN instruction)
 129+ B729
 130+ B729 D9               exx                         ; 4T    secondary set
 131+ B72A 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC '(and delay at the same time)
 132+ B72D 23               inc  hl                     ; 6T    delay
 133+ B72E 2B               dec  hl                     ; 6T    delay
 134+ B72F 26 07            ld   h, 7                   ; 7T    in the cycle will be read 7 bits and 8th at the end of the cycle
 135+ B731
 136+ B731              ; 6 + 6 + 4 + 10 + 6 + 6 + 7 + 7 = 52T
 137+ B731              ; now bit 0 is somewhere in the middle, we can read 8 times with a distance of 61T
 138+ B731
 139+ B731              rxLoop:
 140+ B731 ED 78            in   a, (c)                 ; 12T   load port
 141+ B733 0F               rrca                        ; 4T    bit 0 to carry flag
 142+ B734 CB 1D            rr   l                      ; 8T    build byte in L
 143+ B736 3E 00            ld   a, 0                   ; 7T    delay
 144+ B738 3E 00            ld   a, 0                   ; 7T    delay
 145+ B73A ED 5F            ld   a, r                   ; 9T    delay
 146+ B73C 25               dec  h                      ; 4T    counter
 147+ B73D C2 31 B7         jp   nz, rxLoop             ; 10T   reads more bits
 148+ B740
 149+ B740              ; 12 + 4 + 8 + 7 + 7 + 9 + 4 + 10 = 61T if repeated (bits 0 to 6)
 150+ B740
 151+ B740              ; followed by reading the MSB, bit 7
 152+ B740
 153+ B740 ED 78            in   a, (c)                 ; 12T   read port (MSB is somewhere in the middle of the duration, to the stop bit approx. 31  13T  2T accuracy deviation 3%)
 154+ B742 0F               rrca                        ; 4T    bit 0 to carry flag
 155+ B743 7D               ld   a, l                   ; 4T    almost assembled byte to A
 156+ B744 1F               rra                         ; 4T    rotate the MSB to bit 7 in A
 157+ B745
 158+ B745              ; 12 + 4 + 4 + 4 = 24T
 159+ B745
 160+ B745 D9               exx                         ; 4T    primary set
 161+ B746
 162+ B746              ; Delay for stop bit
 163+ B746
 164+ B746 08               ex   af, af'                ; 4T
 165+ B747 DD 7E 00         ld   a, (ix + 0)            ; 19T delay
 166+ B74A DD 7E 00         ld   a, (ix + 0)            ; 19T delay
 167+ B74D              ;    xor  a                      ; 4T
 168+ B74D              ;     out  (-2), a                ; 11T    Black border
 169+ B74D 08               ex   af, af'                ; 4T
 170+ B74E
 171+ B74E FB               ei                          ; 4T
 172+ B74F C9               ret                         ; 10T   Return with byte in A
 173+ B750
 174+ B750              ; 4 + 19 + 4 + 11 + 4 + 4 + 10 = 53T
 175+ B750
 176+ B750              rxError
 177+ B750 21 5C B7         ld   hl, readErrors         ; 3T
 178+ B753 34               inc  (hl)                   ; 11T
 179+ B754 C2 14 B7         jp   nz, rxRetry            ; 7/12T
 180+ B757
 181+ B757 3E 02            ld   a, 2                   ; 7T
 182+ B759 D3 FE            out  (-2), a                ; 11T
 183+ B75B C9               ret                         ; 10T
 184+ B75C
 185+ B75C              ; 3 + 11 + 12 = 26T
 186+ B75C
 187+ B75C              readErrors:
 188+ B75C 00               db   0
 189+ B75D
 190+ B75D              ; saving the apartment takes 4 + 7 + 4 + 4 + 10 = 29T
 191+ B75D              ; total 24 + 29 = 53T
 192+ B75D              ; including line status detection, 75T with verification before start bit
 193+ B75D              ; otherwise, you can directly wait for the next start bit
 194+ B75D
# file closed: prtwifi.asm
 433  B75D                  include "ring.asm"
# file opened: ring.asm
   1+ B75D              ; Pushes A to ring buffer
   2+ B75D              pushRing
   3+ B75D 4F               ld   c, a                           ; Save byte in A to C
   4+ B75E 06 20            ld   b, 32
   5+ B760
   6+ B760                  ; Copy bytes in buffer down one position
   7+ B760
   8+ B760 21 9F B7         ld   hl, ring_buffer + 1
   9+ B763 11 9E B7         ld   de, ring_buffer
  10+ B766              1:
  11+ B766 7E               ld   a, (hl)
  12+ B767 12               ld   (de), a
  13+ B768 23               inc  hl
  14+ B769 13               inc  de
  15+ B76A 10 FA            djnz 1B
  16+ B76C
  17+ B76C 79               ld   a, c                           ; Get byte back from C
  18+ B76D 21 BD B7         ld   hl, ring_buffer + 31           ; Write byte to end of buffer
  19+ B770 77               ld   (hl), a
  20+ B771 C9               ret
  21+ B772
  22+ B772              ; Entry:
  23+ B772              ;   HL: Search string (null terminated)
  24+ B772              ; Exit:
  25+ B772              ;   Fc: 1 Found
  26+ B772              ;       0 Not found
  27+ B772              searchRing:
  28+ B772 E5               push hl
  29+ B773
  30+ B773 06 00            ld   b, 0
  31+ B775 11 BE B7         ld   de, ring_buffer + 32           ; Start at end of buffer
  32+ B778
  33+ B778              strlen:
  34+ B778 7E               ld   a, (hl)                        ; Get the length of the string to compare
  35+ B779 23               inc  hl                             ; Count bytes in B until we get to a 0
  36+ B77A 1B               dec  de                             ; Move ring buffer search position back
  37+ B77B 04               inc  b
  38+ B77C A7               and  a
  39+ B77D C2 78 B7         jp   nz, strlen
  40+ B780
  41+ B780 05               dec  b                              ; Don't count 0 string terminator
  42+ B781 13               inc  de
  43+ B782
  44+ B782 E1               pop  hl
  45+ B783
  46+ B783              strcmp:                                 ; B = strlen (without 0 terminator)
  47+ B783 1A               ld   a, (de)
  48+ B784 BE               cp   (hl)
  49+ B785 C2 8E B7         jp   nz, .failed
  50+ B788 13               inc  de
  51+ B789 23               inc  hl
  52+ B78A 10 F7            djnz strcmp
  53+ B78C 37               scf
  54+ B78D C9               ret
  55+ B78E
  56+ B78E              .failed
  57+ B78E AF               xor  a
  58+ B78F C9               ret
  59+ B790
  60+ B790              clearRing:
  61+ B790 AF               xor  a
  62+ B791 21 9E B7         ld   hl, ring_buffer
  63+ B794 11 9F B7         ld   de, ring_buffer + 1
  64+ B797 01 20 00         ld   bc, 32
  65+ B79A 77               ld   (hl), a
  66+ B79B ED B0            ldir
  67+ B79D C9               ret
  68+ B79E
  69+ B79E              ; dumpRing:
  70+ B79E              ;     push af
  71+ B79E              ;
  72+ B79E              ;     ld   b, 32
  73+ B79E              ;     ld   hl, ring_buffer
  74+ B79E              ; 1:
  75+ B79E              ;     ld   a, (hl)
  76+ B79E              ;     cp   31
  77+ B79E              ;     jr   c, 1F
  78+ B79E              ; 2:
  79+ B79E              ;     push bc
  80+ B79E              ;     push hl
  81+ B79E              ;     call putc
  82+ B79E              ;     pop  hl
  83+ B79E              ;     pop  bc
  84+ B79E              ;
  85+ B79E              ;     inc  hl
  86+ B79E              ;     djnz 1B
  87+ B79E              ;
  88+ B79E              ;     ld   a, 13
  89+ B79E              ;     call putc
  90+ B79E              ;
  91+ B79E              ;     pop  af
  92+ B79E              ;     ret
  93+ B79E              ; 1:
  94+ B79E              ;     ld   a, '.'
  95+ B79E              ;     jr   2B
  96+ B79E
  97+ B79E              ring_buffer
  98+ B79E 00 00 00...      ds  32, 0
  99+ B7BE
# file closed: ring.asm
 434  B7BE                  include "utils.asm"
# file opened: utils.asm
   1+ B7BE              ;    IFNDEF ZX48
   2+ B7BE              ; ; This routine checks availability of extended(128K) memory.
   3+ B7BE              ; ; Output:
   4+ B7BE              ; ; Flag: Z - High memory available
   5+ B7BE              ; checkHighMem:
   6+ B7BE              ;     xor a : call changeBank : ld hl, #c000 : xor a : ld (hl), a ; Let's write in zero page zero value
   7+ B7BE              ;     inc a : call changeBank : ld a, 13 : ld (hl), a             ; In other page - any other value. Let's write luck 13
   8+ B7BE              ;     xor a : call changeBank : ld a, (hl) : and a                ; When we back to zero page - still there zero?!
   9+ B7BE              ;     ret
  10+ B7BE              ;
  11+ B7BE              ; ; A - memory bank
  12+ B7BE              ; changeBank:
  13+ B7BE              ;     ld bc, #7ffd : or #18 : out (c), a : ld (bankm), a
  14+ B7BE              ;     re
  15+ B7BE              ;     ENDIF
  16+ B7BE
  17+ B7BE              uartWriteStringZ:
  18+ B7BE              ;     IFDEF DEBUG
  19+ B7BE              ;     push hl
  20+ B7BE              ;     call putstr
  21+ B7BE              ;     pop  hl
  22+ B7BE              ;     ENDIF
  23+ B7BE
  24+ B7BE 7E           1:  ld   a, (hl)
  25+ B7BF B7               or   a
  26+ B7C0 CA AC B4         jp   z, restoreBorder               ; Return via restoreBorder
  27+ B7C3
  28+ B7C3 E5               push hl
  29+ B7C4 CD E0 B6         call uartWriteByte
  30+ B7C7 E1               pop  hl
  31+ B7C8
  32+ B7C8 ED 5F            ld   a, r                           ; Flash the border
  33+ B7CA E6 06            and  %00000110
  34+ B7CC F6 01            or   1                              ; Ensure not black
  35+ B7CE D3 FE            out  (-2), a
  36+ B7D0
  37+ B7D0 23               inc  hl
  38+ B7D1 18 EB            jr   1B
  39+ B7D3
  40+ B7D3              ; Print zero-terminated string
  41+ B7D3              ; HL - string pointer
  42+ B7D3              ; putStringZ:
  43+ B7D3              ; printZ64:
  44+ B7D3              ;     IFNDEF ZX48
  45+ B7D3              ;     ld a, 7 : call changeBank
  46+ B7D3              ;     ENDIF
  47+ B7D3              ;     ld   b, 41
  48+ B7D3              ; 1:
  49+ B7D3              ;     ld   a, (hl) : and a : ret z
  50+ B7D3              ;     push bc
  51+ B7D3              ;     push hl : call putC : pop hl
  52+ B7D3              ;     inc  hl
  53+ B7D3              ;     pop  bc
  54+ B7D3              ;
  55+ B7D3              ;     dec  b                              ; Limit string display length
  56+ B7D3              ;     ld   a, b
  57+ B7D3              ;     or   a
  58+ B7D3              ;     ret  z
  59+ B7D3              ;     jr  1B
  60+ B7D3              ;
  61+ B7D3              ; printT64:
  62+ B7D3              ;     ld   b, 41
  63+ B7D3              ; 1:
  64+ B7D3              ;     xor  a : or b : ret z
  65+ B7D3              ;
  66+ B7D3              ;     ld   a, (hl)
  67+ B7D3              ;
  68+ B7D3              ;     and  a : ret z
  69+ B7D3              ;     cp   09 : ret z
  70+ B7D3              ;
  71+ B7D3              ;     push bc
  72+ B7D3              ;
  73+ B7D3              ;     push hl : call putC : pop hl
  74+ B7D3              ;
  75+ B7D3              ;     inc  hl : pop bc : dec b
  76+ B7D3              ;     jr   1B
  77+ B7D3              ;
  78+ B7D3              ; printL64:
  79+ B7D3              ;
  80+ B7D3              ;     ld b, 41
  81+ B7D3              ; .loop
  82+ B7D3              ;     xor a : or b : ret z
  83+ B7D3              ;     ld a, (hl)
  84+ B7D3              ;
  85+ B7D3              ;     and a : ret z
  86+ B7D3              ;     cp #0A : ret z
  87+ B7D3              ;     cp #0D : ret z;
  88+ B7D3              ;
  89+ B7D3              ;     push hl, bc : call putC : pop bc, hl
  90+ B7D3              ;     dec b
  91+ B7D3              ;     inc hl
  92+ B7D3              ;     jr .loop
  93+ B7D3
  94+ B7D3              ; HL - string
  95+ B7D3              ; Return: bc - len
  96+ B7D3              getStringLength:
  97+ B7D3 01 00 00         ld bc, 0
  98+ B7D6              strLnLp
  99+ B7D6 7E               ld a, (hl)
 100+ B7D7 A7               and a
 101+ B7D8 C8               ret z
 102+ B7D9 03               inc bc
 103+ B7DA 23               inc hl
 104+ B7DB 18 F9            jr strLnLp
 105+ B7DD
 106+ B7DD              SkipWhitespace:
 107+ B7DD 7E               ld a, (hl)
 108+ B7DE FE 20            cp ' '
 108+ B7E0 C0             ret nz
 109+ B7E1 23               inc hl
 110+ B7E2 18 F9            jr SkipWhitespace
 111+ B7E4
 112+ B7E4              ; DE <= StringZ
 113+ B7E4              ; HL => output
 114+ B7E4              atoi:
 115+ B7E4 21 00 00         ld   hl, 0
 116+ B7E7 1A           1:  ld   a, (de)
 117+ B7E8 A7               and  a
 117+ B7E9 C8             ret z
 118+ B7EA FE 0D            cp   13
 118+ B7EC C8             ret z
 119+ B7ED FE 09            cp   9
 119+ B7EF C8             ret z
 120+ B7F0 CD F6 B7         call atoi2
 121+ B7F3 13               inc  de
 122+ B7F4 18 F1            jr 1B
 123+ B7F6
 124+ B7F6              atoi2:
 125+ B7F6 D6 30            sub  0x30
 126+ B7F8 4D               ld   c, l
 127+ B7F9 44               ld   b, h
 128+ B7FA 29               add  hl, hl
 129+ B7FB 29               add  hl, hl
 130+ B7FC 09               add  hl, bc
 131+ B7FD 29               add  hl, hl
 132+ B7FE 4F               ld   c, a
 133+ B7FF 06 00            ld   b, 0
 134+ B801 09               add  hl, bc
 135+ B802 C9               ret
 136+ B803
 137+ B803              ;findEnd:
 138+ B803              ;    ld   a, (hl)
 139+ B803              ;    and  a
 140+ B803              ;    ret  z
 141+ B803              ;    inc  hl
 142+ B803              ;    jr   findEnd
 143+ B803
 144+ B803              ;;;;;;;;;;;;;;;;;;;;;;;;
 145+ B803
 146+ B803              ; Binary to decimal stuff
 147+ B803              ; From https://www.msx.org/forum/development/msx-development/32-bit-long-ascii
 148+ B803
 149+ B803              ; Combined routine for conversion of different sized binary numbers into
 150+ B803              ; directly printable ASCII(Z)-string
 151+ B803              ; Input value in registers, number size and -related to that- registers to fill
 152+ B803              ; is selected by calling the correct entry:
 153+ B803              ;
 154+ B803              ;  entry  inputregister(s)  decimal value 0 to:
 155+ B803              ;   B2D8             A                    255  (3 digits)
 156+ B803              ;   B2D16           HL                  65535   5   "
 157+ B803              ;   B2D24         E:HL               16777215   8   "
 158+ B803              ;   B2D32        DE:HL             4294967295  10   "
 159+ B803              ;   B2D48     BC:DE:HL        281474976710655  15   "
 160+ B803              ;   B2D64  IX:BC:DE:HL   18446744073709551615  20   "
 161+ B803              ;
 162+ B803              ; The resulting string is placed into a small buffer attached to this routine,
 163+ B803              ; this buffer needs no initialization and can be modified as desired.
 164+ B803              ; The number is aligned to the right, and leading 0's are replaced with spaces.
 165+ B803              ; On exit HL points to the first digit, (B)C = number of decimals
 166+ B803              ; This way any re-alignment / postprocessing is made easy.
 167+ B803              ; Changes: AF,BC,DE,HL,IX
 168+ B803              ; P.S. some examples below
 169+ B803
 170+ B803              ; by Alwin Henseler
 171+ B803
 172+ B803 26 00        B2D8:    LD H,0
 173+ B805 6F                    LD L,A
 174+ B806 1E 00        B2D16:   LD E,0
 175+ B808 16 00        B2D24:   LD D,0
 176+ B80A 01 00 00     B2D32:   LD BC,0
 177+ B80D DD 21 00 00  B2D48:   LD IX,0          ; zero all non-used bits
 178+ B811 22 9A B8     B2D64:   LD (B2DINV),HL
 179+ B814 ED 53 9C B8           LD (B2DINV+2),DE
 180+ B818 ED 43 9E B8           LD (B2DINV+4),BC
 181+ B81C DD 22 A0 B8           LD (B2DINV+6),IX ; place full 64-bit input value in buffer
 182+ B820 21 A2 B8              LD HL,B2DBUF
 183+ B823 11 A3 B8              LD DE,B2DBUF+1
 184+ B826 36 20                 LD (HL)," "
 185+ B828              B2DFILC: EQU $-1         ; address of fill-character
 186+ B828 01 12 00              LD BC,18
 187+ B82B ED B0                 LDIR            ; fill 1st 19 bytes of buffer with spaces
 188+ B82D ED 43 B5 B8           LD (B2DEND-1),BC ;set BCD value to "0" & place terminating 0
 189+ B831 1E 01                 LD E,1          ; no. of bytes in BCD value
 190+ B833 21 A2 B8              LD HL,B2DINV+8  ; (address MSB input)+1
 191+ B836 01 09 09              LD BC,0x0909
 192+ B839 AF                    XOR A
 193+ B83A 05           B2DSKP0: DEC B
 194+ B83B 28 29                 JR Z,B2DSIZ     ; all 0: continue with postprocessing
 195+ B83D 2B                    DEC HL
 196+ B83E B6                    OR (HL)         ; find first byte <>0
 197+ B83F 28 F9                 JR Z,B2DSKP0
 198+ B841 0D           B2DFND1: DEC C
 199+ B842 17                    RLA
 200+ B843 30 FC                 JR NC,B2DFND1   ; determine no. of most significant 1-bit
 201+ B845 1F                    RRA
 202+ B846 57                    LD D,A          ; byte from binary input value
 203+ B847 E5           B2DLUS2: PUSH HL
 204+ B848 C5                    PUSH BC
 205+ B849 21 B5 B8     B2DLUS1: LD HL,B2DEND-1  ; address LSB of BCD value
 206+ B84C 43                    LD B,E          ; current length of BCD value in bytes
 207+ B84D CB 12                 RL D            ; highest bit from input value -> carry
 208+ B84F 7E           B2DLUS0: LD A,(HL)
 209+ B850 8F                    ADC A,A
 210+ B851 27                    DAA
 211+ B852 77                    LD (HL),A       ; double 1 BCD byte from intermediate result
 212+ B853 2B                    DEC HL
 213+ B854 10 F9                 DJNZ B2DLUS0    ; and go on to double entire BCD value (+carry!)
 214+ B856 30 03                 JR NC,B2DNXT
 215+ B858 1C                    INC E           ; carry at MSB -> BCD value grew 1 byte larger
 216+ B859 36 01                 LD (HL),1       ; initialize new MSB of BCD value
 217+ B85B 0D           B2DNXT:  DEC C
 218+ B85C 20 EB                 JR NZ,B2DLUS1   ; repeat for remaining bits from 1 input byte
 219+ B85E C1                    POP BC          ; no. of remaining bytes in input value
 220+ B85F 0E 08                 LD C,8          ; reset bit-counter
 221+ B861 E1                    POP HL          ; pointer to byte from input value
 222+ B862 2B                    DEC HL
 223+ B863 56                    LD D,(HL)       ; get next group of 8 bits
 224+ B864 10 E1                 DJNZ B2DLUS2    ; and repeat until last byte from input value
 225+ B866 21 B6 B8     B2DSIZ:  LD HL,B2DEND    ; address of terminating 0
 226+ B869 4B                    LD C,E          ; size of BCD value in bytes
 227+ B86A B7                    OR A
 228+ B86B ED 42                 SBC HL,BC       ; calculate address of MSB BCD
 229+ B86D 54                    LD D,H
 230+ B86E 5D                    LD E,L
 231+ B86F ED 42                 SBC HL,BC
 232+ B871 EB                    EX DE,HL        ; HL=address BCD value, DE=start of decimal value
 233+ B872 41                    LD B,C          ; no. of bytes BCD
 234+ B873 CB 21                 SLA C           ; no. of bytes decimal (possibly 1 too high)
 235+ B875 3E 30                 LD A,"0"
 236+ B877 ED 6F                 RLD             ; shift bits 4-7 of (HL) into bit 0-3 of A
 237+ B879 FE 30                 CP "0"          ; (HL) was > 9h?
 238+ B87B 20 06                 JR NZ,B2DEXPH   ; if yes, start with recording high digit
 239+ B87D 0D                    DEC C           ; correct number of decimals
 240+ B87E 13                    INC DE          ; correct start address
 241+ B87F 18 04                 JR B2DEXPL      ; continue with converting low digit
 242+ B881 ED 6F        B2DEXP:  RLD             ; shift high digit (HL) into low digit of A
 243+ B883 12           B2DEXPH: LD (DE),A       ; record resulting ASCII-code
 244+ B884 13                    INC DE
 245+ B885 ED 6F        B2DEXPL: RLD
 246+ B887 12                    LD (DE),A
 247+ B888 13                    INC DE
 248+ B889 23                    INC HL          ; next BCD-byte
 249+ B88A 10 F5                 DJNZ B2DEXP     ; and go on to convert each BCD-byte into 2 ASCII
 250+ B88C ED 42                 SBC HL,BC       ; return with HL pointing to 1st decimal
 251+ B88E C9                    RET
 252+ B88F
 253+ B88F              AppendB2D:
 254+ B88F              ; Append results of B2D to string at HL
 255+ B88F EB               ex      de, hl  ; Get destination into DE
 256+ B890 21 A2 B8         ld      hl, B2DBUF
 257+ B893 CD DD B7         call        SkipWhitespace
 258+ B896 ED B0            ldir
 259+ B898 EB               ex      de, hl  ; Get destination into DE
 260+ B899 C9               ret
 261+ B89A
 262+ B89A 00 00 00...  B2DINV:  DS 8            ; space for 64-bit input value (LSB first)
 263+ B8A2 00 00 00...  B2DBUF:  DS 20           ; space for 20 decimal digits
 264+ B8B6 00           B2DEND:  DB 0 ; space for terminating 0
 265+ B8B7
# file closed: utils.asm
 435  B8B7                  include "wifi.asm"
# file opened: wifi.asm
   1+ B8B7              ROM_OPEN_CHANNEL        EQU  0x1601             ; Open a channel
   2+ B8B7              ROM_PRINT               EQU  0x203C             ; Print a string
   3+ B8B7
   4+ B8B7                  macro dodos n
   5+ B8B7 ~                    ld   ix, n
   6+ B8B7 ~                    call dos_ix
   7+ B8B7                  endm
   8+ B8B7
   9+ B8B7              loadWiFiConfig:
  10+ B8B7 3E 01            ld      a, 1
  11+ B8B9 CD 01 16         call    ROM_OPEN_CHANNEL
  12+ B8BC 11 0A BB         ld      de, loadingMsg
  13+ B8BF 01 19 00         ld      bc, loadingMsgLen
  14+ B8C2 CD 3C 20         call    ROM_PRINT
  15+ B8C5
  16+ B8C5 06 01            ld      b, 1
  17+ B8C7 21 29 BC         ld      hl, conf_file
  18+ B8CA 0E 01            ld      c, ACCESS_MODE_EXCLUSIVE_READ
  19+ B8CC 16 00            ld      d, CREATE_ACTION_DONT_CREATE
  20+ B8CE 1E 01            ld      e, OPEN_ACTION_READ_HEADER
  21+ B8D0                  dodos   dos_open
  21+ B8D0 DD 21 06 01 >        ld   ix, dos_open
  21+ B8D4 CD A5 B5    >        call dos_ix
  22+ B8D7 30 1D            jr      nc, .error
  23+ B8D9
  24+ B8D9 06 01            ld      b, 1
  25+ B8DB 0E 00            ld      c, 0
  26+ B8DD 11 A0 00         ld      de, 160
  27+ B8E0 21 36 BC         ld      hl, ssid
  28+ B8E3                  dodos   dos_read
  28+ B8E3 DD 21 12 01 >        ld   ix, dos_read
  28+ B8E7 CD A5 B5    >        call dos_ix
  29+ B8EA 30 0A            jr      nc, .error
  30+ B8EC
  31+ B8EC 06 01            ld      b, 1
  32+ B8EE                  dodos   dos_close
  32+ B8EE DD 21 09 01 >        ld   ix, dos_close
  32+ B8F2 CD A5 B5    >        call dos_ix
  33+ B8F5 C9               ret
  34+ B8F6
  35+ B8F6              .error
  36+ B8F6 3E 02            ld      a, 2
  37+ B8F8 D3 FE            out     (-2), a
  38+ B8FA C9               ret
  39+ B8FB
  40+ B8FB              ; Initialize WiFi chip and connect to WiFi
  41+ B8FB              initWiFi
  42+ B8FB 3E 01            ld      a, 1
  43+ B8FD CD 01 16         call    ROM_OPEN_CHANNEL
  44+ B900 11 23 BB         ld      de, connectingMsg
  45+ B903 01 19 00         ld      bc, connectingMsgLen
  46+ B906 CD 3C 20         call    ROM_PRINT
  47+ B909
  48+ B909 CD C3 B6         call    uartBegin
  49+ B90C 21 28 BA         ld      hl, cmd_rst
  50+ B90F CD BE B7         call    uartWriteStringZ
  51+ B912
  52+ B912              1
  53+ B912                  ; Flush ESP TX buffer
  54+ B912 CD C3 B6         call    uartBegin
  55+ B915
  56+ B915                  ; WiFi client mode
  57+ B915 21 38 BA         ld      hl, cmd_mode
  58+ B918 CD 70 B9         call    okErrCmd
  59+ B91B E6 01            and     1
  60+ B91D 28 4B            jr      z, errInit
  61+ B91F
  62+ B91F                  ; Disable ECHO. BTW Basic UART test
  63+ B91F 21 31 BA         ld      hl, cmd_at
  64+ B922 CD 70 B9         call    okErrCmd
  65+ B925 E6 01            and     1
  66+ B927 28 41            jr      z, errInit
  67+ B929
  68+ B929                  ; Lets disconnect from last AP
  69+ B929 21 58 BA         ld      hl, cmd_cwqap
  70+ B92C CD 70 B9         call    okErrCmd
  71+ B92F E6 01            and     1
  72+ B931 28 37            jr      z, errInit
  73+ B933
  74+ B933                  ; Single connection mode
  75+ B933 21 4A BA         ld      hl, cmd_cmux
  76+ B936 CD 70 B9         call    okErrCmd
  77+ B939 E6 01            and     1
  78+ B93B 28 2D            jr      z, errInit
  79+ B93D
  80+ B93D                  ; FTP enables this info? We doesn't need it :-)
  81+ B93D 21 63 BA         ld      hl, cmd_inf_off
  82+ B940 CD 70 B9         call    okErrCmd
  83+ B943 E6 01            and     1
  84+ B945 28 23            jr      z, errInit
  85+ B947
  86+ B947              ; Access Point connection
  87+ B947 21 73 BA         ld      hl, cmd_cwjap1
  88+ B94A CD BE B7         call    uartWriteStringZ
  89+ B94D 21 36 BC         ld      hl, ssid
  90+ B950 CD BE B7         call    uartWriteStringZ
  91+ B953 21 82 BA         ld      hl, cmd_cwjap2
  92+ B956 CD BE B7         call    uartWriteStringZ
  93+ B959 21 86 BC         ld      hl, pass
  94+ B95C CD BE B7         call    uartWriteStringZ
  95+ B95F 21 86 BA         ld      hl, cmd_cwjap3
  96+ B962 CD 70 B9         call    okErrCmd
  97+ B965
  98+ B965 E6 01            and 1
  98+ B967 28 01         jr z, errInit
  99+ B969
 100+ B969 C9               ret
 101+ B96A
 102+ B96A              errInit
 103+ B96A                  ; ld hl, log_err : call putStringZ
 104+ B96A 3E 03            ld   a, 3
 105+ B96C D3 FE            out  (-2), a
 106+ B96E 18 FE            jr $
 107+ B970
 108+ B970              ; Send AT-command and wait for result.
 109+ B970              ; HL - Z-terminated AT-command(with CR/LF)
 110+ B970              ; A:
 111+ B970              ;    1 - Success
 112+ B970              ;    0 - Failed
 113+ B970              okErrCmd
 114+ B970 CD BE B7         call    uartWriteStringZ
 115+ B973              okErrCmdLp
 116+ B973 CD 0C B7         call    uartReadBlocking
 117+ B976 CD 5D B7         call    pushRing
 118+ B979
 119+ B979 21 EC BA         ld      hl, response_ok
 120+ B97C CD 72 B7         call    searchRing
 121+ B97F 38 13            jr      c, okErrOk
 122+ B981 21 F1 BA         ld      hl, response_err
 123+ B984 CD 72 B7         call    searchRing
 124+ B987 38 0E            jr      c, okErrErr
 125+ B989 21 FB BA         ld      hl, response_fail
 126+ B98C CD 72 B7         call    searchRing
 127+ B98F 38 06            jr      c, okErrErr
 128+ B991
 129+ B991 C3 73 B9         jp      okErrCmdLp
 130+ B994              okErrOk
 131+ B994 3E 01            ld      a, 1
 132+ B996 C9               ret
 133+ B997              okErrErr
 134+ B997 AF               xor     a
 135+ B998 C9               ret
 136+ B999
 137+ B999              ; Gets packet from network
 138+ B999              ; packet will be in var 'output_buffer'
 139+ B999              ; received packet size in var 'bytes_avail'
 140+ B999              ;
 141+ B999              ; If connection was closed it calls 'closed_callback'
 142+ B999              getPacket
 143+ B999 CD 0C B7         call    uartReadBlocking
 144+ B99C FE 2B            cp      '+'
 145+ B99E 28 34            jr      z, .checkIpdStart
 146+ B9A0 FE 4F            cp      'O'
 147+ B9A2 28 4A            jr      z, .checkClosed
 148+ B9A4 18 F3            jr      getPacket
 149+ B9A6
 150+ B9A6              .readPacket
 151+ B9A6 CD 13 BA         call    count_ipd_length
 152+ B9A9 22 04 BB         ld      (bytes_avail), hl
 153+ B9AC E5               push    hl
 154+ B9AD C1               pop     bc                      ; BC = byte count
 155+ B9AE
 156+ B9AE 2A C6 BB         ld      hl, (data_pointer)
 157+ B9B1              .readByte
 158+ B9B1 C5               push    bc
 159+ B9B2 E5               push    hl
 160+ B9B3 CD 0C B7         call    uartReadBlocking
 161+ B9B6
 162+ B9B6 F3               di
 163+ B9B7
 164+ B9B7 F5               push    af
 165+ B9B8 3A 01 B6         ld      a, (ddl_parms)
 166+ B9BB CD D5 B5         call    ram_page_in
 167+ B9BE F1               pop     af
 168+ B9BF
 169+ B9BF E1               pop     hl
 170+ B9C0 C1               pop     bc
 171+ B9C1
 172+ B9C1 77               ld      (hl), a
 173+ B9C2 23               inc     hl
 174+ B9C3 0B               dec     bc
 175+ B9C4
 176+ B9C4 C5               push    bc
 177+ B9C5 E5               push    hl
 178+ B9C6 CD E2 B5         call    ram_page_out
 179+ B9C9 E1               pop     hl
 180+ B9CA C1               pop     bc
 181+ B9CB
 182+ B9CB 78               ld      a, b
 183+ B9CC B1               or      c
 184+ B9CD 20 E2            jr      nz, .readByte
 185+ B9CF
 186+ B9CF 22 C6 BB         ld      (data_pointer), hl
 187+ B9D2 FB               ei
 188+ B9D3 C9               ret
 189+ B9D4
 190+ B9D4              .checkIpdStart
 191+ B9D4 CD 0C B7         call uartReadBlocking
 191+ B9D7 FE 49          cp 'I'
 191+ B9D9 20 BE          jr nz, getPacket
 192+ B9DB CD 0C B7         call uartReadBlocking
 192+ B9DE FE 50          cp 'P'
 192+ B9E0 20 B7          jr nz, getPacket
 193+ B9E2 CD 0C B7         call uartReadBlocking
 193+ B9E5 FE 44          cp 'D'
 193+ B9E7 20 B0          jr nz, getPacket
 194+ B9E9 CD 0C B7         call uartReadBlocking ; Comma
 195+ B9EC 18 B8            jr   .readPacket
 196+ B9EE
 197+ B9EE              .checkClosed
 198+ B9EE CD 0C B7         call uartReadBlocking
 198+ B9F1 FE 53          cp 'S'
 198+ B9F3 20 A4          jr nz, getPacket
 199+ B9F5 CD 0C B7         call uartReadBlocking
 199+ B9F8 FE 45          cp 'E'
 199+ B9FA 20 9D          jr nz, getPacket
 200+ B9FC CD 0C B7         call uartReadBlocking
 200+ B9FF FE 44          cp 'D'
 200+ BA01 20 96          jr nz, getPacket
 201+ BA03 CD 0C B7         call uartReadBlocking
 201+ BA06 FE 0D          cp 13
 201+ BA08 20 8F          jr nz, getPacket
 202+ BA0A C3 0D BA         jp   closed_callback
 203+ BA0D
 204+ BA0D              closed_callback:
 205+ BA0D AF               xor  a
 206+ BA0E 32 22 BC         ld   (connectionOpen), a
 207+ BA11 FB               ei
 208+ BA12 C9               ret
 209+ BA13
 210+ BA13              count_ipd_length
 211+ BA13 21 00 00         ld   hl, 0          ; count length
 212+ BA16 E5           1:  push hl
 213+ BA17 CD 0C B7         call uartReadBlocking
 214+ BA1A F5               push af
 215+ BA1B CD 5D B7         call pushRing
 216+ BA1E F1               pop  af
 217+ BA1F E1               pop  hl
 218+ BA20 FE 3A            cp   ':'
 219+ BA22 C8               ret  z
 220+ BA23
 221+ BA23 CD F6 B7         call atoi2
 222+ BA26 18 EE            jr   1B
 223+ BA28
 224+ BA28 41 54 2B 52  cmd_rst     defb "AT+RST",13, 10, 0
 224+ BA2C 53 54 0D 0A
 224+ BA30 00
 225+ BA31 41 54 45 30  cmd_at      defb "ATE0", 13, 10, 0                  ; Disable echo - less to parse
 225+ BA35 0D 0A 00
 226+ BA38 41 54 2B 43  cmd_mode    defb "AT+CWMODE_DEF=1",13,10,0          ; Client mode
 226+ BA3C 57 4D 4F 44
 226+ BA40 45 5F 44 45
 226+ BA44 46 3D 31 0D
 226+ BA48 0A 00
 227+ BA4A 41 54 2B 43  cmd_cmux    defb "AT+CIPMUX=0",13,10,0              ; Single connection mode
 227+ BA4E 49 50 4D 55
 227+ BA52 58 3D 30 0D
 227+ BA56 0A 00
 228+ BA58 41 54 2B 43  cmd_cwqap   defb "AT+CWQAP",13,10,0                 ; Disconnect from AP
 228+ BA5C 57 51 41 50
 228+ BA60 0D 0A 00
 229+ BA63 41 54 2B 43  cmd_inf_off defb "AT+CIPDINFO=0",13,10,0            ; doesn't send me info about remote port and ip
 229+ BA67 49 50 44 49
 229+ BA6B 4E 46 4F 3D
 229+ BA6F 30 0D 0A 00
 230+ BA73
 231+ BA73 41 54 2B 43  cmd_cwjap1  defb  "AT+CWJAP_CUR=", #22,0        ;Connect to AP. Send this -> SSID
 231+ BA77 57 4A 41 50
 231+ BA7B 5F 43 55 52
 231+ BA7F 3D 22 00
 232+ BA82 22 2C 22 00  cmd_cwjap2  defb #22,',',#22,0                  ; -> This -> Password
 233+ BA86 22 0D 0A 00  cmd_cwjap3  defb #22, 13, 10, 0                 ; -> And this
 234+ BA8A
 235+ BA8A 41 54 2B 43  cmd_open1   defb "AT+CIPSTART=", #22, "TCP", #22, ",", #22, 0
 235+ BA8E 49 50 53 54
 235+ BA92 41 52 54 3D
 235+ BA96 22 54 43 50
 235+ BA9A 22 2C 22 00
 236+ BA9E 22 2C 00     cmd_open2   defb #22, ",", 0
 237+ BAA1 0D 0A 00     cmd_open3   defb 13, 10, 0
 238+ BAA4 41 54 2B 43  cmd_send    defb "AT+CIPSEND=", 0
 238+ BAA8 49 50 53 45
 238+ BAAC 4E 44 3D 00
 239+ BAB0 41 54 2B 43  cmd_close   defb "AT+CIPCLOSE",13,10,0
 239+ BAB4 49 50 43 4C
 239+ BAB8 4F 53 45 0D
 239+ BABC 0A 00
 240+ BABE 41 54 2B 43  cmd_send_b  defb "AT+CIPSEND=1", 13, 10,0
 240+ BAC2 49 50 53 45
 240+ BAC6 4E 44 3D 31
 240+ BACA 0D 0A 00
 241+ BACD 43 4C 4F 53  closed      defb "CLOSED", 13, 10, 0
 241+ BAD1 45 44 0D 0A
 241+ BAD5 00
 242+ BAD6 0D 0A 2B 49  ipd         defb 13, 10, "+IPD,", 0
 242+ BADA 50 44 2C 00
 243+ BADE
 244+ BADE 72 65 61 64  response_rdy        defb 'ready', 0
 244+ BAE2 79 00
 245+ BAE4 69 6E 76 61  response_invalid    defb 'invalid', 0
 245+ BAE8 6C 69 64 00
 246+ BAEC 4F 4B 0D 0A  response_ok         defb 'OK', 13, 10, 0      ; Sucessful operation
 246+ BAF0 00
 247+ BAF1 0D 0A 45 52  response_err        defb 13, 10, 'ERROR', 13, 10, 0      ; Failed operation
 247+ BAF5 52 4F 52 0D
 247+ BAF9 0A 00
 248+ BAFB 0D 0A 46 41  response_fail       defb 13, 10, 'FAIL', 13, 10, 0       ; Failed connection to WiFi. For us same as ERROR
 248+ BAFF 49 4C 0D 0A
 248+ BB03 00
 249+ BB04
 250+ BB04 00 00        bytes_avail   defw 0
 251+ BB06 00 00        sbyte_buff    defb 0, 0
 252+ BB08
 253+ BB08 3E 00        send_prompt defb ">",0
 254+ BB0A
 255+ BB0A              loadingMsg:
 256+ BB0A 16 01 00 4C      defb 0x16, 1, 0, "Loading WiFi config..."
 256+ BB0E 6F 61 64 69
 256+ BB12 6E 67 20 57
 256+ BB16 69 46 69 20
 256+ BB1A 63 6F 6E 66
 256+ BB1E 69 67 2E 2E
 256+ BB22 2E
 257+ BB23              loadingMsgLen: equ $-loadingMsg
 258+ BB23
 259+ BB23              connectingMsg:
 260+ BB23 16 01 00 43      defb 0x16, 1, 0, "Connecting...         "
 260+ BB27 6F 6E 6E 65
 260+ BB2B 63 74 69 6E
 260+ BB2F 67 2E 2E 2E
 260+ BB33 20 20 20 20
 260+ BB37 20 20 20 20
 260+ BB3B 20
 261+ BB3C              connectingMsgLen equ $-connectingMsg
 262+ BB3C
# file closed: wifi.asm
 436  BB3C                  include "request.asm"
# file opened: request.asm
   1+ BB3C              ; hl - server
   2+ BB3C              ; de - path
   3+ BB3C              ; bc - port
   4+ BB3C              ; a - page
   5+ BB3C              loadSector:
   6+ BB3C CD 42 BB         call    makeRequest
   7+ BB3F C3 BB BB         jp      loadData
   8+ BB42
   9+ BB42              ; HL - domain stringZ
  10+ BB42              ; DE - path stringZ
  11+ BB42              ; BC - port stringZ
  12+ BB42              makeRequest:
  13+ BB42 22 23 BC         ld      (srv_ptr), hl
  14+ BB45 ED 53 25 BC      ld      (path_ptr), de
  15+ BB49 ED 43 27 BC      ld      (port_ptr), bc
  16+ BB4D
  17+ BB4D                  ; Open TCP connection
  18+ BB4D 21 8A BA         ld      hl, cmd_open1
  19+ BB50 CD BE B7         call    uartWriteStringZ
  20+ BB53 2A 23 BC         ld      hl, (srv_ptr)
  21+ BB56 CD BE B7         call    uartWriteStringZ
  22+ BB59 21 9E BA         ld      hl, cmd_open2
  23+ BB5C CD BE B7         call    uartWriteStringZ
  24+ BB5F 2A 27 BC         ld      hl, (port_ptr)
  25+ BB62 CD BE B7         call    uartWriteStringZ
  26+ BB65 21 A1 BA         ld      hl, cmd_open3
  27+ BB68 CD 70 B9         call    okErrCmd
  28+ BB6B
  29+ BB6B                  ; call    dumpRing
  30+ BB6B FE 01            cp      1
  31+ BB6D C2 B6 BB         jp      nz, reqErr
  32+ BB70
  33+ BB70                  ; Send request
  34+ BB70 21 A4 BA         ld      hl, cmd_send
  35+ BB73 CD BE B7         call    uartWriteStringZ
  36+ BB76 2A 25 BC         ld      hl, (path_ptr)
  37+ BB79 CD D3 B7         call    getStringLength
  38+ BB7C C5               push    bc
  39+ BB7D E1               pop     hl
  40+ BB7E CD 06 B8         call    B2D16
  41+ BB81
  42+ BB81 21 A2 B8         ld      hl, B2DBUF
  43+ BB84 CD DD B7         call    SkipWhitespace
  44+ BB87 CD BE B7         call    uartWriteStringZ
  45+ BB8A 21 CB BB         ld      hl, crlf
  46+ BB8D CD 70 B9         call    okErrCmd
  47+ BB90
  48+ BB90                  ; call    dumpRing
  49+ BB90 FE 01            cp      1
  50+ BB92 C2 B6 BB         jp      nz, reqErr
  51+ BB95
  52+ BB95              wPrmt:
  53+ BB95 CD 0C B7         call    uartReadBlocking
  54+ BB98 CD 5D B7         call    pushRing
  55+ BB9B 21 08 BB         ld      hl, send_prompt
  56+ BB9E CD 72 B7         call    searchRing
  57+ BBA1 30 F2            jr      nc, wPrmt
  58+ BBA3
  59+ BBA3 2A 25 BC         ld      hl, (path_ptr)
  60+ BBA6 CD BE B7         call    uartWriteStringZ
  61+ BBA9
  62+ BBA9 21 CB BB         ld      hl, crlf
  63+ BBAC CD BE B7         call    uartWriteStringZ
  64+ BBAF 3E 01            ld      a, 1
  65+ BBB1 32 22 BC         ld      (connectionOpen), a
  66+ BBB4 AF               xor     a
  67+ BBB5 C9               ret
  68+ BBB6
  69+ BBB6              reqErr:
  70+ BBB6 3E 02            ld      a, 2
  71+ BBB8 D3 FE            out     (-2), a
  72+ BBBA C9               ret
  73+ BBBB
  74+ BBBB              ; HL - data pointer
  75+ BBBB              ; data_pointer = pointer to buffer
  76+ BBBB              loadData:
  77+ BBBB CD 99 B9         call    getPacket                ; Fetch next data packet
  78+ BBBE
  79+ BBBE 3A 22 BC         ld      a, (connectionOpen)      ; Check connection status
  80+ BBC1 B7               or      a                        ; Test if zero
  81+ BBC2 C8               ret     z                        ; Exit loop if connection closed
  82+ BBC3
  83+ BBC3 C3 BB BB         jp      loadData                 ; Process next packet
  84+ BBC6
  85+ BBC6 00 00        data_pointer    defw    0
  86+ BBC8 00 00        data_recv       defw    0
  87+ BBCA 00           fstream         defb    0
  88+ BBCB
  89+ BBCB 0D 0A 00     crlf            defb    13, 10, 0
  90+ BBCE
  91+ BBCE 00 00 00...  d_path          defs    32, 0
  92+ BBEE 31 39 32 2E  d_host          defb    '192.168.7.164', 0
  92+ BBF2 31 36 38 2E
  92+ BBF6 37 2E 31 36
  92+ BBFA 34 00
  93+ BBFC 00 00 00...                  defs    32
  94+ BC1C 37 36 35 30  d_port          db      '7650', 0
  94+ BC20 00
  95+ BC21 00                           defs    1
  96+ BC22
  97+ BC22 00           connectionOpen  db      0
  98+ BC23
  99+ BC23 00 00        srv_ptr         dw  0
 100+ BC25 00 00        path_ptr        dw  0
 101+ BC27 00 00        port_ptr        dw  0
 102+ BC29
# file closed: request.asm
 437  BC29              ;    include "screen42.asm"
 438  BC29              ;    include "font42.asm"
 439  BC29
 440  BC29              conf_file
 441  BC29 69 77 2E 63      defb "iw.cfg",0xff
 441  BC2D 66 67 FF
 442  BC30 FF FF FF...      defs 13-($-conf_file), 0xff
 443  BC36
 444  BC36              ssid:
 445  BC36 00 00 00...      defs    80
 446  BC86              pass:
 447  BC86 00 00 00...      defs    80
 448  BCD6
 449  BCD6              end:
 450  BCD6
 451  BCD6              ; ddl_parms layout
 452  BCD6
 453  BCD6              ; Off.    Size  Desc
 454  BCD6              ; +$00    1     Buffer page
 455  BCD6              ; +$01    2     Buffer address
 456  BCD6              ; +$03    2     Sector size in bytes
 457  BCD6              ; +$05    1     # Command bytes
 458  BCD6
 459  BCD6              ; READ
 460  BCD6
 461  BCD6              ; +$06    1     Command byte
 462  BCD6              ; +$07    1     Unit byte                   x x x x x H U1 U0
 463  BCD6              ; +$08    1     Track
 464  BCD6              ; +$09    1     Side
 465  BCD6              ; +$0A    1     1st sector id
 466  BCD6              ; +$0B    1     Sector size
 467  BCD6              ; +$0C    1     Last sector id (=1st)
 468  BCD6              ; +$0D    1     Gap size
 469  BCD6              ; +$0E    1     Dummy data length ($ff)
 470  BCD6
 471  BCD6                  save3dos "driven.bin", start, end-start
 472  BCD6                  savebin  "drvn.bin", start, end-start
 473  BCD6
# file closed: drive_n.asm
