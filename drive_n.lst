# file opened: drive_n.asm
   1  0000                      device ZXSPECTRUM128
   2  0000
   3  0000              bank1       equ 0x7ffd
   4  0000              bankm       equ 0x5B5c
   5  0000              xdpb_ptrs   equ 0xe2a0              ; This is the same on the +3e, +3 or +2A
   6  0000              bordcr      equ $5c48
   7  0000
   8  0000                  org     0xc000 - (3*1024)
   9  B400
  10  B400              start:
  11  B400                  display $
  12  B400 C3 08 B4         jp      start2
  13  B403
  14  B403                  ; Variables that can be peeked / poked from BASIC
  15  B403
  16  B403 E5 BB            defw    d_host                  ; Addresses so we can poke in IP address
  17  B405 13 BC            defw    d_port                  ; and port of server if needed
  18  B407              disk_type:
  19  B407 00               defb    0                       ; Disk type
  20  B408
  21  B408              start2:
  22  B408
  23  B408                  ; Set up the stack and save HL' so we can return to BASIC
  24  B408
  25  B408 F3               di
  26  B409 ED 73 46 B6      ld   (old_sp), sp               ; Move stack so it doesn't get paged out
  27  B40D 31 AC B6         ld   sp, tmp_stack              ; when calling +3DOS
  28  B410 D9               exx
  29  B411 22 06 B6         ld   (temp_hl), hl              ; Save HL' as it's needed if returning to BASIC
  30  B414 D9               exx
  31  B415 FB               ei
  32  B416
  33  B416                  ; Load WiFi config + init ESP
  34  B416
  35  B416 3A 08 B6         ld   a, (wifiConnected)
  36  B419 B7               or   a
  37  B41A 20 0B            jr   nz, 1F
  38  B41C
  39  B41C              ;        call text_init
  40  B41C
  41  B41C CD A0 B8         call loadWiFiConfig
  42  B41F CD E4 B8         call initWiFi
  43  B422 3E 01            ld   a, 1                           ; Flag wifi as connected
  44  B424 32 08 B6         ld   (wifiConnected), a
  45  B427
  46  B427              1:
  47  B427                  ; Set up XDPB for drive 'N:'
  48  B427
  49  B427 3E 4E            ld      a, 'N'
  50  B429 CD 6B B5         call    getXDPBPtr              ; Return the pointer to XDPB for drive N
  51  B42C
  52  B42C F3               di
  53  B42D 3E 07            ld      a, 7
  54  B42F CD C1 B5         call    ram_page_in
  55  B432
  56  B432 3E D2            ld      a, low xdpb             ; Set pointer to point to our XDPB
  57  B434 77               ld      (hl), a
  58  B435 23               inc     hl
  59  B436 3E B4            ld      a, high xdpb
  60  B438 77               ld      (hl), a
  61  B439 2B               dec     hl
  62  B43A
  63  B43A CD CE B5         call    ram_page_out
  64  B43D FB               ei
  65  B43E
  66  B43E DD 21 D2 B4      ld      ix, xdpb
  67  B442 3A 07 B4         ld      a, (disk_type)          ; 0 = Standard +3 format disk
  68  B445 21 84 B4         ld      hl, exit
  69  B448 E5               push    hl
  70  B449 21 78 01         ld      hl, dd_sel_format
  71  B44C E5               push    hl
  72  B44D C3 9D B5         jp      dos_tos
  73  B450
  74  B450              login:
  75  B450 C3 77 B4         jp      cmd_success
  76  B453
  77  B453              ;    B = Page for C000h (49152)...FFFFh (65535)
  78  B453              ;    C = Unit (0/1)
  79  B453              ;    D = Logical track, 0 base
  80  B453              ;    E = Logical sector, 0 base
  81  B453              ;   HL = Address of buffer
  82  B453              ;   IX = Address of XDPB
  83  B453              read:
  84  B453 3E 05            ld   a, 5
  85  B455 32 F3 B5         ld   (ddl_parms+$06), a             ; Read command
  86  B458 CD 64 B4         call prepFloppyCmd
  87  B45B CD 25 BB         call loadSector
  88  B45E 20 1D            jr   nz, cmd_fail
  89  B460 18 15            jr   cmd_success
  90  B462
  91  B462              write:
  92  B462 18 19            jr   cmd_fail
  93  B464
  94  B464              prepFloppyCmd:
  95  B464 E5               push hl
  96  B465 D5               push de
  97  B466 C5               push bc
  98  B467 CD 02 B5         call buildFloppyCmd                 ; Build command to ddl_parms
  99  B46A C1               pop  bc
 100  B46B D1               pop  de
 101  B46C E1               pop  hl
 102  B46D CD 9E B4         call floppyCmdToString              ; Convert to hex string
 103  B470
 104  B470 2A EE B5         ld   hl, (ddl_parms+1)              ; buffer address for sector read/write
 105  B473 22 BD BB         ld   (data_pointer), hl
 106  B476 C9               ret
 107  B477
 108  B477              cmd_success:
 109  B477 CD 93 B4         call restoreBorder
 110  B47A AF               xor  a
 111  B47B 37               scf                                 ; Signal success
 112  B47C C9               ret
 113  B47D
 114  B47D              cmd_fail:
 115  B47D CD 93 B4         call restoreBorder
 116  B480 AF               xor  a
 117  B481 3E 02            ld   a, 2                           ; Seek fail
 118  B483 C9               ret
 119  B484
 120  B484              exit:
 121  B484 F3               di
 122  B485 ED 7B 46 B6      ld      sp, (old_sp)
 123  B489 D9               exx
 124  B48A 2A 06 B6         ld      hl, (temp_hl)
 125  B48D D9               exx
 126  B48E
 127  B48E CD 93 B4         call    restoreBorder
 128  B491
 129  B491 FB               ei
 130  B492 C9               ret
 131  B493
 132  B493              restoreBorder:
 133  B493 3A 48 5C         ld      a, (bordcr)                 ; Restore border colour
 134  B496 E6 38            and     $38
 135  B498 0F               rrca
 136  B499 0F               rrca
 137  B49A 0F               rrca
 138  B49B D3 FE            out     (-2), a
 139  B49D C9               ret
 140  B49E
 141  B49E              floppyCmdToString:
 142  B49E 21 F3 B5         ld   hl, ddl_parms+6
 143  B4A1 01 09 00         ld   bc, 0x09
 144  B4A4 11 C5 BB         ld   de, d_path
 145  B4A7 CD AD B4         call bytesToHex
 146  B4AA AF               xor  a                              ; Null terminate string
 147  B4AB 77               ld   (hl), a
 148  B4AC C9               ret
 149  B4AD
 150  B4AD              bytesToHex:
 151  B4AD 7E           1:  ld   a, (hl)
 152  B4AE C5               push bc
 153  B4AF CD BE B4         call hexToBuf
 154  B4B2 C1               pop  bc
 155  B4B3 23               inc  hl
 156  B4B4 0B               dec  bc
 157  B4B5 78               ld   a, b
 158  B4B6 B1               or   c
 159  B4B7 C8               ret  z
 160  B4B8 3E 20            ld   a, ' '
 161  B4BA 12               ld   (de), a
 162  B4BB 13               inc  de
 163  B4BC 18 EF            jr   1B
 164  B4BE
 165  B4BE              ; Entry:
 166  B4BE              ;   A = Hex value
 167  B4BE              ;  DE = Output buffer
 168  B4BE              hexToBuf:
 169  B4BE 4F               ld   c, a
 170  B4BF 1F               rra
 171  B4C0 1F               rra
 172  B4C1 1F               rra
 173  B4C2 1F               rra
 174  B4C3 CD C7 B4         call 1f
 175  B4C6 79               ld   a, c
 176  B4C7 E6 0F        1:  and  0x0f
 177  B4C9 C6 90            add  a, 0x90
 178  B4CB 27               daa
 179  B4CC CE 40            adc  a, 0x40
 180  B4CE 27               daa
 181  B4CF 12               ld   (de), a
 182  B4D0 13               inc  de
 183  B4D1 C9               ret
 184  B4D2
 185  B4D2              xdpb:
 186  B4D2 00 00 00...      defs $1b, 0
 187  B4ED
 188  B4ED              .l17f6
 189  B4ED 04 4E 00         defb    $04,'N',$00         ; flags,drive,unit
 190  B4F0 00 00 00 00      defb    $00,$00,$00,$00     ; last access,filesopen
 191  B4F4 00 00 00 00      defw    $0000,$0000         ; #free direntries,last used
 192  B4F8 09 B6 19 B6      defw    chksm_a,alloc_a     ; checksum vector,alloc bitmap
 193  B4FC 50 B4            defw    login               ; login disk
 194  B4FE 53 B4            defw    read                ; read sector
 195  B500 62 B4            defw    write               ; write sector
 196  B502
 197  B502              ; Convert logical track / sector to physical
 198  B502              ; Entry:
 199  B502              ;   DE = Logical Track / Sector
 200  B502              ;    C = Unit
 201  B502
 202  B502              buildFloppyCmd:
 203  B502 CD 2D B5         call    l1b9c                   ; setup basic parameter block data
 204  B505 7B               ld      a,e
 205  B506 DD 86 14         add     a,(ix+$14)
 206  B509 5F               ld      e,a                     ; E=physical sector number
 207  B50A D5               push    de                      ; save physical track & sector numbers
 208  B50B 7B               ld      a,e
 209  B50C 32 F7 B5         ld      (ddl_parms+$0a),a       ; store 1st sector ID
 210  B50F DD 6E 0F         ld      l,(ix+$0f)
 211  B512 63               ld      h,e
 212  B513 22 F8 B5         ld      (ddl_parms+$0b),hl      ; store sector size & last(=1st) sector ID
 213  B516 DD 7E 17         ld      a,(ix+$17)
 214  B519 32 FA B5         ld      (ddl_parms+$0d),a       ; store gap length
 215  B51C 60               ld      h,b
 216  B51D 6A               ld      l,d
 217  B51E 22 F5 B5         ld      (ddl_parms+8),hl        ; store track & side numbers
 218  B521 3E 09            ld      a,$09
 219  B523 32 F2 B5         ld      (ddl_parms+5),a         ; store # command bytes
 220  B526 21 FB B5         ld      hl,ddl_parms+$0e
 221  B529 36 FF            ld      (hl),$ff                ; store dummy data length
 222  B52B D1               pop     de
 223  B52C C9               ret
 224  B52D
 225  B52D              ; Subroutine to setup some of the parameter block for sector read/writes
 226  B52D              ; (except # command bytes & additional command bytes)
 227  B52D
 228  B52D              l1b9c
 229  B52D 22 EE B5         ld      (ddl_parms+1),hl        ; store buffer address
 230  B530 6F               ld      l,a                     ; Floppy command
 231  B531 78               ld      a,b                     ; Page
 232  B532 32 ED B5         ld      (ddl_parms),a           ; store buffer page
 233  B535 CD 46 B5         call    l1bb5                   ; C=physical side & unit byte
 234  B538 61               ld      h,c
 235  B539 22 F3 B5         ld      (ddl_parms+6),hl        ; store command & unit byte
 236  B53C DD 6E 15         ld      l,(ix+$15)
 237  B53F DD 66 16         ld      h,(ix+$16)
 238  B542 22 F0 B5         ld      (ddl_parms+3),hl        ; store sector size as # bytes to transfer
 239  B545 C9               ret
 240  B546
 241  B546              ; Subroutine to return physical side (B) and track (D) given logical track (D)
 242  B546              ; Physical side is also ORed with unit number in C
 243  B546
 244  B546              l1bb5
 245  B546 DD 7E 11         ld      a,(ix+$11)
 246  B549 E6 7F            and     $7f                     ; A=sidedness
 247  B54B 06 00            ld      b,$00                   ; side 0
 248  B54D C8               ret     z                       ; exit if single-sided (physical=logical)
 249  B54E
 250  B54E 3D               dec     a
 251  B54F 20 08            jr      nz,l1bc8                ; move on if double-sided: successive sides
 252  B551
 253  B551 7A               ld      a,d
 254  B552 1F               rra                             ; for alternate sides, halve track
 255  B553 57               ld      d,a
 256  B554 78               ld      a,b
 257  B555 17               rla                             ; with side=remainder
 258  B556 47               ld      b,a
 259  B557 18 0C            jr      l1bd4                   ; move on to OR into unit number
 260  B559
 261  B559              l1bc8
 262  B559 7A               ld      a,d
 263  B55A DD 96 12         sub     (ix+$12)                ; subtract # tracks
 264  B55D 38 06            jr      c,l1bd4                 ; if < # tracks, physical=logical so move on
 265  B55F DD 96 12         sub     (ix+$12)                ; on successive side, tracks count back down
 266  B562 2F               cpl
 267  B563 57               ld      d,a
 268  B564 04               inc     b                       ; and use side 1
 269  B565
 270  B565              l1bd4
 271  B565 78               ld      a,b                     ; A = side (0 or 1)
 272  B566 87               add     a,a                     ; A*= 2
 273  B567 87               add     a,a
 274  B568 B1               or      c                       ; OR in unit number
 275  B569 4F               ld      c,a                     ; update unit number with side bit as bit 1
 276  B56A C9               ret
 277  B56B
 278  B56B              ; ----------------------------------------------------------------------------
 279  B56B              ; Get the address of the pointer to an XDPB for a given drive letter
 280  B56B              ; ----------------------------------------------------------------------------
 281  B56B              ; Entry:
 282  B56B              ;   A = Drive letter, 'A'...'P'
 283  B56B              ; Exit
 284  B56B              ;   HL = Address in page 7 of pointer, or 0 if error
 285  B56B              ; ----------------------------------------------------------------------------
 286  B56B              getXDPBPtr:
 287  B56B F5               push    af
 288  B56C 3E 07            ld      a, 7
 289  B56E CD C1 B5         call    ram_page_in
 290  B571 F1               pop     af
 291  B572 CD 79 B5         call    .getPtr
 292  B575 CD CE B5         call    ram_page_out
 293  B578 C9               ret
 294  B579
 295  B579              .getPtr
 296  B579 21 A0 E2         ld      hl,xdpb_ptrs
 297  B57C D6 41            sub     'A'
 298  B57E 38 0D            jr      c, .error         ; error if <A
 299  B580 FE 10            cp      $10
 300  B582 30 09            jr      nc, .error        ; error if >P
 301  B584 87               add     a,a
 302  B585 C6 A0            add     a, low xdpb_ptrs
 303  B587 6F               ld      l,a
 304  B588 CE E2            adc     a, high xdpb_ptrs
 305  B58A 95               sub     l
 306  B58B 67               ld      h, a             ; HL=xdpb_ptrs+2*drive
 307  B58C C9               ret
 308  B58D              .error:
 309  B58D 21 00 00         ld      hl, 0
 310  B590 C9               ret
 311  B591
 312  B591              ; Entry
 313  B591              ;   IX = +3dos routine to call
 314  B591              dos_ix:
 315  B591 F3               di
 316  B592 CD AD B5         call dos_in
 317  B595 CD D7 B5         call call_ix                        ; Call routine in IX
 318  B598 CD D9 B5         call dos_out
 319  B59B FB               ei
 320  B59C C9               ret
 321  B59D
 322  B59D              dos_tos:
 323  B59D CD AD B5         call dos_in
 324  B5A0 D9               exx                  ; preserve parameters
 325  B5A1 E1               pop  hl               ; address of the DOS routine
 326  B5A2 11 A9 B5         ld   de,dos_tos_return ; return address from the DOS routine
 327  B5A5 D5               push de              ; force the return later
 328  B5A6 E5               push hl              ; address of the DOS routine
 329  B5A7 D9               exx                  ; restore parameters
 330  B5A8 C9               ret                  ; call routine in TOS, then continue at dos.ix.return
 331  B5A9
 332  B5A9              dos_tos_return:
 333  B5A9 CD D9 B5         call dos_out
 334  B5AC C9               ret
 335  B5AD
 336  B5AD              ; ----------------------------------------------------------------------------
 337  B5AD              ; Page in +3dos
 338  B5AD              ; ----------------------------------------------------------------------------
 339  B5AD              dos_in:
 340  B5AD F5               push af
 341  B5AE C5               push bc              ; temp save registers while switching
 342  B5AF 01 FD 7F         ld   bc,bank1        ; port used for horiz. ROM switch and RAM paging
 343  B5B2 3A 5C 5B         ld   a,(bankm)       ; RAM/ROM switching system variable
 344  B5B5 CB A7            res  4,a             ; and DOS ROM
 345  B5B7 F6 07            or   7               ; set bits 0-3: RAM 7
 346  B5B9 32 5C 5B         ld   (bankm),a       ; keep system variables up to date
 347  B5BC ED 79            out  (c),a           ; RAM page 7 to top and DOS ROM
 348  B5BE C1               pop  bc
 349  B5BF F1               pop  af
 350  B5C0 C9               ret
 351  B5C1
 352  B5C1              ; A = RAM page
 353  B5C1              ram_page_in:
 354  B5C1 5F               ld      e, a
 355  B5C2 01 FD 7F         ld      bc, $7ffd
 356  B5C5 3A 5C 5B         ld      a, (bankm)
 357  B5C8 E6 F8            and     %11111000       ; Lose RAM bits
 358  B5CA B3               or      e               ; Or in RAM page
 359  B5CB ED 79            out     (c), a
 360  B5CD C9               ret
 361  B5CE
 362  B5CE              ram_page_out:
 363  B5CE 01 FD 7F         ld      bc, $7ffd
 364  B5D1 3A 5C 5B         ld      a, (bankm)
 365  B5D4 ED 79            out     (c), a          ; restore memory configuration
 366  B5D6 C9               ret
 367  B5D7
 368  B5D7              call_ix:
 369  B5D7 DD E9            jp   (ix)                           ; Jump to IX and return
 370  B5D9
 371  B5D9              ; ----------------------------------------------------------------------------
 372  B5D9              ; Page out +3DOS
 373  B5D9              ; ----------------------------------------------------------------------------
 374  B5D9              dos_out:
 375  B5D9 F5               push af
 376  B5DA C5               push bc
 377  B5DB 3A 5C 5B         ld   a,(bankm)
 378  B5DE E6 F8            and  %11111000           ; reset bits 0-3: RAM 0
 379  B5E0 CB E7            set  4,a                 ; switch to ROM 3 (48 BASIC)
 380  B5E2 01 FD 7F         ld   bc,bank1
 381  B5E5 32 5C 5B         ld   (bankm),a
 382  B5E8 ED 79            out  (c),a               ; switch back to RAM page 0 and 48 BASIC
 383  B5EA C1               pop  bc
 384  B5EB F1               pop  af
 385  B5EC C9               ret
 386  B5ED
 387  B5ED              ; dosError:
 388  B5ED              ;     ld   (0x4000), a
 389  B5ED              ;     ld   a, 2
 390  B5ED              ;     out  (-2), a
 391  B5ED              ;     ret
 392  B5ED
 393  B5ED              ; Data
 394  B5ED
 395  B5ED              ; Space for floppy emulation command
 396  B5ED              ddl_parms
 397  B5ED 00 00 00...      defs    $6
 398  B5F3
 399  B5F3              dd_cmd
 400  B5F3 00 00 00...      defs    $13
 401  B606
 402  B606              temp_hl:
 403  B606 00 00            defw    0
 404  B608
 405  B608              wifiConnected:
 406  B608 00               defb    0
 407  B609
 408  B609              chksm_a
 409  B609 00 00 00...      defs $10, 0
 410  B619
 411  B619              alloc_a
 412  B619 00 00 00...      defs $2d, 0
 413  B646
 414  B646              old_sp:
 415  B646 00 00            defw 0
 416  B648
 417  B648 00 00 00...      defs 100
 418  B6AC              tmp_stack:
 419  B6AC 00 00            defw 0
 420  B6AE
 421  B6AE                  include "p3dos.asm"
# file opened: p3dos.asm
   1+ B6AE              ; ZX Spectrum +3DOS
   2+ B6AE
   3+ B6AE              ; By Marcos Cruz (programandala.net)
   4+ B6AE
   5+ B6AE              ; Credit:
   6+ B6AE              ;
   7+ B6AE              ; This file is Part 27 of Chapter 8 of the ZX Spectrum +3
   8+ B6AE              ; manual, transcribed by Russell Marks et al. and published in
   9+ B6AE              ; HTML format in <http://worldofspectrum.org>.  I simply
  10+ B6AE              ; converted it to be usable as Z80 source.
  11+ B6AE
  12+ B6AE              ; --------------------------------------------------------------
  13+ B6AE              ; Change history
  14+ B6AE
  15+ B6AE              ; 2015-01-12: Start.
  16+ B6AE              ;
  17+ B6AE              ; 2015-07-13: Add labels for DOS GET 1346 and DOS SET 1346.
  18+ B6AE              ; Fix typos (also in the original HTML document).
  19+ B6AE              ;
  20+ B6AE              ; 2017-02-06: Add all symbols for low-level "DD" entry points.
  21+ B6AE              ; Improve the credit note.
  22+ B6AE
  23+ B6AE              ; --------------------------------------------------------------
  24+ B6AE
  25+ B6AE              ; Part 27
  26+ B6AE              ; Guide to +3DOS
  27+ B6AE              ;
  28+ B6AE              ; Subjects covered...
  29+ B6AE              ;
  30+ B6AE              ;         ROMs
  31+ B6AE              ;         +3DOS interface
  32+ B6AE              ;         File attributes and headers
  33+ B6AE              ;         Disk format and specification
  34+ B6AE              ;         Tracks and sectors
  35+ B6AE              ;         Disk parameter blocks
  36+ B6AE              ;         CP/M file compatibility
  37+ B6AE              ;         Changing disks
  38+ B6AE              ;         Logical to physical drive mapping
  39+ B6AE              ;         +3DOS messages and requirements
  40+ B6AE              ;         +3DOS routines
  41+ B6AE              ;
  42+ B6AE              ;
  43+ B6AE              ; This section describes +3DOS - the disk operating system of the
  44+ B6AE              ; +3. The information will probably be of most interest to people
  45+ B6AE              ; familiar with assembly language (machine code) programming (see part
  46+ B6AE              ; 26 of this chapter for more information on this subject). What follows
  47+ B6AE              ; is highly technical, and should not be used by the uninitiated.
  48+ B6AE              ;
  49+ B6AE              ; The operating software of the +3 is, in effect, held in four ROMs
  50+ B6AE              ; (though the information is actually contained in just two ICs). All
  51+ B6AE              ; four ROMs are addressed between 0000h and 3FFFh, although only one is
  52+ B6AE              ; switched in at a time.
  53+ B6AE              ;
  54+ B6AE              ; ROM 0 is the 'editor' ROM and is the one entered when the +3 is first
  55+ B6AE              ; switched on. This controls the high level 'menuing' and editing
  56+ B6AE              ; functions.
  57+ B6AE              ;
  58+ B6AE              ; ROM 1 is the 'syntax' ROM and handles the high level control of +3
  59+ B6AE              ; BASIC. It contains the code for the BASIC parts of most of the disk
  60+ B6AE              ; based commands.
  61+ B6AE              ;
  62+ B6AE              ; ROM 3 is the '48 BASIC' ROM and is virtually identical to the ROM used
  63+ B6AE              ; in the very first Spectrum. The only real area where it is different
  64+ B6AE              ; is in the code executed when an interrupt occurs. If non-zero, a
  65+ B6AE              ; 'ticker' variable is decremented every second interrupt, and when it
  66+ B6AE              ; reaches zero, the disk motor is switched off. This variable is held in
  67+ B6AE              ; page 7 along with some of the editor and DOS variables. Page 7 will
  68+ B6AE              ; only be switched in (and this variable decremented) if bit 4 in the
  69+ B6AE              ; FLAGS system variable is set - this is used by the software to
  70+ B6AE              ; identify whether it is running 48 BASIC or +3 BASIC. When 48 BASIC is
  71+ B6AE              ; selected (from the main menu or by the SPECTRUM command), this bit is
  72+ B6AE              ; reset so that this page-switching and ticker-decrementing won't
  73+ B6AE              ; happen. However, if bit 4 in the FLAGS system variable is subsequently
  74+ B6AE              ; set by your own program, this process will start again while interrupt
  75+ B6AE              ; mode 1 is still selected.
  76+ B6AE              ;
  77+ B6AE              ; The keypad scanning routines of the Spectrum 128 and +2 have been
  78+ B6AE              ; removed from ROM 3 in the +3.
  79+ B6AE              ;
  80+ B6AE              ; A 'bug' in the original 48 BASIC ROM has been fixed in the +3. When a
  81+ B6AE              ; non-maskable interrupt (NMI) occurs, a jump is made to location
  82+ B6AE              ; 66h. This now checks the contents of the NMIADD system variable. If it
  83+ B6AE              ; is zero, a RETN is executed, otherwise a jump is made to the routine
  84+ B6AE              ; address held in NMIADD. The NMI code in ROM 2 consists of just a RETN.
  85+ B6AE              ;
  86+ B6AE              ; ROM 3 not only provides the 48 BASIC mode for program compatibility,
  87+ B6AE              ; but executes the majority of +3 BASIC commands that don't make use of
  88+ B6AE              ; the more advanced hardware of the +3.
  89+ B6AE              ;
  90+ B6AE              ; The fourth ROM (ROM 2) holds +3DOS - the disk operating system. This
  91+ B6AE              ; is the subject of this section. Unlike the other ROMs, which are
  92+ B6AE              ; unlikely to be of much use for assembler programmers (except the 48
  93+ B6AE              ; BASIC ROM perhaps), the +3DOS ROM has a wealth of routines that may
  94+ B6AE              ; well be of use in your own programs. We strongly recommend that any
  95+ B6AE              ; software that uses the disk drives makes use of these routines as they
  96+ B6AE              ; provide most of the facilities that one could wish for (more than are
  97+ B6AE              ; currently used by BASIC, in fact). Furthermore, the routines should
  98+ B6AE              ; only be accessed via the jump block. This not only makes it easier to
  99+ B6AE              ; write software that can be adapted to and from the AMSTRAD CPC range
 100+ B6AE              ; of computers, but also affords upwards compatibility for the
 101+ B6AE              ; future. The entry points for each routine are held in a jump table at
 102+ B6AE              ; address 0100h (256) in the ROM. Part 26 of this chapter gave a couple
 103+ B6AE              ; of examples of the way in which these routines can be called.
 104+ B6AE              ;
 105+ B6AE              ; +3DOS provides the following facilities:
 106+ B6AE              ;
 107+ B6AE              ;         - Support for one or two floppy disk drives and a RAMdisk.
 108+ B6AE              ;         - CP/M Plus and CP/M 2.2 file compatibility.
 109+ B6AE              ;         - AMSTRAD CPC range and PCW range file and media
 110+ B6AE              ;             compatibility.
 111+ B6AE              ;         - Up to 16 files open at the same time.
 112+ B6AE              ;         - Reading and writing files to or from any page in memory.
 113+ B6AE              ;         - Byte level random access.
 114+ B6AE              ;         - Deleting disk files; renaming disk files; changing disk
 115+ B6AE              ;             files' attributes.
 116+ B6AE              ;         - Selecting the default drive and user.
 117+ B6AE              ;         - Booting a game or operating system.
 118+ B6AE              ;         - Low level access to floppy disk driver.
 119+ B6AE              ;         - Optional mapping of two logical drives (A: or B:) onto one
 120+ B6AE              ;             physical drive (unit 0).
 121+ B6AE              ;
 122+ B6AE              ;
 123+ B6AE              ; +3DOS interface
 124+ B6AE              ;
 125+ B6AE              ; +3DOS's interface is a set of routines accessed via a jump block. The
 126+ B6AE              ; routines provided fall into three categories:
 127+ B6AE              ;
 128+ B6AE              ;         - Essential filing system routines.
 129+ B6AE              ;         - Additional routines for games and operating systems.
 130+ B6AE              ;         - Low level floppy disk access routines for disk formatting,
 131+ B6AE              ;             copying, etc.
 132+ B6AE              ;
 133+ B6AE              ; The following is a list of the routines in each of these categories
 134+ B6AE              ; (together with brief descriptions of the routines' functions):
 135+ B6AE              ;
 136+ B6AE              ;
 137+ B6AE              ; Essential filing system routines
 138+ B6AE              ;
 139+ B6AE              ; NAME OF ROUTINE         FUNCTION
 140+ B6AE              ;
 141+ B6AE              ; DOS INITIALISE          Initialise +3DOS
 142+ B6AE              ; DOS VERSION             Get +3DOS issue and version numbers
 143+ B6AE              ; DOS OPEN                Create and/or open a file
 144+ B6AE              ; DOS CLOSE               Close a file
 145+ B6AE              ; DOS ABANDON             Abandon a file
 146+ B6AE              ; DOS REF HEAD            Point at the header data for this file
 147+ B6AE              ; DOS READ                Read bytes into memory
 148+ B6AE              ; DOS WRITE               Write bytes from memory
 149+ B6AE              ; DOS BYTE READ           Read a byte
 150+ B6AE              ; DOS BYTE WRITE          Write a byte
 151+ B6AE              ; DOS CATALOG             Catalog disk directory
 152+ B6AE              ; DOS FREE SPACE          Free space on disk
 153+ B6AE              ; DOS DELETE              Delete a file
 154+ B6AE              ; DOS RENAME              Rename a file
 155+ B6AE              ; DOS BOOT                Boot an operating system or other program
 156+ B6AE              ; DOS SET DRIVE           Set/get default drive
 157+ B6AE              ; DOS SET USER            Set/get default user number
 158+ B6AE              ;
 159+ B6AE              ;
 160+ B6AE              ; Additional routines for games and operating systems
 161+ B6AE              ;
 162+ B6AE              ; NAME OF ROUTINE         FUNCTION
 163+ B6AE              ;
 164+ B6AE              ; DOS GET POSITION        Get file pointer for random access
 165+ B6AE              ; DOS SET POSITION        Set file pointer for random access
 166+ B6AE              ; DOS GET EOF             Get end of file position for random access
 167+ B6AE              ; DOS GET 1346            Get memory usage in pages 1, 3, 4, 6
 168+ B6AE              ; DOS SET 1346            Re-allocate memory usage in pages 1, 3, 4, 6
 169+ B6AE              ; DOS FLUSH               Bring disk up to date
 170+ B6AE              ; DOS SET ACCESS          Change open file's access mode
 171+ B6AE              ; DOS SET ATTRIBUTES      Change a file's attributes
 172+ B6AE              ; DOS OPEN DRIVE          Open a drive as a single file
 173+ B6AE              ; DOS SET MESSAGE         Enable/disable error messages
 174+ B6AE              ; DOS REF XDPB            Point at XDPB for low level disk access
 175+ B6AE              ; DOS MAP B               Map B: onto unit 0 or 1
 176+ B6AE              ;
 177+ B6AE              ;
 178+ B6AE              ; Low level floppy disk driving routines
 179+ B6AE              ;
 180+ B6AE              ; NAME OF ROUTINE         FUNCTION
 181+ B6AE              ;
 182+ B6AE              ; DD INTERFACE            Is the floppy disk driver interface present?
 183+ B6AE              ; DD INIT                 Initialise disk driver
 184+ B6AE              ; DD SETUP                Specify drive parameters
 185+ B6AE              ; DD SET RETRY            Set try/retry count
 186+ B6AE              ; DD READ SECTOR          Read a sector
 187+ B6AE              ; DD WRITE SECTOR         Write a sector
 188+ B6AE              ; DD CHECK SECTOR         Check a sector
 189+ B6AE              ; DD FORMAT               Format a track
 190+ B6AE              ; DD READ ID              Read a sector identifier
 191+ B6AE              ; DD TEST UNSUITABLE      Test media suitability
 192+ B6AE              ; DD LOGIN                Log in disk, initialise XDPB
 193+ B6AE              ; DD SEL FORMAT           Pre-initialise XDPB for DD FORMAT
 194+ B6AE              ; DD ASK 1                Is unit 1 (external drive) present?
 195+ B6AE              ; DD DRIVE STATUS         Fetch drive status
 196+ B6AE              ; DD EQUIPMENT            What type of drive?
 197+ B6AE              ; DD ENCODE               Set intercept routine for copy protection
 198+ B6AE              ; DD L XDPB               Initialise an XDPB from a disk specification
 199+ B6AE              ; DD L DPB                Initialise a DPB from a disk specification
 200+ B6AE              ; DD L SEEK               uPD765A seek driver
 201+ B6AE              ; DD L READ               uPD765A read driver
 202+ B6AE              ; DD L WRITE              uPD765A write driver
 203+ B6AE              ; DD L ON MOTOR           Motor on, wait for motor-on time
 204+ B6AE              ; DD L T OFF MOTOR        Start the motor-off ticker
 205+ B6AE              ; DD L OFF MOTOR          Turn the motor off
 206+ B6AE              ;
 207+ B6AE              ;
 208+ B6AE              ; Games and other non-BASIC programs
 209+ B6AE              ;
 210+ B6AE              ; +3DOS provides facilities specifically for non-BASIC programs:
 211+ B6AE              ;
 212+ B6AE              ; - Use DOS BOOT to load a single bootstrap sector, then take over the
 213+ B6AE              ; whole machine (see the second example in part 26 of this chapter).
 214+ B6AE              ;
 215+ B6AE              ; - Claim some store from +3DOS using DOS SET 1346. This enables a
 216+ B6AE              ; non-BASIC program to take control of the machine but still use the
 217+ B6AE              ; facilities of +3DOS if required. If +3DOS is not required, then the
 218+ B6AE              ; non-BASIC program should call DD L OFF MOTOR to force the drive motor
 219+ B6AE              ; off and disable the motor ticker. Bit 4 in the FLAGS system variable
 220+ B6AE              ; should be reset to prevent any back switching/variable decrementing on
 221+ B6AE              ; interrupt.
 222+ B6AE              ;
 223+ B6AE              ; - A drive can be opened as a single file. This enables files and
 224+ B6AE              ; directories to be examined without going via the file structure.
 225+ B6AE              ;
 226+ B6AE              ;
 227+ B6AE              ; Using +3DOS without a floppy disk interface
 228+ B6AE              ;
 229+ B6AE              ; [This is the case on a +2A.]
 230+ B6AE              ;
 231+ B6AE              ; Even if the floppy disk interface were not present, +3DOS could still
 232+ B6AE              ; be used as follows:
 233+ B6AE              ;
 234+ B6AE              ;         - Only drive M: is available (the RAMdisk).
 235+ B6AE              ;         - The default drive for filenames is initialised to M: rather
 236+ B6AE              ;             than A:.
 237+ B6AE              ;         - Any attempt to use drives A: or B: will fail with error '22
 238+ B6AE              ;             - Drive not found'.
 239+ B6AE              ;         - As the sector cache is not required for use with the
 240+ B6AE              ;             RAMdisk, is increased to 64K (the whole of pages 1, 3, 4,
 241+ B6AE              ;             6). This will give 62K of data and 2K of directory (64
 242+ B6AE              ;             entries).
 243+ B6AE              ;         - The presence of the floppy disk interface can be determined
 244+ B6AE              ;             by calling DD INTERFACE. If the interface were not
 245+ B6AE              ;             present, then none of the other low level floppy disk
 246+ B6AE              ;             routines (DD... etc.) could be called; the effect of doing
 247+ B6AE              ;             so is undefined.
 248+ B6AE              ;
 249+ B6AE              ;
 250+ B6AE              ; File attributes
 251+ B6AE              ;
 252+ B6AE              ; Bit 7 of the name and type field characters are the file
 253+ B6AE              ; attributes. The top bits of the name field characters are denoted
 254+ B6AE              ; f1...f8. The top bits of the type field characters are denoted
 255+ B6AE              ; t1...t3. They have the following meanings:
 256+ B6AE              ;
 257+ B6AE              ;         f1...f4 - Available to the user
 258+ B6AE              ;         f5...f8 - Reserved (always 0)
 259+ B6AE              ;              t1 - 0 means file is read-write; 1 means file is
 260+ B6AE              ;                     read-only
 261+ B6AE              ;              t2 - 0 means not system file; 1 means system file
 262+ B6AE              ;              t3 - 0 means not archived; 1 means archived
 263+ B6AE              ;
 264+ B6AE              ; A read-only file cannot be written to, erased or renamed. System files
 265+ B6AE              ; can, optionally, be omitted from the directory catalog. The archive
 266+ B6AE              ; attribute is ignored by +3DOS.
 267+ B6AE              ;
 268+ B6AE              ; Newly created files have all attributes set to 0. An existing file's
 269+ B6AE              ; attributes can only be changed by DOS SET ATTRIBUTES (as used by
 270+ B6AE              ; BASIC's MOVE command).
 271+ B6AE              ;
 272+ B6AE              ;
 273+ B6AE              ; File headers
 274+ B6AE              ;
 275+ B6AE              ; Tape files have headers which contain some system information. +3DOS
 276+ B6AE              ; files may, or may not, have headers. All files created by BASIC's SAVE
 277+ B6AE              ; command will have headers.
 278+ B6AE              ;
 279+ B6AE              ; The +3DOS header mechanism provides a dedicated 8 byte area in each
 280+ B6AE              ; headed file reserved for BASIC's use. The remainder of the header is
 281+ B6AE              ; reserved for +3DOS. This 8 byte header is utilised in files created by
 282+ B6AE              ; BASIC commands (see DOS OPEN description).
 283+ B6AE              ;
 284+ B6AE              ; +3DOS files may have a single header in the first 128 bytes of the
 285+ B6AE              ; file - the header record. These headers are detected by a 'signature'
 286+ B6AE              ; and checksum. If the signature and checksum are as expected, then a
 287+ B6AE              ; header is present; if not, these is no header. Thus, it is possible,
 288+ B6AE              ; but unlikely, that a file without a header could be mistaken for one
 289+ B6AE              ; with a header.
 290+ B6AE              ;
 291+ B6AE              ; The format of the header record is as follows:
 292+ B6AE              ;
 293+ B6AE              ;         Bytes 0...7     - +3DOS signature - 'PLUS3DOS'
 294+ B6AE              ;         Byte 8          - 1Ah (26) Soft-EOF (end of file)
 295+ B6AE              ;         Byte 9          - Issue number
 296+ B6AE              ;         Byte 10         - Version number
 297+ B6AE              ;         Bytes 11...14   - Length of the file in bytes, 32 bit number,
 298+ B6AE              ;                             least significant byte in lowest address
 299+ B6AE              ;         Bytes 15...22   - +3 BASIC header data
 300+ B6AE              ;         Bytes 23...126  - Reserved (set to 0)
 301+ B6AE              ;         Byte 127        - Checksum (sum of bytes 0...126 modulo 256)
 302+ B6AE              ;
 303+ B6AE              ; The issue and version numbers are provided for any future
 304+ B6AE              ; expansion. The issue number must equal the software's issue number;
 305+ B6AE              ; the version number must be less than or equal to the software's
 306+ B6AE              ; version number.
 307+ B6AE              ;
 308+ B6AE              ; +3DOS performs all the necessary header 'house-keeping'. A pointer to
 309+ B6AE              ; +3 BASIC's 8 byte header area may be returned using DOS REF HEAD. It
 310+ B6AE              ; is never necessary to write directly to the 128 byte header.
 311+ B6AE              ;
 312+ B6AE              ; AMSDOS headers (as used on the AMSTRAD CPC range of computers) will
 313+ B6AE              ; not be recognised. AMSDOS files will be treated by +3DOS as
 314+ B6AE              ; headerless, and vice versa.
 315+ B6AE              ;
 316+ B6AE              ;
 317+ B6AE              ; Disk formats
 318+ B6AE              ;
 319+ B6AE              ; +3DOS supports exactly the same disk format as CP/M Plus and
 320+ B6AE              ; LocoScript on the AMSTRAD PCW range of computer/word processors
 321+ B6AE              ; (i.e. the first format listed below).
 322+ B6AE              ;
 323+ B6AE              ; The following formats are automatically detected when the disk is
 324+ B6AE              ; first accessed:
 325+ B6AE              ;
 326+ B6AE              ;         - AMSTRAD PCW range single track (e.g. as used on model
 327+ B6AE              ;             PCW8256)
 328+ B6AE              ;         - AMSTRAD PCW range double track (e.g. as used on model
 329+ B6AE              ;             PCW8512)
 330+ B6AE              ;         - AMSTRAD CPC range system format
 331+ B6AE              ;         - AMSTRAD CPC range vendor format
 332+ B6AE              ;         - AMSTRAD CPC range data only format
 333+ B6AE              ;
 334+ B6AE              ; Note that the AMSTRAD CPC range's IBM format is not supported.
 335+ B6AE              ;
 336+ B6AE              ; Other disk formats can be used by patching the XDPB for a drive. The
 337+ B6AE              ; XDPB is the same as for the first format listed above; it is not the
 338+ B6AE              ; same as on the CPC range.
 339+ B6AE              ;
 340+ B6AE              ; Disk formats are subject to the following restrictions:
 341+ B6AE              ;
 342+ B6AE              ;         - 512 byte sector size
 343+ B6AE              ;         - Maximum of 255 sectors per track
 344+ B6AE              ;         - Maximum of 255 tracks
 345+ B6AE              ;         - Maximum of 256 directory entries
 346+ B6AE              ;         - Maximum of 360 allocation units
 347+ B6AE              ;
 348+ B6AE              ;
 349+ B6AE              ; Logical tracks and sectors
 350+ B6AE              ;
 351+ B6AE              ; The disk driver routines require 'logical' tracks and sectors. These
 352+ B6AE              ; are used to hide information concerning the number of sides and the
 353+ B6AE              ; actual sector numbers from +3DOS, which knows nothing about them.
 354+ B6AE              ;
 355+ B6AE              ; Logical track numbers on a single sided disk are the same as physical
 356+ B6AE              ; track numbers.
 357+ B6AE              ;
 358+ B6AE              ; For double sided disks, two options are available:
 359+ B6AE              ;
 360+ B6AE              ; 1. Alternating sides...
 361+ B6AE              ;
 362+ B6AE              ;         side 0 track 0 = logical track 0
 363+ B6AE              ;         side 1 track 0 = logical track 1
 364+ B6AE              ;         side 0 track 1 = logical track 2
 365+ B6AE              ;         side 1 track 1 = logical track 3
 366+ B6AE              ;         ...to...
 367+ B6AE              ;         side 0 last track = logical track n-1
 368+ B6AE              ;         side 1 last track = logical track n
 369+ B6AE              ;
 370+ B6AE              ; 2. Successive sides...
 371+ B6AE              ;
 372+ B6AE              ;         side 0 track 0 = logical track 0
 373+ B6AE              ;         side 0 track 1 = logical track 1
 374+ B6AE              ;         side 0 track 2 = logical track 2
 375+ B6AE              ;         ...to...
 376+ B6AE              ;         side 0 last track = logical track n/2-1
 377+ B6AE              ;         ...and then...
 378+ B6AE              ;         side 1 last track-1 = logical track n/2
 379+ B6AE              ;         side 1 last track-2 = logical track n/2+1
 380+ B6AE              ;         side 1 last track-3 = logical track n/2+2
 381+ B6AE              ;         ...to...
 382+ B6AE              ;         side 1 track 0 = logical track n
 383+ B6AE              ;
 384+ B6AE              ; ...where n is the total number of logical tracks (i.e. 2 x number of
 385+ B6AE              ; tracks per side).
 386+ B6AE              ;
 387+ B6AE              ; Logical sectors hide the actual physical sector numbers. Logical
 388+ B6AE              ; sector numbers always start from 0.
 389+ B6AE              ;
 390+ B6AE              ;         Logical sector = physical sector - first sector
 391+ B6AE              ;
 392+ B6AE              ;
 393+ B6AE              ; Disk specification
 394+ B6AE              ;
 395+ B6AE              ; The PCW range disk format (used by the +3) is, in fact, a family of
 396+ B6AE              ; formats the precise member of which is defined in the 'disk
 397+ B6AE              ; specification' which is recorded on bytes 0...15 of sector 1, track 0
 398+ B6AE              ; side 0. The format used on the +3 is the same as disk type 0
 399+ B6AE              ; below. The sector holding this specification is also that used for a
 400+ B6AE              ; bootstrap program. An example of how it may be set up is shown in the
 401+ B6AE              ; second example in part 26 of this chapter.
 402+ B6AE              ;
 403+ B6AE              ; Byte 0          Disk type
 404+ B6AE              ;                         0 = Standard PCW range DD SS ST (and +3)
 405+ B6AE              ;                         1 = Standard CPC range DD SS ST system format
 406+ B6AE              ;                         2 = Standard CPC range DD SS ST data only format
 407+ B6AE              ;                         3 = Standard PCW range DD DS DT
 408+ B6AE              ;                         All other values reserved
 409+ B6AE              ;
 410+ B6AE              ; Byte 1          Bits 0...1 Sidedness
 411+ B6AE              ;                         0 = Single sided
 412+ B6AE              ;                         1 = Double sided (alternating sides)
 413+ B6AE              ;                         2 = Double sided (successive sides)
 414+ B6AE              ;                 Bits 2...6 Reserved (set to 0)
 415+ B6AE              ;                 Bit 7 Double track
 416+ B6AE              ;
 417+ B6AE              ; Byte 2          Number of tracks per side
 418+ B6AE              ;
 419+ B6AE              ; Byte 3          Number of sectors per track
 420+ B6AE              ;
 421+ B6AE              ; Byte 4          Log2(sector size) - 7
 422+ B6AE              ;
 423+ B6AE              ; Byte 5          Number of reserved tracks
 424+ B6AE              ;
 425+ B6AE              ; Byte 6          Log2(block size / 128)
 426+ B6AE              ;
 427+ B6AE              ; Byte 7          Number of directory blocks
 428+ B6AE              ;
 429+ B6AE              ; Byte 8          Gap length (read/write)
 430+ B6AE              ;
 431+ B6AE              ; Byte 9          Gap length (format)
 432+ B6AE              ;
 433+ B6AE              ; Bytes 10...14   Reserved
 434+ B6AE              ;
 435+ B6AE              ; Byte 15         Checksum (used only if disk is bootable)
 436+ B6AE              ;
 437+ B6AE              ;
 438+ B6AE              ; When a disk is logged on, the disk specification is used to initialise
 439+ B6AE              ; the relevant XDPB.
 440+ B6AE              ;
 441+ B6AE              ;
 442+ B6AE              ; Extended disk parameter blocks (XDPB)
 443+ B6AE              ;
 444+ B6AE              ; Associated with each (logical) drive is an extended disk parameter
 445+ B6AE              ; block (XDPB). This contains a standard DPB which is the same as that
 446+ B6AE              ; used by CP/M Plus. It also contains information required by +3DOS to
 447+ B6AE              ; support the different formats. It may be patched in order to use
 448+ B6AE              ; differently formatted disks (provided that the restrictions detailed
 449+ B6AE              ; in the previous table are obeyed).
 450+ B6AE              ;
 451+ B6AE              ; XDPB structure:
 452+ B6AE              ;
 453+ B6AE              ; Bytes 0...1     SPT records per track
 454+ B6AE              ; Byte 2          BSH log2(block size / 128)
 455+ B6AE              ; Byte 3          BLM block size / 128 - 1
 456+ B6AE              ; Byte 4          EXM extent mask
 457+ B6AE              ; Bytes 5...6     DSM last block number
 458+ B6AE              ; Bytes 7...8     DRM last directory entry number
 459+ B6AE              ; Byte 9          AL0 directory bit map
 460+ B6AE              ; Byte 10         AL1 directory bit map
 461+ B6AE              ; Bytes 11...12   CKS size of checksum vector (bit 15 = permanent)
 462+ B6AE              ; Bytes 13...14   OFF number of reserved tracks
 463+ B6AE              ; Byte 15         PSH log2(sector size / 128)
 464+ B6AE              ; Byte 16         PHM sector size / 128 - 1
 465+ B6AE              ; Byte 17         Bits 0...1 Sidedness
 466+ B6AE              ;                         0 = Single sided
 467+ B6AE              ;                         1 = Double sided (alternating sides)
 468+ B6AE              ;                         2 = Double sided (successive sides)
 469+ B6AE              ;                 Bits 2...6 Reserved (set to 0)
 470+ B6AE              ;                 Bit 7 Double track
 471+ B6AE              ; Byte 18         Number of tracks per side
 472+ B6AE              ; Byte 19         Number of sectors per track
 473+ B6AE              ; Byte 20         First sector number
 474+ B6AE              ; Bytes 21...22   Sector size
 475+ B6AE              ; Byte 23         Gap length (read/write)
 476+ B6AE              ; Byte 24         Gap length (format)
 477+ B6AE              ; Byte 25         Bit 7 Multi-track operation
 478+ B6AE              ;                         1 = multi-track
 479+ B6AE              ;                         0 = single track
 480+ B6AE              ;                 Bit 6 Modulation mode
 481+ B6AE              ;                         1 = MFM mode
 482+ B6AE              ;                         0 = FM mode
 483+ B6AE              ;                 Bit 5 Skip deleted data address mark
 484+ B6AE              ;                         1 = skip deleted data address mark
 485+ B6AE              ;                         0 = don't skip deleted address mark
 486+ B6AE              ;                 Bits 0...4 = 0
 487+ B6AE              ; Byte 26         Freeze flag
 488+ B6AE              ;                         00h (0) = auto-detect disk format
 489+ B6AE              ;                         FFh (255) = don't auto-detect disk format
 490+ B6AE              ;
 491+ B6AE              ; Byte 25 is normally set to 60h (96). Multi-track operation is not
 492+ B6AE              ; recommended.
 493+ B6AE              ;
 494+ B6AE              ; Setting the freeze flag (byte 26) prevents +3DOS from trying to
 495+ B6AE              ; determine the format of a disk. This should be used when patching an
 496+ B6AE              ; XDPB for a non-standard format.
 497+ B6AE              ;
 498+ B6AE              ; The XDPBs for the three main formats are as follows:
 499+ B6AE              ;
 500+ B6AE              ; AMSTRAD PCW range single track format (type 0)
 501+ B6AE              ; (As used by the +3)
 502+ B6AE              ;
 503+ B6AE              ; 36              SPT, records per track
 504+ B6AE              ; 3               BSH, block shift
 505+ B6AE              ; 7               BLM, block mask
 506+ B6AE              ; 0               EXM, extent mask
 507+ B6AE              ; 174             DSM, number of blocks - 1
 508+ B6AE              ; 63              DRM, number of directory entries - 1
 509+ B6AE              ; C0h (192)       AL0, 2 directory blocks
 510+ B6AE              ; 00h (0)         AL1
 511+ B6AE              ; 16              CKS, size of checksum vector
 512+ B6AE              ; 1               OFF, reserved tracks
 513+ B6AE              ; 2               PSH, physical sector shift
 514+ B6AE              ; 3               PHM, physical sector mask
 515+ B6AE              ;
 516+ B6AE              ; 0               Single sided
 517+ B6AE              ; 40              Tracks per side
 518+ B6AE              ; 9               Sectors per track
 519+ B6AE              ; 1               First sector number
 520+ B6AE              ; 512             Sector size
 521+ B6AE              ; 42              Gap length (read/write)
 522+ B6AE              ; 82              Gap length (format)
 523+ B6AE              ; 60h (96)        MFM mode, skip deleted data address mark
 524+ B6AE              ; 0               Do auto select format
 525+ B6AE              ;
 526+ B6AE              ;
 527+ B6AE              ; AMSTRAD CPC range SYSTEM format (type 1)
 528+ B6AE              ;
 529+ B6AE              ; 36              SPT, records per track
 530+ B6AE              ; 3               BSH, block shift
 531+ B6AE              ; 7               BLM, block mask
 532+ B6AE              ; 0               EXM, extent mask
 533+ B6AE              ; 170             DSM, number of blocks - 1
 534+ B6AE              ; 63              DRM, number of directory entries - 1
 535+ B6AE              ; C0h (192)       AL0, 2 directory blocks
 536+ B6AE              ; 00h (0)         AL1
 537+ B6AE              ; 16              CKS, size of checksum vector
 538+ B6AE              ; 2               OFF, reserved tracks
 539+ B6AE              ; 2               PSH, physical sector shift
 540+ B6AE              ; 3               PHM, physical sector mask
 541+ B6AE              ;
 542+ B6AE              ; 0               Single sided
 543+ B6AE              ; 40              Tracks per side
 544+ B6AE              ; 9               Sectors per track
 545+ B6AE              ; 41h (65)        First sector number
 546+ B6AE              ; 512             Sector size
 547+ B6AE              ; 42              Gap length (read/write)
 548+ B6AE              ; 82              Gap length (format)
 549+ B6AE              ; 60h (96)        MFM mode, skip deleted data address mark
 550+ B6AE              ; 0               Do auto select format
 551+ B6AE              ;
 552+ B6AE              ;
 553+ B6AE              ; AMSTRAD CPC range DATA ONLY format (type 2)
 554+ B6AE              ;
 555+ B6AE              ; 36              SPT, records per track
 556+ B6AE              ; 3               BSH, block shift
 557+ B6AE              ; 7               BLM, block mask
 558+ B6AE              ; 0               EXM, extent mask
 559+ B6AE              ; 179             DSM, number of blocks - 1
 560+ B6AE              ; 63              DRM, number of directory entries - 1
 561+ B6AE              ; C0h (192)       AL0, 2 directory blocks
 562+ B6AE              ; 00h (0)         AL1
 563+ B6AE              ; 16              CKS, size of checksum vector
 564+ B6AE              ; 0               OFF, reserved tracks
 565+ B6AE              ; 2               PSH, physical sector shift
 566+ B6AE              ; 3               PHM, physical sector mask
 567+ B6AE              ;
 568+ B6AE              ; 0               Single sided
 569+ B6AE              ; 40              Tracks per side
 570+ B6AE              ; 9               Sectors per track
 571+ B6AE              ; C1h (193)       First sector number
 572+ B6AE              ; 512             Sector size
 573+ B6AE              ; 42              Gap length (read/write)
 574+ B6AE              ; 82              Gap length (format)
 575+ B6AE              ; 60h (96)        MFM mode, skip deleted data address mark
 576+ B6AE              ; 0               Do auto select format
 577+ B6AE              ;
 578+ B6AE              ;
 579+ B6AE              ; CP/M File compatibility
 580+ B6AE              ;
 581+ B6AE              ; +3DOS uses the CP/M file structure, subject to the following
 582+ B6AE              ; restrictions:
 583+ B6AE              ;
 584+ B6AE              ;         - Maximum file size of 8 megabytes (CP/M Plus supports a
 585+ B6AE              ;             maximum of 32 megabytes).
 586+ B6AE              ;
 587+ B6AE              ;         - Maximum drive size of 8 megabytes (CP/M Plus supports a
 588+ B6AE              ;             maximum of 128 megabytes).
 589+ B6AE              ;
 590+ B6AE              ;         - Directory labels are ignored.
 591+ B6AE              ;
 592+ B6AE              ;         - No passwords. XFCBs will be erased, renamed, etc., along
 593+ B6AE              ;             with their file(s) but are otherwise ignored.
 594+ B6AE              ;
 595+ B6AE              ;         - No date and time stamps. SFCBs are initialised to zero when
 596+ B6AE              ;             a file is created, but are otherwise ignored.
 597+ B6AE              ;
 598+ B6AE              ;         - The archive file attribute is ignored, i.e. it is unaffected
 599+ B6AE              ;             by all routines except DOS SET ATTRIBUTES.
 600+ B6AE              ;
 601+ B6AE              ;
 602+ B6AE              ; File model
 603+ B6AE              ;
 604+ B6AE              ; A file is an array of bytes which may be of any length from 0 to 8
 605+ B6AE              ; megabytes. Associated with each open file is a 24 bit file
 606+ B6AE              ; pointer. The file pointer is the address of the next byte to be
 607+ B6AE              ; written or read. The file pointer is automatically advanced after each
 608+ B6AE              ; read or write operation, however, the user may set it to any value
 609+ B6AE              ; required for random access.
 610+ B6AE              ;
 611+ B6AE              ; The end of file position (EOF) is the lowest byte position that is
 612+ B6AE              ; greater than all written byte positions. Files without headers can
 613+ B6AE              ; only record their EOF position to the start of the next 128 byte
 614+ B6AE              ; record, i.e. ceiling(EOF/128). Files with headers have their EOF
 615+ B6AE              ; position recorded exactly.
 616+ B6AE              ;
 617+ B6AE              ; Writing a byte after the EOF position will extend the file and advance
 618+ B6AE              ; the EOF position.
 619+ B6AE              ;
 620+ B6AE              ; Reading a byte at (or beyond) the EOF position will return an EOF
 621+ B6AE              ; error.
 622+ B6AE              ;
 623+ B6AE              ; Reading an unwritten byte below the EOF position will either return a
 624+ B6AE              ; nonsensical byte or an EOF error. (Reading unwritten bytes is not
 625+ B6AE              ; recommended.)
 626+ B6AE              ;
 627+ B6AE              ;
 628+ B6AE              ; Changing disks
 629+ B6AE              ;
 630+ B6AE              ; Under +3DOS, a disk may be changed or removed whenever the drive is
 631+ B6AE              ; not being accessed (and there are no files open on that drive). There
 632+ B6AE              ; is no need to log in a disk.
 633+ B6AE              ;
 634+ B6AE              ; A disk should not be changed while there are files open on it. If,
 635+ B6AE              ; however, a disk is changed while there are still files open on it,
 636+ B6AE              ; then as soon as +3DOS detects this, the user will be prompted to
 637+ B6AE              ; insert the correct disk. +3DOS can only detect this changed when it
 638+ B6AE              ; reads the directory from the disk.
 639+ B6AE              ;
 640+ B6AE              ; Note that changing a disk while it is still being written to may
 641+ B6AE              ; corrupt the data on the disk.
 642+ B6AE              ;
 643+ B6AE              ;
 644+ B6AE              ; Logical to physical drive mapping
 645+ B6AE              ;
 646+ B6AE              ; If required, two logical drives (A: and B:) can be mapped onto a
 647+ B6AE              ; single physical drive (unit 0). This may be useful for single disk
 648+ B6AE              ; drive systems.
 649+ B6AE              ;
 650+ B6AE              ; To enable this mapping, the routine DOS MAP B is called, passing to it
 651+ B6AE              ; the address of a routine CHANGE DISK. Whenever unit 0 is accessed, a
 652+ B6AE              ; check is made to see if the disk in unit 0 is for the required logical
 653+ B6AE              ; drive. If not, then CHANGE DISK is called. CHANGE DISK is passed the
 654+ B6AE              ; address of a message and the required logical drive, and the user
 655+ B6AE              ; should be prompted with the message...
 656+ B6AE              ;
 657+ B6AE              ;         Please put the disk for x: into the drive then press any key
 658+ B6AE              ;
 659+ B6AE              ; ...(where x is the name of the logical drive, e.g. 'A:' or 'B:'). The
 660+ B6AE              ; routine should then wait for a key to be pressed before returning,
 661+ B6AE              ; after which it is assumed that the disk in unit 0 is for the required
 662+ B6AE              ; logical drive.
 663+ B6AE              ;
 664+ B6AE              ; DOS MAP B can also be used to re-map B onto unit 1. If unit 1 does not
 665+ B6AE              ; exist, then drive B: is disabled.
 666+ B6AE              ;
 667+ B6AE              ;
 668+ B6AE              ; +3DOS Error codes
 669+ B6AE              ;
 670+ B6AE              ; Many +3DOS routines can fail. This is indicated with 'carry' false and
 671+ B6AE              ; an error code in the A register. The error codes are...
 672+ B6AE              ;
 673+ B6AE              ; Recoverable disk errors:
 674+ B6AE              ;
 675+ B6AE              ; 0       Drive not ready
 676+ B6AE              ; 1       Disk is write protected
 677+ B6AE              ; 2       Seek fail
 678+ B6AE              ; 3       CRC data error
 679+ B6AE              ; 4       No data
 680+ B6AE              ; 5       Missing address mark
 681+ B6AE              ; 6       Unrecognised disk format
 682+ B6AE              ; 7       Unknown disk error
 683+ B6AE              ; 8       Disk changed whilst +3DOS was using it
 684+ B6AE              ; 9       Unsuitable media for drive
 685+ B6AE              ;
 686+ B6AE              ; Non-recoverable errors:
 687+ B6AE              ;
 688+ B6AE              ; 20      Bad filename
 689+ B6AE              ; 21      Bad parameter
 690+ B6AE              ; 22      Drive not found
 691+ B6AE              ; 23      File not found
 692+ B6AE              ; 24      File already exists
 693+ B6AE              ; 25      End of file
 694+ B6AE              ; 26      Disk full
 695+ B6AE              ; 27      Directory full
 696+ B6AE              ; 28      Read-only file
 697+ B6AE              ; 29      File number not open (or open with wrong access)
 698+ B6AE              ; 30      Access denied (file is in use already)
 699+ B6AE              ; 31      Cannot rename between drives
 700+ B6AE              ; 32      Extent missing (which should be there)
 701+ B6AE              ; 33      Uncached (software error)
 702+ B6AE              ; 34      File too big (trying to read or write past 8 megabytes)
 703+ B6AE              ; 35      Disk not bootable (boot sector is not acceptable to DOS BOOT)
 704+ B6AE              ; 36      Drive in use (trying to re-map or remove a drive with files
 705+ B6AE              ;           open)
 706+ B6AE              ;
 707+ B6AE              ; As an example, the report 'Unsuitable media for drive' is caused by
 708+ B6AE              ; trying to write to a single track disk in a double track drive, or
 709+ B6AE              ; trying to read or write a double track disk in a single track drive.
 710+ B6AE              ;
 711+ B6AE              ; The report 'Missing address mark' is the error returned when trying to
 712+ B6AE              ; access a disk that is not formatted (although this is not the sole
 713+ B6AE              ; reason for the error).
 714+ B6AE              ;
 715+ B6AE              ;
 716+ B6AE              ; +3DOS Messages
 717+ B6AE              ;
 718+ B6AE              ; If error messages are enabled (DOS SET MESSAGE) then, in the event of
 719+ B6AE              ; a recoverable disk error, +3DOS will pass the ALERT routine a message
 720+ B6AE              ; and the user should be prompted to '- Retry, Ignore or Cancel?' If the
 721+ B6AE              ; user replies 'R', then the disk operation is retried. If the reply is
 722+ B6AE              ; 'I', then the error is ignored, and if the reply is 'C', then the
 723+ B6AE              ; operation is cancelled and an error condition is returned to the
 724+ B6AE              ; caller. If error messages are disabled or if the error is not
 725+ B6AE              ; recoverable, then no message is displayed and an error condition is
 726+ B6AE              ; returned to the caller.
 727+ B6AE              ;
 728+ B6AE              ;
 729+ B6AE              ; Essential filing system routines
 730+ B6AE              ;
 731+ B6AE
 732+ B6AE              dos_initialise: equ 0x0100 ; (256)
 733+ B6AE
 734+ B6AE              ; Initialise +3DOS.
 735+ B6AE              ; Initialise disk drivers.
 736+ B6AE              ; Initialise cache and the RAMdisk.
 737+ B6AE              ; All files closed.
 738+ B6AE              ; All drives logged out.
 739+ B6AE              ; Default drive A: (if disk interface present), else M:.
 740+ B6AE              ; Default user 0.
 741+ B6AE              ; Retry count 15.
 742+ B6AE              ; Error messages disabled.
 743+ B6AE              ;
 744+ B6AE              ; ENTRY CONDITIONS
 745+ B6AE              ;         None
 746+ B6AE              ;
 747+ B6AE              ; EXIT CONDITIONS
 748+ B6AE              ;         If OK:
 749+ B6AE              ;                 Carry true
 750+ B6AE              ;                 A corrupt
 751+ B6AE              ;         Otherwise:
 752+ B6AE              ;                 Carry false
 753+ B6AE              ;                 A=Error code
 754+ B6AE              ;         Always:
 755+ B6AE              ;                 BC DE HL IX corrupt
 756+ B6AE              ;                 All other registers preserved
 757+ B6AE              ;
 758+ B6AE              ;
 759+ B6AE
 760+ B6AE              dos_version: equ 0x0103 ; (259)
 761+ B6AE
 762+ B6AE              ; Get the DOS issue and version numbers.
 763+ B6AE              ;
 764+ B6AE              ; ENTRY CONDITIONS
 765+ B6AE              ;         None
 766+ B6AE              ;
 767+ B6AE              ; EXIT CONDITIONS
 768+ B6AE              ;                 D=Issue
 769+ B6AE              ;                 E=Version (within issue)
 770+ B6AE              ;         Always:
 771+ B6AE              ;                 AF BC HL IX corrupt
 772+ B6AE              ;                 All other registers preserved
 773+ B6AE              ;
 774+ B6AE              ;
 775+ B6AE
 776+ B6AE              dos_open: equ 0x0106 ; (262)
 777+ B6AE
 778+ B6AE              ; Create and/or open a file
 779+ B6AE              ;
 780+ B6AE              ; There is a choice of action depending on whether or not the file
 781+ B6AE              ; already exists. The choices are 'open action' or 'create action', and
 782+ B6AE              ; are specified in DE. If the file already exists, then the open action
 783+ B6AE              ; is followed; otherwise the create action is followed.
 784+ B6AE              ;
 785+ B6AE              ; Open action
 786+ B6AE              ;
 787+ B6AE              ;         0. Error - File already exists.
 788+ B6AE              ;
 789+ B6AE              ;         1. Open the file, read the header (if any). Position file
 790+ B6AE              ;            pointer after header.
 791+ B6AE              ;
 792+ B6AE              ;         2. Open the file, ignore any header. Position file pointer at
 793+ B6AE              ;            000000h (0).
 794+ B6AE              ;
 795+ B6AE              ;         3. Assume given filename is 'filename.type'. Erase
 796+ B6AE              ;            'filename.BAK' (if it exists). Rename 'filename.type' to
 797+ B6AE              ;            'filename.BAK'. Follow create action.
 798+ B6AE              ;
 799+ B6AE              ;         4. Erase existing version. Follow create action.
 800+ B6AE              ;
 801+ B6AE              ; Create action
 802+ B6AE              ;
 803+ B6AE              ;         0. Error - File does not exist.
 804+ B6AE              ;
 805+ B6AE              ;         1. Create and open new file with a header. Position file
 806+ B6AE              ;            pointer after header.
 807+ B6AE              ;
 808+ B6AE              ;         2. Create and open new file without a header. Position file
 809+ B6AE              ;            pointer at 000000h (0).
 810+ B6AE              ;
 811+ B6AE              ; (Example: To simulate the tape action of... 'if the file exists open
 812+ B6AE              ; it, otherwise create it with a header', set open action = 1, create
 813+ B6AE              ; action = 1.)
 814+ B6AE              ;
 815+ B6AE              ; (Example: To open a file and report an error if it does not exist, set
 816+ B6AE              ; open action = 1, create action = 0.)
 817+ B6AE              ;
 818+ B6AE              ; (Example: To create a new file with a header, first renaming any
 819+ B6AE              ; existing version to '.BAK', set open action = 3, create action = 1.)
 820+ B6AE              ;
 821+ B6AE              ; Files with headers have their EOF position recorded as the smallest
 822+ B6AE              ; byte position greater than all written byte positions.
 823+ B6AE              ;
 824+ B6AE              ; Files without headers have their EOF position recorded as the byte at
 825+ B6AE              ; the start of the smallest 128 byte record position greater than all
 826+ B6AE              ; written record positions.
 827+ B6AE              ;
 828+ B6AE              ; Soft-EOF is the character 1Ah (26) and is nothing to do with the EOF
 829+ B6AE              ; position, only the routine DOS BYTE READ knows about soft-EOF.
 830+ B6AE              ;
 831+ B6AE              ; The header data area is 8 bytes long and may be used by the caller for
 832+ B6AE              ; any purpose whatsoever. If open action = 1, and the file exists (and
 833+ B6AE              ; has a header), then the header data is read from the file, otherwise
 834+ B6AE              ; the header data is zeroised. The header data is available even if the
 835+ B6AE              ; file does not have a header. Call DOS REF HEAD to access the header
 836+ B6AE              ; data.
 837+ B6AE              ;
 838+ B6AE              ; Note that +3 BASIC makes use of the first 7 of these 8 bytes as
 839+ B6AE              ; follows:
 840+ B6AE              ;
 841+ B6AE              ; +---------------+-------+-------+-------+-------+-------+-------+-------+
 842+ B6AE              ; | BYTE          |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
 843+ B6AE              ; +---------------+-------+-------+-------+-------+-------+-------+-------+
 844+ B6AE              ; | Program           0   file length     8000h or LINE   offset to prog  |
 845+ B6AE              ; | Numeric array     1   file length     xxx     name    xxx     xxx     |
 846+ B6AE              ; | Character array   2   file length     xxx     name    xxx     xxx     |
 847+ B6AE              ; | CODE or SCREEN$   3   file length     load address    xxx     xxx     |
 848+ B6AE              ; +-----------------------------------------------------------------------+
 849+ B6AE              ;
 850+ B6AE              ; (xxx = doesn't matter)
 851+ B6AE              ;
 852+ B6AE              ; If creating a file that will subsequently be LOADed within BASIC, then
 853+ B6AE              ; these bytes should be filled with the relevant values.
 854+ B6AE              ;
 855+ B6AE              ; If the file is opened with exclusive-write or exclusive-read-write
 856+ B6AE              ; access (and the file has a header), then the header is updated when
 857+ B6AE              ; the file is closed.
 858+ B6AE              ;
 859+ B6AE              ; A file that is already open for shared-read access on another file
 860+ B6AE              ; number may only be opened for shared-read access on this file number.
 861+ B6AE              ;
 862+ B6AE              ; A file that is already open for exclusive-read or exclusive-write or
 863+ B6AE              ; exclusive-read-write access on another file number may not be opened
 864+ B6AE              ; on this file number.
 865+ B6AE              ;
 866+ B6AE              ; ENTRY CONDITIONS
 867+ B6AE              ;         B = File number 0...15
 868+ B6AE              ;         C = Access mode required
 869+ B6AE              ;                 Bits 0...2 values:
 870+ B6AE              ;                         1 = exclusive-read
 871+ B6AE              ;                         2 = exclusive-write
 872+ B6AE              ;                         3 = exclusive-read-write
 873+ B6AE              ;                         5 = shared-read
 874+ B6AE              ;                 Bits 3...7 = 0 (reserved)
 875+ B6AE              ;         D = Create action
 876+ B6AE              ;         E = Open action
 877+ B6AE              ;         HL = Address of filename (no wildcards)
 878+ B6AE              ;
 879+ B6AE              ; EXIT CONDITIONS
 880+ B6AE              ;         If file newly created:
 881+ B6AE              ;                 Carry true
 882+ B6AE              ;                 Zero true
 883+ B6AE              ;                 A corrupt
 884+ B6AE              ;         If existing file opened:
 885+ B6AE              ;                 Carry true
 886+ B6AE              ;                 Zero false
 887+ B6AE              ;                 A corrupt
 888+ B6AE              ;         Otherwise:
 889+ B6AE              ;                 Carry false
 890+ B6AE              ;                 A = Error code
 891+ B6AE              ;         Always:
 892+ B6AE              ;                 BC DE HL IX corrupt
 893+ B6AE              ;                 All other registers preserved
 894+ B6AE              ;
 895+ B6AE              ;
 896+ B6AE
 897+ B6AE              dos_close: equ 0x0109 ; (265)
 898+ B6AE
 899+ B6AE              ; Close a file.
 900+ B6AE              ;
 901+ B6AE              ; Write the header (if there is one).
 902+ B6AE              ;
 903+ B6AE              ; Write any outstanding data.
 904+ B6AE              ;
 905+ B6AE              ; Update the directory.
 906+ B6AE              ;
 907+ B6AE              ; Release the file number.
 908+ B6AE              ;
 909+ B6AE              ; All opened files must eventually be closed (or abandoned). A file
 910+ B6AE              ; number cannot be reused until it is closed (or abandoned).
 911+ B6AE              ;
 912+ B6AE              ; ENTRY CONDITIONS
 913+ B6AE              ;         B = File number
 914+ B6AE              ;
 915+ B6AE              ; EXIT CONDITIONS
 916+ B6AE              ;         If OK:
 917+ B6AE              ;                 Carry true
 918+ B6AE              ;                 A corrupt
 919+ B6AE              ;         Otherwise:
 920+ B6AE              ;                 Carry false
 921+ B6AE              ;                 A = Error code
 922+ B6AE              ;         Always:
 923+ B6AE              ;                 BC DE HL IX corrupt
 924+ B6AE              ;                 All other registers preserved
 925+ B6AE              ;
 926+ B6AE              ;
 927+ B6AE
 928+ B6AE              dos_abandon: equ 0x010C ; (268)
 929+ B6AE
 930+ B6AE              ; Abandon a file.
 931+ B6AE              ;
 932+ B6AE              ; Similar to DOS CLOSE, except that any header, or data, or directory
 933+ B6AE              ; data yet to be written to disk is discarded. This routine should only
 934+ B6AE              ; be used to force a file closed in the event that DOS CLOSE is unable
 935+ B6AE              ; to close the file (for example, if the media is damaged or permanently
 936+ B6AE              ; changed or removed).
 937+ B6AE              ;
 938+ B6AE              ; ENTRY CONDITIONS
 939+ B6AE              ;         B = File number
 940+ B6AE              ;
 941+ B6AE              ; EXIT CONDITIONS
 942+ B6AE              ;         If OK:
 943+ B6AE              ;                 Carry true
 944+ B6AE              ;                 A corrupt
 945+ B6AE              ;         Otherwise:
 946+ B6AE              ;                 Carry false
 947+ B6AE              ;                 A = Error code
 948+ B6AE              ;         Always:
 949+ B6AE              ;                 BC DE HL IX corrupt
 950+ B6AE              ;                 All other registers preserved
 951+ B6AE              ;
 952+ B6AE              ;
 953+ B6AE
 954+ B6AE              dos_ref_head: equ 0x010F ; (271)
 955+ B6AE
 956+ B6AE              ; Point at the header data for this file.
 957+ B6AE              ;
 958+ B6AE              ; The header data area is 8 bytes long and may be used by the caller for
 959+ B6AE              ; any purpose whatsoever. It is available even if the file does not have
 960+ B6AE              ; a header; however, only files with a header and opened with write
 961+ B6AE              ; access will have the header data recorded on disk.
 962+ B6AE              ;
 963+ B6AE              ; Note that +3 BASIC uses these 8 bytes (see the note under DOS OPEN
 964+ B6AE              ; which gives the details). If creating a file that will subsequently be
 965+ B6AE              ; LOADed within BASIC, then those bytes should be filled with the
 966+ B6AE              ; relevant values.
 967+ B6AE              ;
 968+ B6AE              ; ENTRY CONDITIONS
 969+ B6AE              ;         B = File number
 970+ B6AE              ;
 971+ B6AE              ; EXIT CONDITIONS
 972+ B6AE              ;         If OK, but file doesn't have a header:
 973+ B6AE              ;                 Carry true
 974+ B6AE              ;                 Zero true
 975+ B6AE              ;                 A corrupt
 976+ B6AE              ;                 IX = Address of header data in page 7
 977+ B6AE              ;         If OK, file has a header:
 978+ B6AE              ;                 Carry true
 979+ B6AE              ;                 Zero false
 980+ B6AE              ;                 A corrupt
 981+ B6AE              ;                 IX = Address of header data in page 7
 982+ B6AE              ;         Otherwise:
 983+ B6AE              ;                 Carry false
 984+ B6AE              ;                 A = Error code
 985+ B6AE              ;                 IX corrupt
 986+ B6AE              ;         Always:
 987+ B6AE              ;                 BC DE HL corrupt
 988+ B6AE              ;                 All other registers preserved
 989+ B6AE              ;
 990+ B6AE              ;
 991+ B6AE
 992+ B6AE              dos_read: equ 0x0112 ; (274)
 993+ B6AE
 994+ B6AE              ; Read bytes from a file into memory.
 995+ B6AE              ;
 996+ B6AE              ; Advance the file pointer.
 997+ B6AE              ;
 998+ B6AE              ; The destination buffer is in the following memory configuration:
 999+ B6AE              ;
1000+ B6AE              ;         C000h...FFFFh (49152...65535)   - Page specified in C
1001+ B6AE              ;         8000h...BFFFh (32768...49151)   - Page 2
1002+ B6AE              ;         4000h...7FFFh (16384...32767)   - Page 5
1003+ B6AE              ;         0000h...3FFFh (0...16383)       - DOS ROM
1004+ B6AE              ;
1005+ B6AE              ; The routine does not consider soft-EOF.
1006+ B6AE              ;
1007+ B6AE              ; Reading EOF will produce an error.
1008+ B6AE              ;
1009+ B6AE              ; ENTRY CONDITIONS
1010+ B6AE              ;         B = File number
1011+ B6AE              ;         C = Page for C000h (49152)...FFFFh (65535)
1012+ B6AE              ;         DE = Number of bytes to read (0 means 64K)
1013+ B6AE              ;         HL = Address for bytes to be read
1014+ B6AE              ;
1015+ B6AE              ; EXIT CONDITIONS
1016+ B6AE              ;         If OK:
1017+ B6AE              ;                 Carry true
1018+ B6AE              ;                 A DE corrupt
1019+ B6AE              ;         Otherwise:
1020+ B6AE              ;                 Carry false
1021+ B6AE              ;                 A = Error code
1022+ B6AE              ;                 DE = Number of bytes remaining unread
1023+ B6AE              ;         Always:
1024+ B6AE              ;                 BC HL IX corrupt
1025+ B6AE              ;                 All other registers preserved
1026+ B6AE              ;
1027+ B6AE              ;
1028+ B6AE
1029+ B6AE              dos_write: equ 0x0115 ; (277)
1030+ B6AE
1031+ B6AE              ; Write bytes to a file from memory.
1032+ B6AE              ;
1033+ B6AE              ; Advance the file pointer.
1034+ B6AE              ;
1035+ B6AE              ; The source buffer is in the following memory configuration:
1036+ B6AE              ;
1037+ B6AE              ;         C000h...FFFFh (49152...65535)   - Page specified in C
1038+ B6AE              ;         8000h...BFFFh (32768...49151)   - Page 2
1039+ B6AE              ;         4000h...7FFFh (16384...32767)   - Page 5
1040+ B6AE              ;         0000h...3FFFh (0...16383)       - DOS ROM
1041+ B6AE              ;
1042+ B6AE              ; ENTRY CONDITIONS
1043+ B6AE              ;         B = File number
1044+ B6AE              ;         C = Page for C000h (49152)...FFFFh (65535)
1045+ B6AE              ;         DE = Number of bytes to write (0 means 64K)
1046+ B6AE              ;         HL = Address for bytes to write
1047+ B6AE              ;
1048+ B6AE              ; EXIT CONDITIONS
1049+ B6AE              ;         If OK:
1050+ B6AE              ;                 Carry true
1051+ B6AE              ;                 A DE corrupt
1052+ B6AE              ;         Otherwise:
1053+ B6AE              ;                 Carry false
1054+ B6AE              ;                 A = Error code
1055+ B6AE              ;                 DE = Number of bytes remaining unwritten
1056+ B6AE              ;         Always:
1057+ B6AE              ;                 BC HL IX corrupt
1058+ B6AE              ;                 All other registers preserved
1059+ B6AE              ;
1060+ B6AE              ;
1061+ B6AE
1062+ B6AE              dos_byte_read: equ 0x0118 ; (280)
1063+ B6AE
1064+ B6AE              ; Read a byte from a file.
1065+ B6AE              ;
1066+ B6AE              ; Advance the file pointer.
1067+ B6AE              ;
1068+ B6AE              ; Tests for soft-EOF (1Ah (26)). As this condition is not latched, it is
1069+ B6AE              ; possible to read past soft-EOF.
1070+ B6AE              ;
1071+ B6AE              ; EOF is latched.
1072+ B6AE              ;
1073+ B6AE              ; The caller must decide whether or not soft-EOF is of interest. This
1074+ B6AE              ; would normally be the case only when reading an ASCII file.
1075+ B6AE              ;
1076+ B6AE              ; Reading EOF will produce an error.
1077+ B6AE              ;
1078+ B6AE              ; ENTRY CONDITIONS
1079+ B6AE              ;         B = File number
1080+ B6AE              ;
1081+ B6AE              ; EXIT CONDITIONS
1082+ B6AE              ;         If OK - Byte <> 1Ah (26) (soft-EOF)
1083+ B6AE              ;                 Carry true
1084+ B6AE              ;                 Zero false
1085+ B6AE              ;                 A corrupt
1086+ B6AE              ;                 C = Byte
1087+ B6AE              ;         If OK - Byte = 1Ah (26) (soft-EOF)
1088+ B6AE              ;                 Carry true
1089+ B6AE              ;                 Zero true
1090+ B6AE              ;                 A corrupt
1091+ B6AE              ;                 C = Byte
1092+ B6AE              ;         Otherwise:
1093+ B6AE              ;                 Carry false
1094+ B6AE              ;                 A = Error code
1095+ B6AE              ;                 C corrupt
1096+ B6AE              ;         Always:
1097+ B6AE              ;                 B DE HL IX corrupt
1098+ B6AE              ;                 All other registers preserved
1099+ B6AE              ;
1100+ B6AE              ;
1101+ B6AE
1102+ B6AE              dos_byte_write: equ 0x011B ; (283)
1103+ B6AE
1104+ B6AE              ; Write a byte to a file.
1105+ B6AE              ;
1106+ B6AE              ; Advance the file pointer.
1107+ B6AE              ;
1108+ B6AE              ; ENTRY CONDITIONS
1109+ B6AE              ;         B = File number
1110+ B6AE              ;         C = Byte to write
1111+ B6AE              ;
1112+ B6AE              ; EXIT CONDITIONS
1113+ B6AE              ;         If OK:
1114+ B6AE              ;                 Carry true
1115+ B6AE              ;                 A corrupt
1116+ B6AE              ;         Otherwise:
1117+ B6AE              ;                 Carry false
1118+ B6AE              ;                 A = Error code
1119+ B6AE              ;         Always:
1120+ B6AE              ;                 BC DE HL IX corrupt
1121+ B6AE              ;                 All otehr registers preserved
1122+ B6AE              ;
1123+ B6AE              ;
1124+ B6AE
1125+ B6AE              dos_catalog: equ 0x011E ; (286)
1126+ B6AE
1127+ B6AE              ; Fills a buffer with part of the directory (sorted).
1128+ B6AE              ;
1129+ B6AE              ; The filename specifies the drive, user and a (possibly ambiguous)
1130+ B6AE              ; filename.
1131+ B6AE              ;
1132+ B6AE              ; Since the size of a directory is variable (and may be quite large),
1133+ B6AE              ; this routine permits the directory to be catalogued in a number of
1134+ B6AE              ; small sections. The caller passes a buffer pre-loaded with the first
1135+ B6AE              ; required filename, or zeroes for the start of the directory. The
1136+ B6AE              ; buffer is loaded with part (or all, if it fits) of the directory
1137+ B6AE              ; sorted in ASCII order. If more of the directory is required, this
1138+ B6AE              ; routine is re-called with the buffer re-initialised with the last file
1139+ B6AE              ; previously returned. This procedure is followed repeatedly until all
1140+ B6AE              ; of the directory has been catalogued.
1141+ B6AE              ;
1142+ B6AE              ; Note that +3DOS format disks (which are the same as single-sided,
1143+ B6AE              ; single track AMSTRAD PCW range format disks) may have a maximum of 64
1144+ B6AE              ; directory entries.
1145+ B6AE              ;
1146+ B6AE              ; Buffer format:
1147+ B6AE              ;
1148+ B6AE              ;         Entry 0
1149+ B6AE              ;         Entry 1
1150+ B6AE              ;         Entry 2
1151+ B6AE              ;         Entry 3
1152+ B6AE              ;         ...to...
1153+ B6AE              ;         Entry n
1154+ B6AE              ;
1155+ B6AE              ; Entry 0 must be preloaded with the first 'filename.type'
1156+ B6AE              ; required. Entry 1 will contain the first matching filename greater
1157+ B6AE              ; than the preloaded entry (if any). A zeroised preload entry is OK.
1158+ B6AE              ;
1159+ B6AE              ; If the buffer is too small for the directory, this routine can be
1160+ B6AE              ; called again with entry 0 replaced by entry n to fetch the next part
1161+ B6AE              ; of the directory.
1162+ B6AE              ;
1163+ B6AE              ; Entry format (13 bytes long):
1164+ B6AE              ;
1165+ B6AE              ;         Bytes 0...7     - Filename (ASCII) left justified, space
1166+ B6AE              ;                            filled
1167+ B6AE              ;         Bytes 6...10    - Type (ASCII) left justified, space filledd
1168+ B6AE              ;         Bytes 11...12   - Size in kilobytes (binary)
1169+ B6AE              ;
1170+ B6AE              ; The file size is the amount of disk space allocated to the file, not
1171+ B6AE              ; necessarily the same as the amount used by the file.
1172+ B6AE              ;
1173+ B6AE              ; ENTRY CONDITIONS
1174+ B6AE              ;         B = n+1, size of buffer in entries, >=2
1175+ B6AE              ;         C = Filter
1176+ B6AE              ;                 bit 0 = include system files (is set)
1177+ B6AE              ;                 bits 1...7 = 0 (reserved)
1178+ B6AE              ;         DE = Address of buffer (first entry initialised)
1179+ B6AE              ;         HL = Address of filename (wildcards permitted)
1180+ B6AE              ;
1181+ B6AE              ; EXIT CONDITIONS
1182+ B6AE              ;         If OK:
1183+ B6AE              ;                 Carry true
1184+ B6AE              ;                 A corrupt
1185+ B6AE              ;                 B = Number of completed entries in buffer, 0...n.
1186+ B6AE              ;                     (If B = n, there may be more to come).
1187+ B6AE              ;
1188+ B6AE              ;         Otherwise:
1189+ B6AE              ;                 Carry false
1190+ B6AE              ;                 A = Error code
1191+ B6AE              ;                 B corrupt
1192+ B6AE              ;         Always:
1193+ B6AE              ;                 C DE HL IX corrupt
1194+ B6AE              ;                 All other registers preserved
1195+ B6AE              ;
1196+ B6AE              ;
1197+ B6AE
1198+ B6AE              dos_free_space: equ 0x0121 ; (289)
1199+ B6AE
1200+ B6AE              ; How much free space is there on this drive?
1201+ B6AE              ;
1202+ B6AE              ; ENTRY CONDITIONS
1203+ B6AE              ;         A = Drive, ASCII 'A'...'P'
1204+ B6AE              ;
1205+ B6AE              ; EXIT CONDITIONS
1206+ B6AE              ;         If OK:
1207+ B6AE              ;                 Carry true
1208+ B6AE              ;                 A corrupt
1209+ B6AE              ;                 HL = Free space (in kilobytes)
1210+ B6AE              ;         Otherwise:
1211+ B6AE              ;                 Carry false
1212+ B6AE              ;                 A = Error code
1213+ B6AE              ;                 HL corrupt
1214+ B6AE              ;         Always:
1215+ B6AE              ;                 BC DE IX corrupt
1216+ B6AE              ;                 All other registers preserved
1217+ B6AE              ;
1218+ B6AE              ;
1219+ B6AE
1220+ B6AE              dos_delete: equ 0x0124 ; (292)
1221+ B6AE
1222+ B6AE              ; XXX This call is not documented in the WoS' HTML version of the +3 manual,
1223+ B6AE              ; but first guessed and finally confirmet it with the original Spanish manual.
1224+ B6AE
1225+ B6AE              ; Delete an existing file.
1226+ B6AE              ;
1227+ B6AE              ; File must not be open on any file number.
1228+ B6AE              ;
1229+ B6AE              ; ENTRY CONDITIONS HL = Address of filename (wildcards permitted)
1230+ B6AE              ;
1231+ B6AE              ; EXIT CONDITIONS If OK: Carry true A corrupt Otherwise: Carry false A = Error
1232+ B6AE              ; code Always: BC DE HL IX corrupt All other registers preserved
1233+ B6AE
1234+ B6AE              dos_rename: equ 0x0127 ; (295)
1235+ B6AE
1236+ B6AE              ; Rename an existing file.
1237+ B6AE              ;
1238+ B6AE              ; File must not be open on any file number. A file with the new filename
1239+ B6AE              ; must not exist. The new name must specify, or default to, the sme
1240+ B6AE              ; drive as the old name.
1241+ B6AE              ;
1242+ B6AE              ; ENTRY CONDITIONS
1243+ B6AE              ;         DE = Address of new filename (no wildcards)
1244+ B6AE              ;         HL = Address of old filename (no wildcards)
1245+ B6AE              ;
1246+ B6AE              ; EXIT CONDITIONS
1247+ B6AE              ;         If OK:
1248+ B6AE              ;                 Carry true
1249+ B6AE              ;                 A corrupt
1250+ B6AE              ;         Otherwise:
1251+ B6AE              ;                 Carry false
1252+ B6AE              ;                 A = Error code
1253+ B6AE              ;         Always:
1254+ B6AE              ;                 BC DE HL IX corrupt
1255+ B6AE              ;                 All other registers preserved
1256+ B6AE              ;
1257+ B6AE              ;
1258+ B6AE
1259+ B6AE              dos_boot: equ 0x012A ; (298)
1260+ B6AE
1261+ B6AE              ; Boot from disk.
1262+ B6AE              ;
1263+ B6AE              ; This routine loads a single bootstrap sector from the disk in drive A:
1264+ B6AE              ; into memory and enters it. This is for loading games or other
1265+ B6AE              ; operating systems.
1266+ B6AE              ;
1267+ B6AE              ; Bootstrap environment:
1268+ B6AE              ;
1269+ B6AE              ;         C000h...FFFFh (49152...65535)   - Page 3
1270+ B6AE              ;         8000h...BFFFh (32768...49151)   - Page 6
1271+ B6AE              ;         4000h...7FFFh (16384...32767)   - Page 7
1272+ B6AE              ;         0000h...3FFFh (0...16383)       - Page 4
1273+ B6AE              ;
1274+ B6AE              ; The bootstrap sector is on side 0, track 0, sector 1. It is loaded at
1275+ B6AE              ; FE00h (65024) and entered at FE10h (65040). Interrupts are disabled.
1276+ B6AE              ; SP is at FE00h (65024). The sum of all bytes in the sector must equal
1277+ B6AE              ; 3 MOD 256 (byte 15 can be set to the required value to achieve this).
1278+ B6AE              ;
1279+ B6AE              ; ENTRY CONDITIONS
1280+ B6AE              ;         None
1281+ B6AE              ;
1282+ B6AE              ; EXIT CONDITIONS
1283+ B6AE              ;         If OK:
1284+ B6AE              ;                 No exit (as the bootstrap will be entered)
1285+ B6AE              ;         Otherwise:
1286+ B6AE              ;                 Carry false
1287+ B6AE              ;                 A = Error code
1288+ B6AE              ;         Always:
1289+ B6AE              ;                 BC DE HL IX corrupt
1290+ B6AE              ;                 All other registers preserved
1291+ B6AE              ;
1292+ B6AE              ;
1293+ B6AE
1294+ B6AE              dos_set_drive: equ 0x012D ; (301)
1295+ B6AE
1296+ B6AE              ; Set the default drive (i.e. the drive implied by all filenames that do
1297+ B6AE              ; not specify a drive).
1298+ B6AE              ;
1299+ B6AE              ; The default drive is initially A:.
1300+ B6AE              ;
1301+ B6AE              ; Does not access the drive, but merely checks that there is a driver
1302+ B6AE              ; for it (which does not imply that the drive exists).
1303+ B6AE              ;
1304+ B6AE              ; This only affects routines that take filename parameters.
1305+ B6AE              ;
1306+ B6AE              ; ENTRY CONDITIONS
1307+ B6AE              ;         A = Drive, ASCII 'A'...'P' (FFh (255) = get default drive)
1308+ B6AE              ;
1309+ B6AE              ; EXIT CONDITIONS
1310+ B6AE              ;         If OK:
1311+ B6AE              ;                 Carry true
1312+ B6AE              ;                 A = Default drive
1313+ B6AE              ;         Otherwise:
1314+ B6AE              ;                 Carry false
1315+ B6AE              ;                 A = Error code
1316+ B6AE              ;         Always:
1317+ B6AE              ;                 BC DE HL IX corrupt
1318+ B6AE              ;                 All other registers preserved
1319+ B6AE              ;
1320+ B6AE              ;
1321+ B6AE
1322+ B6AE              dos_set_user: equ 0x0130 ; (304)
1323+ B6AE
1324+ B6AE              ; Set the default user area, i.e. the user area implied by all filenames
1325+ B6AE              ; that do not specify a user number.
1326+ B6AE              ;
1327+ B6AE              ; The default user number is intially 0.
1328+ B6AE              ;
1329+ B6AE              ; This only affects routines that take filename parameters.
1330+ B6AE              ;
1331+ B6AE              ; ENTRY CONDITIONS
1332+ B6AE              ;         A = User 0...15 (FFh (255) = get default user)
1333+ B6AE              ;
1334+ B6AE              ; EXIT CONDITIONS
1335+ B6AE              ;         If OK:
1336+ B6AE              ;                 Carry true
1337+ B6AE              ;                 A = Default user
1338+ B6AE              ;         Otherwise:
1339+ B6AE              ;                 Carry false
1340+ B6AE              ;                 A = Error code
1341+ B6AE              ;         Always:
1342+ B6AE              ;                 BC DE HL IX corrupt
1343+ B6AE              ;                 All other registers preserved
1344+ B6AE              ;
1345+ B6AE              ;
1346+ B6AE              ;
1347+ B6AE              ; Additional routines for games and operating systems
1348+ B6AE              ;
1349+ B6AE
1350+ B6AE              dos_get_position: equ 0x0133 ; (307)
1351+ B6AE
1352+ B6AE              ; Get the file pointer.
1353+ B6AE              ;
1354+ B6AE              ; ENTRY CONDITIONS
1355+ B6AE              ;         B = File number
1356+ B6AE              ;
1357+ B6AE              ; EXIT CONDITIONS
1358+ B6AE              ;         If OK:
1359+ B6AE              ;                 Carry true
1360+ B6AE              ;                 A corrupt
1361+ B6AE              ;                 E HL = File pointer 000000h...FFFFFFh (0...16777215)
1362+ B6AE              ;                 (E holds most significant byte; L holds leat
1363+ B6AE              ;                 significant byte)
1364+ B6AE              ;         Otherwise:
1365+ B6AE              ;                 Carry false
1366+ B6AE              ;                 A = Error code
1367+ B6AE              ;                 E HL corrupt
1368+ B6AE              ;         Always:
1369+ B6AE              ;                 BC D IX corrupt
1370+ B6AE              ;                 All other registers preserved
1371+ B6AE              ;
1372+ B6AE              ;
1373+ B6AE
1374+ B6AE              dos_set_position: equ 0x0136 ; (310)
1375+ B6AE
1376+ B6AE              ; Set the file pointer.
1377+ B6AE              ;
1378+ B6AE              ; Does not access the disk.
1379+ B6AE              ;
1380+ B6AE              ; Does not check (or care) if pointer is >= 8 megabytes.
1381+ B6AE              ;
1382+ B6AE              ; ENTRY CONDITIONS
1383+ B6AE              ;         B = File numbers
1384+ B6AE              ;         E HL = File pointer 000000h...FFFFFFh (0...16777215)
1385+ B6AE              ;         (E holds most significant byte; L holds leat
1386+ B6AE              ;         significant byte)
1387+ B6AE              ;
1388+ B6AE              ; EXIT CONDITIONS
1389+ B6AE              ;         If OK:
1390+ B6AE              ;                 Carry true
1391+ B6AE              ;                 A corrupt
1392+ B6AE              ;         Otherwise:
1393+ B6AE              ;                 Carry false
1394+ B6AE              ;                 A = Error code
1395+ B6AE              ;         Always:
1396+ B6AE              ;                 BC DE HL IX corrupt
1397+ B6AE              ;                 All other registers preserved
1398+ B6AE              ;
1399+ B6AE              ;
1400+ B6AE
1401+ B6AE              dos_get_eof: equ 0x0139 ; (313)
1402+ B6AE
1403+ B6AE              ; Get the end of file (EOF) file position greater than all written byte
1404+ B6AE              ; positions.
1405+ B6AE              ;
1406+ B6AE              ; Does not affect the file pointer.
1407+ B6AE              ;
1408+ B6AE              ; Does not consider soft-EOF.
1409+ B6AE              ;
1410+ B6AE              ; ENTRY CONDITIONS
1411+ B6AE              ;         B = File number
1412+ B6AE              ;
1413+ B6AE              ; EXIT CONDTITIONS
1414+ B6AE              ;         If OK:
1415+ B6AE              ;                 Carry true
1416+ B6AE              ;                 A corrupt
1417+ B6AE              ;                 E HL = File pointer 000000h...FFFFFFh (0...16777215)
1418+ B6AE              ;                 (E holds most significant byte; L holds leat
1419+ B6AE              ;                 significant byte)
1420+ B6AE              ;         Otherwise:
1421+ B6AE              ;                 Carry false
1422+ B6AE              ;                 A = Error code
1423+ B6AE              ;                 E HL Corrupt
1424+ B6AE              ;         Always:
1425+ B6AE              ;                 BC D IX corrupt
1426+ B6AE              ;                 All other registers preserved
1427+ B6AE              ;
1428+ B6AE              ;
1429+ B6AE              dos_get_1346: equ 0x013C ; (316)
1430+ B6AE              ;
1431+ B6AE              ; Get the current location of the cache and RAMdisk.
1432+ B6AE              ;
1433+ B6AE              ; Pages 1, 3, 4, 6 are considered as an array of 128 sector buffers
1434+ B6AE              ; (numbered 0...127), each of 512 bytes. The cache and RAMdisk occupy
1435+ B6AE              ; two separate (contiguous) areas of this array.
1436+ B6AE              ;
1437+ B6AE              ; Any unused sector buffers may be used by the caller.
1438+ B6AE              ;
1439+ B6AE              ; Note that the sizes may be smaller than those specified in DOS SET
1440+ B6AE              ; 1346, as there is an (unpublished) maximum size of cache and a minimum
1441+ B6AE              ; size of RAMdisk (4 sectors).
1442+ B6AE              ;
1443+ B6AE              ; ENTRY CONDITIONS
1444+ B6AE              ;         None
1445+ B6AE              ;
1446+ B6AE              ; EXIT CONDITIONS
1447+ B6AE              ;                 D = First buffer of cache
1448+ B6AE              ;                 E = Number of cache sector buffers
1449+ B6AE              ;                 H = First buffer of RAMdisk
1450+ B6AE              ;                 L = Number of RAMdisk sector buffers
1451+ B6AE              ;         Always:
1452+ B6AE              ;                 AF BC IX corrupt
1453+ B6AE              ;                 All other registers preserved
1454+ B6AE              ;
1455+ B6AE              ;
1456+ B6AE              dos_set_1346: equ 0x013F ; (319)
1457+ B6AE              ;
1458+ B6AE              ; Rebuild the sector cache and RAMdisk.
1459+ B6AE              ;
1460+ B6AE              ; This routine is used to make some store available to the user, or to
1461+ B6AE              ; return store to DOS.
1462+ B6AE              ;
1463+ B6AE              ; Note that if the RAMdisk is moved, ot its size is changed, then all
1464+ B6AE              ; files thereon are erased.
1465+ B6AE              ;
1466+ B6AE              ; Pages 1, 3, 4, 6 are considered as an array of 128 sector buffers
1467+ B6AE              ; (numbered 0...127), each of 512 bytes. The cache and RAMdisk occupy
1468+ B6AE              ; two separate (contiguous) areas of this array.
1469+ B6AE              ;
1470+ B6AE              ; The location and size of the cache and RAMdisk can be specified
1471+ B6AE              ; separately; any remaining buffers are unused by DOS and are available
1472+ B6AE              ; to the caller.
1473+ B6AE              ;
1474+ B6AE              ; Note that the sizes actually used may be smaller than those specified
1475+ B6AE              ; as in practice, there is a maximum cache size and a minimum size of
1476+ B6AE              ; RAMdisk (4 sectors).
1477+ B6AE              ;
1478+ B6AE              ; A cache size of 0 will still work but will seriously impair the floppy
1479+ B6AE              ; disk performance.
1480+ B6AE              ;
1481+ B6AE              ; This routine will fail if there are any files open on drive M:.
1482+ B6AE              ;
1483+ B6AE              ; ENTRY CONDITIONS
1484+ B6AE              ;         D = First buffer for cache
1485+ B6AE              ;         E = Number of cache sector buffers
1486+ B6AE              ;         H = First buffer for RAMdisk
1487+ B6AE              ;         L = Number of RAMdisk sector buffers
1488+ B6AE              ;         (Note that E + L <= 128)
1489+ B6AE              ;
1490+ B6AE              ; EXIT CONDITIONS
1491+ B6AE              ;         If OK:
1492+ B6AE              ;                 Carry true
1493+ B6AE              ;                 A corrupt
1494+ B6AE              ;         Otherwise:
1495+ B6AE              ;                 Carry false
1496+ B6AE              ;                 A = Error code
1497+ B6AE              ;         Always:
1498+ B6AE              ;                 BC DE HL IX corrupt
1499+ B6AE              ;                 All other registers preserved
1500+ B6AE              ;
1501+ B6AE              ;
1502+ B6AE
1503+ B6AE              dos_flush: equ 0x0142 ; (322)
1504+ B6AE
1505+ B6AE              ; Write any pending headers, data, directory entries for this drive.
1506+ B6AE              ;
1507+ B6AE              ; This routine ensures that the disk is up to date. It can be called at
1508+ B6AE              ; any time, even when files are open.
1509+ B6AE              ;
1510+ B6AE              ; ENTRY CONDITIONS
1511+ B6AE              ;         A = Drive, ASCII 'A'...'P'
1512+ B6AE              ;
1513+ B6AE              ; EXIT CONDITIONS
1514+ B6AE              ;         If OK:
1515+ B6AE              ;                 Carry true
1516+ B6AE              ;                 A corrupt
1517+ B6AE              ;         Otherwise:
1518+ B6AE              ;                 Carry false
1519+ B6AE              ;                 A = Error code
1520+ B6AE              ;         Always:
1521+ B6AE              ;                 BC DE HL IX corrupt
1522+ B6AE              ;                 All other registers preserved
1523+ B6AE              ;
1524+ B6AE              ;
1525+ B6AE
1526+ B6AE              dos_set_access: equ 0x0145 ; (325)
1527+ B6AE
1528+ B6AE              ; Try to change the access mode of an open file.
1529+ B6AE              ;
1530+ B6AE              ; This routine will fail if the file is already open, in an incompatible
1531+ B6AE              ; access mode, or if write access is required for a read-only file or
1532+ B6AE              ; disk.
1533+ B6AE              ;
1534+ B6AE              ; ENTRY CONDITIONS
1535+ B6AE              ;         B = File number
1536+ B6AE              ;         C = Access mode required
1537+ B6AE              ;                 Bits 0...2 values:
1538+ B6AE              ;                         1 = exclusive-read
1539+ B6AE              ;                         2 = exclusive-write
1540+ B6AE              ;                         3 = exclusive-read-write
1541+ B6AE              ;                         5 = shared-read
1542+ B6AE              ;                         (all other bit settings reserved)
1543+ B6AE              ;                 Bits 3...7 = 0 (reserved)
1544+ B6AE              ;
1545+ B6AE              ; EXIT CONDITIONS
1546+ B6AE              ;         If OK:
1547+ B6AE              ;                 Carry true
1548+ B6AE              ;                 A corrupt
1549+ B6AE              ;         Otherwise:
1550+ B6AE              ;                 Carry false
1551+ B6AE              ;                 A = Error code
1552+ B6AE              ;         Always:
1553+ B6AE              ;                 BC DE HL IX corrupt
1554+ B6AE              ;                 All other registers preserved
1555+ B6AE              ;
1556+ B6AE              ;
1557+ B6AE
1558+ B6AE              dos_set_attributes: equ 0x0148 ; (328)
1559+ B6AE
1560+ B6AE              ; Set a file's attributes.
1561+ B6AE              ;
1562+ B6AE              ; Only the file attributes f1'...f4', t1'...t3' can be set or
1563+ B6AE              ; cleared. The interface attributes f5'...f8' are always 0.
1564+ B6AE              ;
1565+ B6AE              ; This routine first sets the attributes specified in D, then clears
1566+ B6AE              ; those attributes specified in E, i.e. E has priority.
1567+ B6AE              ;
1568+ B6AE              ; ENTRY CONDITIONS
1569+ B6AE              ;         D = Attributes to set
1570+ B6AE              ;                 bit 0 = t3' Archive
1571+ B6AE              ;                 bit 1 = t2' System
1572+ B6AE              ;                 bit 2 = t1' Read-only
1573+ B6AE              ;                 bit 3 = f4'
1574+ B6AE              ;                 bit 4 = f3'
1575+ B6AE              ;                 bit 5 = f2'
1576+ B6AE              ;                 bit 6 = f1'
1577+ B6AE              ;         E = Attributes to clear
1578+ B6AE              ;                 bit 0 = t3' Archive
1579+ B6AE              ;                 bit 1 = t2' System
1580+ B6AE              ;                 bit 2 = t1' Read-only
1581+ B6AE              ;                 bit 3 = f4'
1582+ B6AE              ;                 bit 4 = f3'
1583+ B6AE              ;                 bit 5 = f2'
1584+ B6AE              ;                 bit 6 = f1'
1585+ B6AE              ;         HL = Address of filename (wildcards permitted)
1586+ B6AE              ;
1587+ B6AE              ; EXIT CONDITIONS
1588+ B6AE              ;         If OK:
1589+ B6AE              ;                 Carry true
1590+ B6AE              ;                 A corrupt
1591+ B6AE              ;         Otherwise:
1592+ B6AE              ;                 Carry false
1593+ B6AE              ;                 A = Error code
1594+ B6AE              ;         Always:
1595+ B6AE              ;                 BC DE HL IX corrupt
1596+ B6AE              ;                 All other registers preserved
1597+ B6AE              ;
1598+ B6AE              ;
1599+ B6AE
1600+ B6AE              dos_open_drive: equ 0x014B ; (331)
1601+ B6AE
1602+ B6AE              ; Open the disk in this drive as a single file.
1603+ B6AE              ;
1604+ B6AE              ; The whole disk is presented as a single file regardless of any real
1605+ B6AE              ; files on the disk. This routine can be used to examine/poke
1606+ B6AE              ; directories, files, etc. It should not be used by the uninitiated, the
1607+ B6AE              ; faint hearted, or by anyone who values their files!
1608+ B6AE              ;
1609+ B6AE              ; Sets file pointer to 000000h (0).
1610+ B6AE              ;
1611+ B6AE              ; If there are any files open on this drive from other file numbers with
1612+ B6AE              ; shared-read access, then the disk can only be opened with shared-read
1613+ B6AE              ; access from this file number.
1614+ B6AE              ;
1615+ B6AE              ; If there are any file open on this drive from other file numbers with
1616+ B6AE              ; exclusive access, then the disk cannot be opened from this file
1617+ B6AE              ; number.
1618+ B6AE              ;
1619+ B6AE              ; ENTRY CONDITIONS
1620+ B6AE              ;         A = Drive, ASCII 'A'...'P'
1621+ B6AE              ;         B = File number
1622+ B6AE              ;         C = Access mode required
1623+ B6AE              ;                 Bits 0...2 values:
1624+ B6AE              ;                         1 = exclusive-read
1625+ B6AE              ;                         2 = exclusive-write
1626+ B6AE              ;                         3 = exclusive-read-write
1627+ B6AE              ;                         5 = shared-read
1628+ B6AE              ;                         (all other bit settings reserved)
1629+ B6AE              ;                 Bits 3...7 = 0 (reserved)
1630+ B6AE              ;
1631+ B6AE              ; EXIT CONDITIONS
1632+ B6AE              ;         If OK:
1633+ B6AE              ;                 Carry true
1634+ B6AE              ;                 A corrupt
1635+ B6AE              ;         Otherwise:
1636+ B6AE              ;                 Carry false
1637+ B6AE              ;                 A = Error code
1638+ B6AE              ;         Always:
1639+ B6AE              ;                 BC DE HL corrupt
1640+ B6AE              ;                 All other registers preserved
1641+ B6AE              ;
1642+ B6AE              ;
1643+ B6AE
1644+ B6AE              dos_set_message: equ 0x014E ; (334)
1645+ B6AE
1646+ B6AE              ; Enable/disable disk error messages.
1647+ B6AE              ;
1648+ B6AE              ; This should be used to make +3DOS aware of your own ALERT subroutine.
1649+ B6AE              ; When +3DOS detects an error, it will call your ALERT subroutine,
1650+ B6AE              ; passing to it the values documented below. The ALERT subroutine should
1651+ B6AE              ; print the text of the message that +3DOS passes it, then should wait
1652+ B6AE              ; for the user to press a key. If the key is in the reply string (that
1653+ B6AE              ; +3DOS also passes - version V1.0 only), then a 'ret' should be made
1654+ B6AE              ; with A = 0, 1 or 2, or containing the character (depending on the
1655+ B6AE              ; version of +3DOS).
1656+ B6AE              ;
1657+ B6AE              ; ENTRY CONDITIONS
1658+ B6AE              ;         A = Enable/disable
1659+ B6AE              ;                 FFh (255) = enable
1660+ B6AE              ;                 00h (0) = disable
1661+ B6AE              ;         HL = Address of ALERT routine (if enabled)
1662+ B6AE              ;
1663+ B6AE              ; EXIT CONDITIONS
1664+ B6AE              ;         HL = address of previous ALERT routine (0 if none)
1665+ B6AE              ; Always:
1666+ B6AE              ;         AF BC DE IX corrupt
1667+ B6AE              ;         All other registers preserved
1668+ B6AE              ;
1669+ B6AE              ; NOTE
1670+ B6AE              ;
1671+ B6AE              ;         Note that if you are substituting your own ALERT subroutine,
1672+ B6AE              ;         the 'entry conditions' are the conditions passed to your
1673+ B6AE              ;         subroutine and the 'exit conditions' are the values that your
1674+ B6AE              ;         subroutine must produce and the registers you are allowed to
1675+ B6AE              ;         corrupt.
1676+ B6AE              ;
1677+ B6AE              ;         Note that there are two routine interfaces for ALERT. The
1678+ B6AE              ;         first, (which is used in machines with +3DOS version V1.0)
1679+ B6AE              ;         should have the entry and exit conditions shown ahead.
1680+ B6AE              ;
1681+ B6AE              ;         ALERT (VERSION V1.0 ONLY)
1682+ B6AE              ;
1683+ B6AE              ;         ENTRY CONDITIONS
1684+ B6AE              ;                 DE = Address of reply string (in page 7) terminated by
1685+ B6AE              ;                         FFh (255)
1686+ B6AE              ;                 HL = Address of error message (in page 7) terminated
1687+ B6AE              ;                         by FFh (255)
1688+ B6AE              ;
1689+ B6AE              ;         EXIT CONDITIONS
1690+ B6AE              ;                         A = Reply character
1691+ B6AE              ;                 Always:
1692+ B6AE              ;                         F BC DE HL IX corrupt
1693+ B6AE              ;                         All other registers preserved
1694+ B6AE              ;
1695+ B6AE              ;         The second version of ALERT, which allows the user to provide
1696+ B6AE              ;         non-UK error messages and is generally more flexible, is
1697+ B6AE              ;         present in +3DOS versions V1.1 and upwards.
1698+ B6AE              ;
1699+ B6AE              ;         ALERT (VERSION V1.1 AND ABOVE)
1700+ B6AE              ;
1701+ B6AE              ;         ENTRY CONDITIONS
1702+ B6AE              ;                 B = Error number
1703+ B6AE              ;                 C = Drive, ASCII 'A'...'P'
1704+ B6AE              ;                 D = Logical track (if required for message)
1705+ B6AE              ;                 E = Logical sector (if required for message)
1706+ B6AE              ;                 HL = Address of UK error message (page 7) terminated
1707+ B6AE              ;                         by FFh (255)
1708+ B6AE              ;
1709+ B6AE              ;         EXIT CONDITIONS
1710+ B6AE              ;                         A = Reply
1711+ B6AE              ;                                 0 = cancel
1712+ B6AE              ;                                 1 = retry
1713+ B6AE              ;                                 2 = ignore
1714+ B6AE              ;                 Always:
1715+ B6AE              ;                         F BC DE HL IX corrupt
1716+ B6AE              ;                         All other registers preserved
1717+ B6AE              ;
1718+ B6AE              ;         If you provide an ALERT function, you should have two
1719+ B6AE              ;         subroutines (or one with switchable entry and exit
1720+ B6AE              ;         conditions), and check the +3DOS version number before
1721+ B6AE              ;         deciding which one to use.
1722+ B6AE              ;
1723+ B6AE              ;
1724+ B6AE
1725+ B6AE              dos_ref_xdpb: equ 0x0151 ; (337)
1726+ B6AE
1727+ B6AE              ; Point at the XDPB for this drive. (The XDPB is required by the floppy
1728+ B6AE              ; disk driver routines.)
1729+ B6AE              ;
1730+ B6AE              ; ENTRY CONDITIONS
1731+ B6AE              ;         A = Drive, ASCII 'A'...'P'
1732+ B6AE              ;
1733+ B6AE              ; EXIT CONDITIONS
1734+ B6AE              ;         If OK:
1735+ B6AE              ;                 Carry true
1736+ B6AE              ;                 A corrupt
1737+ B6AE              ;                 IX = Address of XDPB
1738+ B6AE              ;         Otherwise:
1739+ B6AE              ;                 Carry false
1740+ B6AE              ;                 A = Error code
1741+ B6AE              ;                 IX corrupt
1742+ B6AE              ;         Always:
1743+ B6AE              ;                 BC DE HL corrupt
1744+ B6AE              ;                 All other registers preserved
1745+ B6AE              ;
1746+ B6AE              ;
1747+ B6AE
1748+ B6AE              dos_map_b: equ 0x0154 ; (340)
1749+ B6AE
1750+ B6AE              ; Map drive B: to unit 0 or unit 1. (This routine will fail if drive B:
1751+ B6AE              ; has files open.)
1752+ B6AE              ;
1753+ B6AE              ; If mapping B: to unit 0, then each time unit 0 is accessed, a check is
1754+ B6AE              ; made that the drive mapping is correct. If it isn't, then a reverse
1755+ B6AE              ; call to CHANGE DISK is made, to ask the user to change the disk in
1756+ B6AE              ; unit 0.
1757+ B6AE              ;
1758+ B6AE              ; If mapping B: to unit 1, then if unit 1 does not exist, drive B: is
1759+ B6AE              ; disabled.
1760+ B6AE              ;
1761+ B6AE              ; ENTRY CONDITIONS
1762+ B6AE              ;         C = Unit (0/1)
1763+ B6AE              ;         HL = Address of CHANGE DISK routine if unit = 0
1764+ B6AE              ;
1765+ B6AE              ; EXIT CONDITIONS
1766+ B6AE              ;         If OK:
1767+ B6AE              ;                 Carry true
1768+ B6AE              ;                 A corrupt
1769+ B6AE              ;                 HL = Address of previous CHANGE DISK routine (0 if
1770+ B6AE              ;                         none)
1771+ B6AE              ;         Otherwise:
1772+ B6AE              ;                 Carry false
1773+ B6AE              ;                 A HL corrupt
1774+ B6AE              ;         Always
1775+ B6AE              ;                 BC DE IX corrupt
1776+ B6AE              ;                 All other registers preserved
1777+ B6AE              ;
1778+ B6AE              ; NOTE
1779+ B6AE              ;         The definition of the subroutine CHANGE DISK is as shown
1780+ B6AE              ;         ahead. Note that if you are substituting your own CHANGE DISK
1781+ B6AE              ;         subroutine, the 'entry conditions' are the conditions passed
1782+ B6AE              ;         to your subroutine, and the 'exit conditions' are registers
1783+ B6AE              ;         you are allowed to corrupt.
1784+ B6AE              ;
1785+ B6AE              ;         CHANGE DISK
1786+ B6AE              ;
1787+ B6AE              ;         Ask the user to change the disk in unit 0.
1788+ B6AE              ;
1789+ B6AE              ;         Wait for the user to acknowledge the change.
1790+ B6AE              ;
1791+ B6AE              ;         ENTRY CONDITIONS
1792+ B6AE              ;                 A = Logical drive, ASCII 'A'...'P'
1793+ B6AE              ;                 HL = Address of message (page 7) terminated by FFh
1794+ B6AE              ;                         (255)
1795+ B6AE              ;
1796+ B6AE              ;         EXIT CONDITIONS
1797+ B6AE              ;                 Always:
1798+ B6AE              ;                         AF BC DE HL IX corrupt
1799+ B6AE              ;                         All other registers preserved
1800+ B6AE              ;
1801+ B6AE              ;
1802+ B6AE              ;
1803+ B6AE              ; Low level floppy disk driving routines
1804+ B6AE              ;
1805+ B6AE              ; The following are the floppy disk driver routines. The unit number is
1806+ B6AE              ; 0...3 for the uPD765A. On the +3, unit 0 is drive A: and unit 1 is
1807+ B6AE              ; drive B:, or optionally, both A: and B: may be mapped onto unit 0.
1808+ B6AE              ; Units 2 and 3 are not used.
1809+ B6AE              ;
1810+ B6AE              ; With the exception of DD INTERFACE, none of these routines may be
1811+ B6AE              ; called if the floppy disk interface is not present.
1812+ B6AE              ;
1813+ B6AE              ; All routines assume that interrupts are enabled on entry, and will
1814+ B6AE              ; still be enabled on exit.
1815+ B6AE              ;
1816+ B6AE
1817+ B6AE              dd_interface: equ 0x0157 ; (343)
1818+ B6AE
1819+ B6AE              ; Is the floppy disk drive interface present? (This information is also
1820+ B6AE              ; held by BASIC in bit 4 of the FLAGS3 system variable.)
1821+ B6AE              ;
1822+ B6AE              ; ENTRY CONDITIONS
1823+ B6AE              ;         None
1824+ B6AE              ;
1825+ B6AE              ; EXIT CONDITIONS
1826+ B6AE              ;         If present:
1827+ B6AE              ;                 Carry true
1828+ B6AE              ;         Otherwise:
1829+ B6AE              ;                 Carry false
1830+ B6AE              ;         Always:
1831+ B6AE              ;                 A BC DE HL IX corrupt
1832+ B6AE              ;                 All other registers preserved
1833+ B6AE              ;
1834+ B6AE
1835+ B6AE              dd_init: equ 0x015a ; (346)
1836+ B6AE
1837+ B6AE              ; Initialise the disk driver.
1838+ B6AE              ;
1839+ B6AE              ; ENTRY CONDITIONS
1840+ B6AE              ;         None
1841+ B6AE              ;
1842+ B6AE              ; EXIT CONDITIONS
1843+ B6AE              ;         Always:
1844+ B6AE              ;                 AF BC DE HL IX corrupt
1845+ B6AE              ;                 All other registers preserved
1846+ B6AE              ;
1847+ B6AE
1848+ B6AE              dd_setup: equ 0x015d ; (349)
1849+ B6AE
1850+ B6AE              ; Set up disk parameters.
1851+ B6AE              ;
1852+ B6AE              ; Send a specify command.
1853+ B6AE              ;
1854+ B6AE              ; Parameter block format:
1855+ B6AE              ;
1856+ B6AE              ;         Byte 0 - Motor on time (in 100 mS units)
1857+ B6AE              ;         Byte 1 - Motor off time (in 100 mS units)
1858+ B6AE              ;         Byte 2 - Write off time (in 10 uS units)
1859+ B6AE              ;         Byte 3 - Head settle time (in mS units)
1860+ B6AE              ;         Byte 4 - Step rate (in mS units)
1861+ B6AE              ;         Byte 5 - Head unload time (in 32 mS units, 32...480)
1862+ B6AE              ;         Byte 6 - (Head load time x 2) + 1, (in 4 mS units, 4...508)
1863+ B6AE              ;
1864+ B6AE              ; ENTRY CONDITIONS
1865+ B6AE              ;         HL = Address of parameter block
1866+ B6AE              ;
1867+ B6AE              ; EXIT CONDITIONS
1868+ B6AE              ;         Always:
1869+ B6AE              ;                 AF BC DE HL IX corrupt
1870+ B6AE              ;                 All other registers preserved
1871+ B6AE              ;
1872+ B6AE
1873+ B6AE              dd_set_retry: equ 0x0160 ; (352)
1874+ B6AE
1875+ B6AE              ; Set the try and retry count. (A value of 1 will try the operation
1876+ B6AE              ; once, i.e. no retry.)
1877+ B6AE              ;
1878+ B6AE              ; ENTRY CONDITIONS
1879+ B6AE              ;         A = Try/retry count >= 1
1880+ B6AE              ;
1881+ B6AE              ; EXIT CONDITIONS
1882+ B6AE              ;         Always:
1883+ B6AE              ;                 AF BC DE HL IX corrupt
1884+ B6AE              ;                 All other registers preserved
1885+ B6AE              ;
1886+ B6AE
1887+ B6AE              dd_read_sector: equ 0x0163 ; (355)
1888+ B6AE
1889+ B6AE              ; Read a sector.
1890+ B6AE              ;
1891+ B6AE              ; ENTRY CONDITIONS
1892+ B6AE              ;         B = Page for C000h (49152)...FFFFh (65535)
1893+ B6AE              ;         C = Unit (0/1)
1894+ B6AE              ;         D = Logical track, 0 base
1895+ B6AE              ;         E = Logical sector, 0 base
1896+ B6AE              ;         HL = Address of buffer
1897+ B6AE              ;         IX = Address of XDPB
1898+ B6AE              ;
1899+ B6AE              ; EXIT CONDITIONS
1900+ B6AE              ;         If OK:
1901+ B6AE              ;                 Carry true
1902+ B6AE              ;                 A corrupt
1903+ B6AE              ;         Otherwise:
1904+ B6AE              ;                 Carry false
1905+ B6AE              ;                 A = Error code
1906+ B6AE              ;         Always:
1907+ B6AE              ;                 BC DE HL IX corrupt
1908+ B6AE              ;                 All other registers preserved
1909+ B6AE              ;
1910+ B6AE
1911+ B6AE              dd_write_sector: equ 0x0166 ; (358)
1912+ B6AE
1913+ B6AE              ; Write a sector.
1914+ B6AE              ;
1915+ B6AE              ; ENTRY CONDITIONS
1916+ B6AE              ;         B = Page for C000h (49152)...FFFFh (65535)
1917+ B6AE              ;         C = Unit (0/1)
1918+ B6AE              ;         D = Logical track, 0 base
1919+ B6AE              ;         E = Logical sector, 0 base
1920+ B6AE              ;         HL = Address of buffer
1921+ B6AE              ;         IX = Address of XDPB
1922+ B6AE              ;
1923+ B6AE              ; EXIT CONDITIONS
1924+ B6AE              ;         If OK:
1925+ B6AE              ;                 Carry true
1926+ B6AE              ;                 A corrupt
1927+ B6AE              ;         Otherwise:
1928+ B6AE              ;                 Carry false
1929+ B6AE              ;                 A = Error code
1930+ B6AE              ;         Always:
1931+ B6AE              ;                 BC DE HL IX corrupt
1932+ B6AE              ;                 All other registers preserved
1933+ B6AE              ;
1934+ B6AE
1935+ B6AE              dd_check_sector: equ 0x0169 ; (361)
1936+ B6AE
1937+ B6AE              ; Check a sector. (Uses the uPD765A scan equal command.)
1938+ B6AE              ;
1939+ B6AE              ; Checks that the sector on disk is the same as the copy in memory.
1940+ B6AE              ;
1941+ B6AE              ; Note that FFh (255) on disk or in memory always matches anything (see
1942+ B6AE              ; uPD765A specification for further details).
1943+ B6AE              ;
1944+ B6AE              ; ENTRY CONDITIONS
1945+ B6AE              ;         B = Page for C000h (49152)...FFFFh (65535)
1946+ B6AE              ;         C = Unit (0/1)
1947+ B6AE              ;         D = Logical track, 0 base
1948+ B6AE              ;         E = Logical sector, 0 base
1949+ B6AE              ;         HL = Address of copy of sector
1950+ B6AE              ;         IX = Address of XDPB
1951+ B6AE              ;
1952+ B6AE              ; EXIT CONDITIONS
1953+ B6AE              ;         If OK (equal):
1954+ B6AE              ;                 Carry true
1955+ B6AE              ;                 Zero true
1956+ B6AE              ;                 A corrupt
1957+ B6AE              ;         If OK (not equal):
1958+ B6AE              ;                 Carry true
1959+ B6AE              ;                 Zero false
1960+ B6AE              ;                 A corrupt
1961+ B6AE              ;         Otherwise:
1962+ B6AE              ;                 Carry false
1963+ B6AE              ;                 A = Error code
1964+ B6AE              ;         Always:
1965+ B6AE              ;                 BC DE HL IX corrupt
1966+ B6AE              ;                 All other registers preserved
1967+ B6AE              ;
1968+ B6AE
1969+ B6AE              dd_format: equ 0x016c ; (364)
1970+ B6AE
1971+ B6AE              ; Format a track. (Uses the uPD765A format track command.)
1972+ B6AE              ;
1973+ B6AE              ; Buffer contains 4 bytes for each sector as follows:
1974+ B6AE              ;
1975+ B6AE              ;         C - Track number        (0...39)
1976+ B6AE              ;         H - Head number         (always 0 on the +3's single-sided
1977+ B6AE              ;                                 drives)
1978+ B6AE              ;         R - Sector number       (0...255)
1979+ B6AE              ;         N - Log2(sector size)-7 (2 for 512 byte sectors)
1980+ B6AE              ;
1981+ B6AE              ; ENTRY CONDITIONS
1982+ B6AE              ;         B = Page for C000h (49152)...FFFFh (65535)
1983+ B6AE              ;         C = Unit (0/1)
1984+ B6AE              ;         D = Logical track, 0 base
1985+ B6AE              ;         E = Filler byte, usually E5h (229)
1986+ B6AE              ;         HL = Address of format buffer
1987+ B6AE              ;         IX = Address of XDPB
1988+ B6AE              ;
1989+ B6AE              ; EXIT CONDITIONS
1990+ B6AE              ;         If OK:
1991+ B6AE              ;                 Carry true
1992+ B6AE              ;                 A corrupt
1993+ B6AE              ;         Otherwise:
1994+ B6AE              ;                 Carry false
1995+ B6AE              ;                 A = Error code
1996+ B6AE              ;         Always:
1997+ B6AE              ;                 BC DE HL IX corrupt
1998+ B6AE              ;                 All other registers preserved
1999+ B6AE              ;
2000+ B6AE
2001+ B6AE              dd_read_id: equ 0x016f ; (367)
2002+ B6AE
2003+ B6AE              ; Read a sector identifier.
2004+ B6AE              ;
2005+ B6AE              ; ENTRY CONDITIONS
2006+ B6AE              ;         C = Unit (0/1)
2007+ B6AE              ;         D = Logical track, 0 base
2008+ B6AE              ;         IX = Address of XDPB
2009+ B6AE              ;
2010+ B6AE              ; EXIT CONDITIONS
2011+ B6AE              ;         If OK:
2012+ B6AE              ;                 Carry true
2013+ B6AE              ;                 A = Sector number from identifier
2014+ B6AE              ;         Otherwise:
2015+ B6AE              ;                 Carry false
2016+ B6AE              ;                 A = Error code
2017+ B6AE              ;         Always:
2018+ B6AE              ;                 HL = Address of result buffer in page 7
2019+ B6AE              ;                 BC DE IX corrupt
2020+ B6AE              ;                 All other registers preserved
2021+ B6AE              ;
2022+ B6AE
2023+ B6AE              dd_test_unsuitable: equ 0x0172 ; (370)
2024+ B6AE
2025+ B6AE              ; Check that disk is suitable to write to.
2026+ B6AE              ;
2027+ B6AE              ; A single track disk will not work in a double track drive, and vice
2028+ B6AE              ; versa.
2029+ B6AE              ;
2030+ B6AE              ; ENTRY CONDITIONS
2031+ B6AE              ;         C = Unit (0/1)
2032+ B6AE              ;         IX = Address of XDPB
2033+ B6AE              ;
2034+ B6AE              ; EXIT CONDITIONS
2035+ B6AE              ;         If suitable:
2036+ B6AE              ;                 Carry true
2037+ B6AE              ;                 A corrupt
2038+ B6AE              ;         Otherwise:
2039+ B6AE              ;                 Carry false
2040+ B6AE              ;                 A = Error code
2041+ B6AE              ;         Always:
2042+ B6AE              ;                 BC DE HL IX corrupt
2043+ B6AE              ;                 All other registers preserved
2044+ B6AE              ;
2045+ B6AE
2046+ B6AE              dd_login: equ 0x0175 ; (373)
2047+ B6AE
2048+ B6AE              ; Log in a new disk.
2049+ B6AE              ;
2050+ B6AE              ; Initialise the XDPB.
2051+ B6AE              ;
2052+ B6AE              ; This routine does not affect or consider the freeze flag.
2053+ B6AE              ;
2054+ B6AE              ; ENTRY CONDITIONS
2055+ B6AE              ;         C = Unit (0/1)
2056+ B6AE              ;         IX = Address of destination XDPB
2057+ B6AE              ;
2058+ B6AE              ; EXIT CONDITIONS
2059+ B6AE              ;         If OK:
2060+ B6AE              ;                 Carry true
2061+ B6AE              ;                 A = Disk type
2062+ B6AE              ;                 DE = Size of allocation vector
2063+ B6AE              ;                 HL = Size of hash table
2064+ B6AE              ;         Otherwise:
2065+ B6AE              ;                 Carry false
2066+ B6AE              ;                 A = Error code
2067+ B6AE              ;                 DE HL corrupt
2068+ B6AE              ;         Always:
2069+ B6AE              ;                 BC IX corrupt
2070+ B6AE              ;                 All other registers preserved
2071+ B6AE              ;
2072+ B6AE
2073+ B6AE              dd_sel_format: equ 0x0178 ; (376)
2074+ B6AE
2075+ B6AE              ; Initialise an XDPB for a standard format.
2076+ B6AE              ;
2077+ B6AE              ; This routine does not affect or consider the freeze flag.
2078+ B6AE              ;
2079+ B6AE              ; ENTRY CONDITIONS
2080+ B6AE              ;         A = Disk type
2081+ B6AE              ;                 0 = Spectrum +3 format (AMSTRAD PCW range - DD SS ST)
2082+ B6AE              ;                 1 = AMSTRAD CPC range system format
2083+ B6AE              ;                 2 = AMSTRAD CPC range data-only format
2084+ B6AE              ;                 3 = AMSTRAD PCW range - DD SS DT
2085+ B6AE              ;                 (other values = error)
2086+ B6AE              ;         IX = Address of XDPB
2087+ B6AE              ;
2088+ B6AE              ; EXIT CONDITIONS
2089+ B6AE              ;         If OK:
2090+ B6AE              ;                 Carry true
2091+ B6AE              ;                 A = Disk type
2092+ B6AE              ;                 DE = Size of 2 bit allocation vector
2093+ B6AE              ;                 HL = Size of hash table
2094+ B6AE              ;         Otherwise:
2095+ B6AE              ;                 Carry false
2096+ B6AE              ;                 A = Error code
2097+ B6AE              ;                 DE HL corrupt
2098+ B6AE              ;         Always:
2099+ B6AE              ;                 BC IX corrupt
2100+ B6AE              ;                 All other registers preserved
2101+ B6AE              ;
2102+ B6AE
2103+ B6AE              dd_ask_1: equ 0x017b ; (379)
2104+ B6AE
2105+ B6AE              ; Check to see if unit 1 is present. (BASIC holds this information in
2106+ B6AE              ; bit 5 of the FLAGS3 system variable.)
2107+ B6AE              ;
2108+ B6AE              ; Turn motor on.
2109+ B6AE              ;
2110+ B6AE              ; Fetch drive status.
2111+ B6AE              ;
2112+ B6AE              ; If unit 1 is not-ready and write-protected, then unit 1 is missing.
2113+ B6AE              ; Start motor off timeout.
2114+ B6AE              ;
2115+ B6AE              ; Note that this routine can be fooled by disks which are almost, but
2116+ B6AE              ; not quite, inserted in the drive.
2117+ B6AE              ;
2118+ B6AE              ; This routine assumes that when a disk is not in the drive, then
2119+ B6AE              ; write-protect is true. This is indeed the case for 3 inch and 8 inch
2120+ B6AE              ; disk drives, but is not the case for 5 1/4 inch disk drives.
2121+ B6AE              ;
2122+ B6AE              ; ENTRY CONDITIONS
2123+ B6AE              ;         None
2124+ B6AE              ;
2125+ B6AE              ; EXIT CONDITIONS
2126+ B6AE              ;         If unit 1 present:
2127+ B6AE              ;                 Carry true
2128+ B6AE              ;         Otherwise:
2129+ B6AE              ;                 Carry false
2130+ B6AE              ;         Always:
2131+ B6AE              ;                 A BC DE HL IX corrupt
2132+ B6AE              ;                 All other registers preserved
2133+ B6AE              ;
2134+ B6AE
2135+ B6AE              dd_drive_status: equ 0x017e ; (382)
2136+ B6AE
2137+ B6AE              ; Issue a sense drive status command.
2138+ B6AE              ;
2139+ B6AE              ; ENTRY CONDITIONS
2140+ B6AE              ;         C = Unit/head
2141+ B6AE              ;                 bits 0...1 = unit
2142+ B6AE              ;                 bit 2 = head
2143+ B6AE              ;                 bits 3...7 = 0
2144+ B6AE              ;
2145+ B6AE              ; EXIT CONDITIONS
2146+ B6AE              ;                 A = ST3 (Status register 3 of uPD765A)
2147+ B6AE              ;         Always:
2148+ B6AE              ;                 F BC DE HL IX corrupt
2149+ B6AE              ;                 All other registers preserved
2150+ B6AE              ;
2151+ B6AE
2152+ B6AE              dd_equipment: equ 0x0181 ; (385)
2153+ B6AE
2154+ B6AE              ; Ask what type of drive this is (i.e. single/double track,
2155+ B6AE              ; single/double sided).
2156+ B6AE              ;
2157+ B6AE              ; Track information can only be determined once a disk has been seen and
2158+ B6AE              ; had its type identified during logging in.
2159+ B6AE              ;
2160+ B6AE              ; Side information can only be detected after a double sided disk has
2161+ B6AE              ; been seen and has its type identified during logging in.
2162+ B6AE              ;
2163+ B6AE              ; ENTRY CONDITIONS
2164+ B6AE              ;         C = Unit (0/1)
2165+ B6AE              ;         IX = Address of XDPB
2166+ B6AE              ;
2167+ B6AE              ; EXIT CONDITIONS
2168+ B6AE              ;                 A = Side/track information
2169+ B6AE              ;                         bits 0...1 = side information
2170+ B6AE              ;                                 0 = unknown
2171+ B6AE              ;                                 1 = single sided
2172+ B6AE              ;                                 2 = double sided
2173+ B6AE              ;                         bits 2...3 = track information
2174+ B6AE              ;                                 0 = unknown
2175+ B6AE              ;                                 1 = single track
2176+ B6AE              ;                                 2 = double track
2177+ B6AE              ;         Always:
2178+ B6AE              ;                 F BC DE HL IX corrupt
2179+ B6AE              ;                 All other registers preserved
2180+ B6AE              ;
2181+ B6AE
2182+ B6AE              dd_encode: equ 0x0184 ; (388)
2183+ B6AE
2184+ B6AE              ; Set the copy protection ENCODE subroutine.
2185+ B6AE              ;
2186+ B6AE              ; Copy protected disks have some of their track and sector numbers
2187+ B6AE              ; encoded on disk. Before each disk access, the ENCODE subroutine is
2188+ B6AE              ; called to encode the physical track and sector numbers.
2189+ B6AE              ;
2190+ B6AE              ; These encoded track and sector numbers must match those in the sector
2191+ B6AE              ; identifier.
2192+ B6AE              ;
2193+ B6AE              ; Note that tracks 0...2 on either side of a disk should not be encoded.
2194+ B6AE              ;
2195+ B6AE              ; ENTRY CONDTIONS
2196+ B6AE              ;         A = Enable/disable
2197+ B6AE              ;                 00h (0) = disable
2198+ B6AE              ;                 FFh (255) = enable
2199+ B6AE              ;         HL = (If enabled) address of ENCODE subroutine
2200+ B6AE              ;
2201+ B6AE              ; EXIT CONDITIONS
2202+ B6AE              ;                 HL = Address of previous ENCODE subroutine (0 if none)
2203+ B6AE              ;         Always:
2204+ B6AE              ;                 AF BC DE IX corrupt
2205+ B6AE              ;                 All other registers preserved
2206+ B6AE              ;
2207+ B6AE              ; NOTE
2208+ B6AE              ;         The definition of the subroutine ENCODE is as shown ahead.
2209+ B6AE              ;         Note that if you are substituting your own ENCODE subroutine,
2210+ B6AE              ;         the 'entry conditions' are the conditions passed to your
2211+ B6AE              ;         subroutine, and the 'exit conditions' are the values that your
2212+ B6AE              ;         subroutine must produce and the registers you are allowed to
2213+ B6AE              ;         corrupt.
2214+ B6AE              ;
2215+ B6AE              ;         ENCODE
2216+ B6AE              ;
2217+ B6AE              ;         ENTRY CONDITIONS
2218+ B6AE              ;                 C = Unit/side
2219+ B6AE              ;                         bits 0...1 = unit
2220+ B6AE              ;                         bit 2 = side
2221+ B6AE              ;                         bits 3...7 = 0
2222+ B6AE              ;                 D = Physical track
2223+ B6AE              ;                 E = Physical sector
2224+ B6AE              ;                 IX = Address of DPB
2225+ B6AE              ;
2226+ B6AE              ;         EXIT CONDITIONS
2227+ B6AE              ;                         D = Encoded physical track
2228+ B6AE              ;                         E = Encoded physical sector
2229+ B6AE              ;                 Always:
2230+ B6AE              ;                         AF corrupt
2231+ B6AE              ;                         All other registers preserved
2232+ B6AE              ;
2233+ B6AE
2234+ B6AE              dd_l_xdpb: equ 0x0187 ; (391)
2235+ B6AE
2236+ B6AE              ; Initialise an XDPB for a given format.
2237+ B6AE              ;
2238+ B6AE              ; This routine does not affect or consider the freeze flag.
2239+ B6AE              ;
2240+ B6AE              ; ENTRY CONDITIONS
2241+ B6AE              ;         IX = Address of destination XDPB
2242+ B6AE              ;         HL = Address of source disk specification
2243+ B6AE              ;
2244+ B6AE              ; EXIT CONDITIONS
2245+ B6AE              ;         If OK:
2246+ B6AE              ;                 Carry true
2247+ B6AE              ;                 A = Disk type recorded on disk
2248+ B6AE              ;                 DE = Size of allocation vector
2249+ B6AE              ;                 HL = Size of hash table
2250+ B6AE              ;         If bad format:
2251+ B6AE              ;                 Carry false
2252+ B6AE              ;                 A = Error code
2253+ B6AE              ;                 DE HL corrupt
2254+ B6AE              ;         Always:
2255+ B6AE              ;                 BC IX corrupt
2256+ B6AE              ;                 All other registers preserved
2257+ B6AE              ;
2258+ B6AE
2259+ B6AE              dd_l_dpb: equ 0x018a ; (394)
2260+ B6AE
2261+ B6AE              ; Initialise a DPB for a given format.
2262+ B6AE              ;
2263+ B6AE              ; This routine does not affect or consider the freeze flag.
2264+ B6AE              ;
2265+ B6AE              ; ENTRY CONDITIONS
2266+ B6AE              ;         IX = Address of destination DPB
2267+ B6AE              ;         HL = Address of source disk specification
2268+ B6AE              ;
2269+ B6AE              ; EXIT CONDITIONS
2270+ B6AE              ;         If OK:
2271+ B6AE              ;                 Carry true
2272+ B6AE              ;                 A = Disk type recorded on disk
2273+ B6AE              ;                 DE = Size of allocation vector
2274+ B6AE              ;                 HL = Size of hash table
2275+ B6AE              ;         If bad format:
2276+ B6AE              ;                 Carry false
2277+ B6AE              ;                 A = Error code
2278+ B6AE              ;                 DE HL corrupt
2279+ B6AE              ;         Always:
2280+ B6AE              ;                 BC IX corrupt
2281+ B6AE              ;                 All other registers preserved
2282+ B6AE              ;
2283+ B6AE
2284+ B6AE              dd_l_seek: equ 0x018d ; (397)
2285+ B6AE
2286+ B6AE              ; Seek to required track.
2287+ B6AE              ;
2288+ B6AE              ; Retry if fails.
2289+ B6AE              ;
2290+ B6AE              ; ENTRY CONDITIONS
2291+ B6AE              ;         C = Unit/head
2292+ B6AE              ;                 bits 0...1 = unit
2293+ B6AE              ;                 bit 2 = head
2294+ B6AE              ;                 bits 3...7 = 0
2295+ B6AE              ;         D = Track
2296+ B6AE              ;         IX = Address of XDPB
2297+ B6AE              ;
2298+ B6AE              ; EXIT CONDITIONS
2299+ B6AE              ;         If OK:
2300+ B6AE              ;                 Carry true
2301+ B6AE              ;                 A corrupt
2302+ B6AE              ;         Otherwise:
2303+ B6AE              ;                 Carry false
2304+ B6AE              ;                 A = Error report
2305+ B6AE              ;         Always:
2306+ B6AE              ;                 BC DE HL IX corrupt
2307+ B6AE              ;                 All other registers preserved
2308+ B6AE              ;
2309+ B6AE
2310+ B6AE              dd_l_read: equ 0x0190 ; (400)
2311+ B6AE
2312+ B6AE              ; Low level uPD765A read command.
2313+ B6AE              ;
2314+ B6AE              ; Read data.
2315+ B6AE              ;
2316+ B6AE              ; Read deleted data.
2317+ B6AE              ;
2318+ B6AE              ; Read a track.
2319+ B6AE              ;
2320+ B6AE              ; Parameter block format:
2321+ B6AE              ;
2322+ B6AE              ;         Byte 0          - Page for C000h (49152)...FFFFh (65535)
2323+ B6AE              ;         Bytes 1...2     - Address of buffer
2324+ B6AE              ;         Bytes 3...4     - Number of bytes to transfer
2325+ B6AE              ;         Byte 5          - Number of command bytes
2326+ B6AE              ;         Bytes 6...      - Command bytes
2327+ B6AE              ;
2328+ B6AE              ; Writes commands.
2329+ B6AE              ;
2330+ B6AE              ; Reads data.
2331+ B6AE              ;
2332+ B6AE              ; Reads results.
2333+ B6AE              ;
2334+ B6AE              ; Motor must be running.
2335+ B6AE              ;
2336+ B6AE              ; ENTRY CONDITIONS
2337+ B6AE              ;         HL = Address of parameter block
2338+ B6AE              ;
2339+ B6AE              ; EXIT CONDITIONS
2340+ B6AE              ;                 HL = Address of result buffer in page 7
2341+ B6AE              ;         Always:
2342+ B6AE              ;                 AF BC DE IX corrupt
2343+ B6AE              ;                 All other registers preserved
2344+ B6AE              ;
2345+ B6AE
2346+ B6AE              dd_l_write: equ 0x0193 ; (403)
2347+ B6AE
2348+ B6AE              ; Low level uPD765A write command.
2349+ B6AE              ;
2350+ B6AE              ; Write data.
2351+ B6AE              ;
2352+ B6AE              ; Write deleted data.
2353+ B6AE              ;
2354+ B6AE              ; Format a track.
2355+ B6AE              ;
2356+ B6AE              ; Scan equal.
2357+ B6AE              ;
2358+ B6AE              ; Scan low or equal.
2359+ B6AE              ;
2360+ B6AE              ; Scan high or equal.
2361+ B6AE              ;
2362+ B6AE              ; Parameter block format:
2363+ B6AE              ;
2364+ B6AE              ;         Byte 0          - Page for C000h (49152)...FFFFh (65535)
2365+ B6AE              ;         Bytes 1...2     - Address of buffer
2366+ B6AE              ;         Bytes 3...4     - Number of bytes to transfer
2367+ B6AE              ;         Byte 5          - Number of command bytes
2368+ B6AE              ;         Bytes 6...      - Command bytes
2369+ B6AE              ;
2370+ B6AE              ; Writes commands.
2371+ B6AE              ;
2372+ B6AE              ; Writes data.
2373+ B6AE              ;
2374+ B6AE              ; Reads results.
2375+ B6AE              ;
2376+ B6AE              ; Motor must be running.
2377+ B6AE              ;
2378+ B6AE              ; ENTRY CONDITIONS
2379+ B6AE              ;         HL = Address of parameter block
2380+ B6AE              ;
2381+ B6AE              ; EXIT CONDITIONS
2382+ B6AE              ;                 HL = Address of result buffer in page 7
2383+ B6AE              ;         Always:
2384+ B6AE              ;                 AF BC DE IX corrupt
2385+ B6AE              ;                 All other registers preserved
2386+ B6AE              ;
2387+ B6AE
2388+ B6AE              dd_l_on_motor: equ 0x0196 ; (406)
2389+ B6AE
2390+ B6AE              ; Turn on the motor.
2391+ B6AE              ;
2392+ B6AE              ; Wait for the motor on time as set by DD SETUP.
2393+ B6AE              ;
2394+ B6AE              ; ENTRY CONDITIONS
2395+ B6AE              ;         None
2396+ B6AE              ;
2397+ B6AE              ; EXIT CONDITIONS
2398+ B6AE              ;         Always:
2399+ B6AE              ;                 AF BC DE HL IX corrupt
2400+ B6AE              ;                 All other registers preserved
2401+ B6AE              ;
2402+ B6AE
2403+ B6AE              dd_l_t_off_motor: equ 0x0199 ; (409)
2404+ B6AE
2405+ B6AE              ; Start the motor off time-out.
2406+ B6AE              ;
2407+ B6AE              ; ENTRY CONDITIONS
2408+ B6AE              ;         None
2409+ B6AE              ;
2410+ B6AE              ; EXIT CONDITIONS
2411+ B6AE              ;         Always:
2412+ B6AE              ;                 AF BC DE HL IX corrupt
2413+ B6AE              ;                 All other registers preserved
2414+ B6AE              ;
2415+ B6AE
2416+ B6AE              dd_l_off_motor: equ 0x019c ; (412)
2417+ B6AE
2418+ B6AE              ; Turn off the motor.
2419+ B6AE              ;
2420+ B6AE              ; ENTRY CONDITIONS
2421+ B6AE              ;         None
2422+ B6AE              ;
2423+ B6AE              ; EXIT CONDITIONS
2424+ B6AE              ;         Always:
2425+ B6AE              ;                 AF BC DE HL IX corrupt
2426+ B6AE              ;                 All other registers preserved
2427+ B6AE
2428+ B6AE              ; +3DOS constants
2429+ B6AE              OPEN_ACTION_ERROR_EXISTS            equ 0
2430+ B6AE              OPEN_ACTION_READ_HEADER             equ 1
2431+ B6AE              OPEN_ACTION_IGNORE_HEADER           equ 2
2432+ B6AE              OPEN_ACTION_MAKE_BACKUP             equ 3
2433+ B6AE              OPEN_ACTION_OVERWRITE               equ 4
2434+ B6AE
2435+ B6AE              CREATE_ACTION_DONT_CREATE           equ 0
2436+ B6AE              CREATE_ACTION_WITH_HEADER           equ 1
2437+ B6AE              CREATE_ACTION_WITHOUT_HEADER        equ 2
2438+ B6AE
2439+ B6AE              FILE_TYPE_BASIC                     equ 0
2440+ B6AE              FILE_TYPE_NUM_ARRAY                 equ 1
2441+ B6AE              FILE_TYPE_CHR_ARRAY                 equ 2
2442+ B6AE              FILE_TYPE_BYTES                     equ 3
2443+ B6AE
2444+ B6AE              ACCESS_MODE_EXCLUSIVE_READ          equ 1
2445+ B6AE              ACCESS_MODE_EXCLUSIVE_WRITE         equ 2
2446+ B6AE              ACCESS_MODE_EXCLUSIVE_READ_WRITE    equ 3
2447+ B6AE              ACCESS_MODE_SHARED                  equ 5
2448+ B6AE
2449+ B6AE              ; +3E extensions
2450+ B6AE
2451+ B6AE              ide_version             equ     $00A0
2452+ B6AE              ide_interface           equ     $00A3
2453+ B6AE              ide_init                equ     $00A6
2454+ B6AE              ide_drive               equ     $00A9
2455+ B6AE              ide_sector_read         equ     $00AC
2456+ B6AE              ide_sector_write        equ     $00AF
2457+ B6AE              ide_format              equ     $00B2
2458+ B6AE              ide_partition_find      equ     $00B5
2459+ B6AE              ide_partition_new       equ     $00B8
2460+ B6AE              ide_partition_init      equ     $00BB
2461+ B6AE              ide_partition_erase     equ     $00BE
2462+ B6AE              ide_partition_rename    equ     $00C1
2463+ B6AE              ide_partition_read      equ     $00C4
2464+ B6AE              ide_partition_write     equ     $00C7
2465+ B6AE              ide_partition_winfo     equ     $00CA
2466+ B6AE              ide_partition_open      equ     $00CD
2467+ B6AE              ide_partition_close     equ     $00D0
2468+ B6AE              ide_partition_getinfo   equ     $00D3
2469+ B6AE              ide_partition_setinfo   equ     $00D6
2470+ B6AE              ide_swap_open           equ     $00D9
2471+ B6AE              ide_swap_close          equ     $00DC
2472+ B6AE              ide_swap_out            equ     $00DF
2473+ B6AE              ide_swap_in             equ     $00E2
2474+ B6AE              ide_swap_ex             equ     $00E5
2475+ B6AE              ide_swap_pos            equ     $00E8
2476+ B6AE              ide_swap_move           equ     $00EB
2477+ B6AE              ide_swap_resize         equ     $00EE
2478+ B6AE              ide_dos_map             equ     $00F1
2479+ B6AE              ide_dos_unmap           equ     $00F4
2480+ B6AE              ide_dos_mapping         equ     $00F7
2481+ B6AE              ide_dos_unpermanent     equ     $00FA
2482+ B6AE              ide_snapload            equ     $00FD
2483+ B6AE
2484+ B6AE              ide_access_data         equ     $019F
2485+ B6AE              ide_identify            equ     $01A2
2486+ B6AE              ide_partitiions         equ     $01A5
2487+ B6AE
# file closed: p3dos.asm
 422  B6AE                  include "prtwifi.asm"
# file opened: prtwifi.asm
   1+ B6AE              ; ==============================================================================================
   2+ B6AE              ; RS232 through +3 printer port, 57600, 8N1, +CTS, -RTS
   3+ B6AE              ; 57600bps (17,3611s)
   4+ B6AE              ; 61.57813T on ZX 128k, 61T will take 17.19811s, error -0.9% (58146bps)
   5+ B6AE              ; 60.76389T on ZX 48k,  61T will take 17.42857s, error +0.4% (57377bps)
   6+ B6AE              ;
   7+ B6AE              ; Based on some *amazing* work here: https://cygnus.speccy.cz/popis_zx-spectrum_dg192k_rs232.php
   8+ B6AE              ; ==============================================================================================
   9+ B6AE
  10+ B6AE              ; --------------------------------------
  11+ B6AE              ; 0xFFD: Printer port data latch (Write)
  12+ B6AE              ; --------------------------------------
  13+ B6AE              ;         Bit 7   TX
  14+ B6AE              ;         Bit 0   CTS
  15+ B6AE              ; --------------------------------------
  16+ B6AE              ; 0xFFD: Printer port busy (Read)
  17+ B6AE              ; --------------------------------------
  18+ B6AE              ;         Bit 0   RX
  19+ B6AE              ; --------------------------------------
  20+ B6AE
  21+ B6AE              uartBegin:
  22+ B6AE 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC
  23+ B6B1 3E 80            ld   a, 0x80                ; 7T    TX = 1, CTS = 0 (allow sending)
  24+ B6B3 ED 79            out  (c), a                 ; 12T
  25+ B6B5
  26+ B6B5 FB               ei                          ; Re-enable interrupts, just in case
  27+ B6B6 3E 32            ld   a, 50                  ; Flush anything left in TX buffer, by keeping CTS low
  28+ B6B8 76           1:  halt                        ; for ~1 second
  29+ B6B9 3D               dec  a
  30+ B6BA 20 FC            jr   nz, 1B
  31+ B6BC F3               di                          ; Timing critical now, so diable interrupts
  32+ B6BD
  33+ B6BD 3E 81            ld   a, 0x81                ; 7T    TX = 1, CTS = 1 (stop sending)
  34+ B6BF ED 79            out  (c), a                 ; 12T
  35+ B6C1
  36+ B6C1 DD 7E 00         ld   a, (ix + 0)            ; 19T   Wait at least one bit
  37+ B6C4 DD 7E 00         ld   a, (ix + 0)            ; 19T
  38+ B6C7 DD 7E 00         ld   a, (ix + 0)            ; 19T
  39+ B6CA C9               ret                         ; 10T
  40+ B6CB
  41+ B6CB              uartWriteByte:
  42+ B6CB F3               di
  43+ B6CC
  44+ B6CC 01 FD 0F         ld   bc, 0xFFD              ; 10T Printer port to BC
  45+ B6CF 26 08            ld   h, 8                   ; 7T H serves as an 8-bit counter
  46+ B6D1 6F               ld   l, a                   ; 4T copy data from A to L
  47+ B6D2
  48+ B6D2 00               nop                         ; 4T
  49+ B6D3 00               nop                         ; 4T
  50+ B6D4 00               nop                         ; 4T
  51+ B6D5 00               nop                         ; 4T
  52+ B6D6
  53+ B6D6              ; start bit
  54+ B6D6 3E 01            ld   a, 1                   ; TX = 1 (Start bit), CTS = 0 (allow sending - why, we're sending?! - maybe should be 0x81?)
  55+ B6D8 ED 79            out  (c), a                 ; 12T write to port
  56+ B6DA
  57+ B6DA 00               nop                         ; 4T
  58+ B6DB 00               nop                         ; 4T
  59+ B6DC 00               nop                         ; 4T
  60+ B6DD 00               nop                         ; 4T
  61+ B6DE
  62+ B6DE              ; data bits
  63+ B6DE              txLoop:
  64+ B6DE 3E 00            ld   a, 0                   ; 7T delay
  65+ B6E0 3E 00            ld   a, 0                   ; 7T delay
  66+ B6E2
  67+ B6E2 CB 0D            rrc  l                      ; 8T next bit at bit position 7
  68+ B6E4 3E 01            ld   a, 1                   ; 7T prepare a mask
  69+ B6E6 B5               or   l                      ; 4T add a mask
  70+ B6E7
  71+ B6E7              ; from the beginning start bit 12 + 8 + 8 + 7 + 7 + 8 + 7 + 4 = 61T
  72+ B6E7              ; from last bit 12 + 4 + 12 + 7 + 7 + 8 + 7 + 4 = 61T
  73+ B6E7
  74+ B6E7 ED 79            out  (c), a                 ; 12T write to port
  75+ B6E9 25               dec  h                      ; 4T bit counter
  76+ B6EA 20 F2            jr   nz, txLoop             ; 12 / 7T repeat
  77+ B6EC
  78+ B6EC              ; stop bit
  79+ B6EC DD 7E 00         ld   a, (ix + 0)            ; 19T delay
  80+ B6EF 23               inc  hl                     ; 6T delay
  81+ B6F0 2B               dec  hl                     ; 6T delay
  82+ B6F1 3E 81            ld   a, 0x81                ; 7T, keep bit 0 (CTS) and 7 (TX - stop bit) high (stop sending)
  83+ B6F3
  84+ B6F3              ; since the last out in the cycle 12 + 4 + 7 + 19 + 6 + 6 + 7 = 61T
  85+ B6F3
  86+ B6F3 ED 79            out   (c), a                ; 12T write to port
  87+ B6F5 FB               ei
  88+ B6F6 C9               ret                         ; 10T extends the stop bit duration
  89+ B6F7
  90+ B6F7              uartReadBlocking:
  91+ B6F7 F3               di
  92+ B6F8
  93+ B6F8 AF               xor  a                      ; Reset read error count
  94+ B6F9 32 47 B7         ld   (readErrors), a
  95+ B6FC
  96+ B6FC 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC
  97+ B6FF
  98+ B6FF              ; Check that RX is idle
  99+ B6FF
 100+ B6FF              rxRetry:
 101+ B6FF ED 78            in   a, (c)                 ; 12T   reads the port, sets the sign flag according to MSB
 102+ B701 E6 01            and  1                      ; 7T
 103+ B703 CA 3B B7         jp   z, rxError             ; 10T   error, RxD should be in log. 1 (idle state / stop bit)
 104+ B706
 105+ B706              ; detection delay 12 + 7 + 10 = 29T
 106+ B706
 107+ B706 3E 80            ld   a, 0x80                ; 7T    TX = 1, CTS = 0
 108+ B708 ED 79            out  (c), a                 ; 12T   Assert CTS to get a byte from the ESP
 109+ B70A
 110+ B70A              ; Wait for the start bit
 111+ B70A
 112+ B70A              rxWFSB:
 113+ B70A ED 78        1:  in   a, (c)                 ; 12T   read port
 114+ B70C 0F               rrca                        ; 4T    bit 0 to carry flag
 115+ B70D DA 0A B7         jp   c, 1B                  ; 10T   Repeat to start bit
 116+ B710
 117+ B710              ; waiting loop 12 + 4 + 10 = 26T
 118+ B710
 119+ B710              ; Immediately de-assert CTS to stop the ESP transmitting another byte
 120+ B710              ; while we process this one
 121+ B710
 122+ B710 3E 81            ld   a, 0x81                ; 7T    TX = 1, CTS = 1
 123+ B712 ED 79            out  (c), a                 ; 12T
 124+ B714
 125+ B714              ; start bit started, waiting for bit 0
 126+ B714              ; the wait length is chosen so that bit 0 is somewhere in its middle
 127+ B714              ; at least 15T has passed from the edge of the start bit, at most 41T, we take an average of 28T
 128+ B714              ; you still have to wait 1.5 x 61T - 28T = 63.5T (of which 11T for another IN instruction)
 129+ B714
 130+ B714 D9               exx                         ; 4T    secondary set
 131+ B715 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC '(and delay at the same time)
 132+ B718 23               inc  hl                     ; 6T    delay
 133+ B719 2B               dec  hl                     ; 6T    delay
 134+ B71A 26 07            ld   h, 7                   ; 7T    in the cycle will be read 7 bits and 8th at the end of the cycle
 135+ B71C
 136+ B71C              ; 6 + 6 + 4 + 10 + 6 + 6 + 7 + 7 = 52T
 137+ B71C              ; now bit 0 is somewhere in the middle, we can read 8 times with a distance of 61T
 138+ B71C
 139+ B71C              rxLoop:
 140+ B71C ED 78            in   a, (c)                 ; 12T   load port
 141+ B71E 0F               rrca                        ; 4T    bit 0 to carry flag
 142+ B71F CB 1D            rr   l                      ; 8T    build byte in L
 143+ B721 3E 00            ld   a, 0                   ; 7T    delay
 144+ B723 3E 00            ld   a, 0                   ; 7T    delay
 145+ B725 ED 5F            ld   a, r                   ; 9T    delay
 146+ B727 25               dec  h                      ; 4T    counter
 147+ B728 C2 1C B7         jp   nz, rxLoop             ; 10T   reads more bits
 148+ B72B
 149+ B72B              ; 12 + 4 + 8 + 7 + 7 + 9 + 4 + 10 = 61T if repeated (bits 0 to 6)
 150+ B72B
 151+ B72B              ; followed by reading the MSB, bit 7
 152+ B72B
 153+ B72B ED 78            in   a, (c)                 ; 12T   read port (MSB is somewhere in the middle of the duration, to the stop bit approx. 31  13T  2T accuracy deviation 3%)
 154+ B72D 0F               rrca                        ; 4T    bit 0 to carry flag
 155+ B72E 7D               ld   a, l                   ; 4T    almost assembled byte to A
 156+ B72F 1F               rra                         ; 4T    rotate the MSB to bit 7 in A
 157+ B730
 158+ B730              ; 12 + 4 + 4 + 4 = 24T
 159+ B730
 160+ B730 D9               exx                         ; 4T    primary set
 161+ B731
 162+ B731              ; Delay for stop bit
 163+ B731
 164+ B731 08               ex   af, af'                ; 4T
 165+ B732 DD 7E 00         ld   a, (ix + 0)            ; 19T delay
 166+ B735 DD 7E 00         ld   a, (ix + 0)            ; 19T delay
 167+ B738              ;    xor  a                      ; 4T
 168+ B738              ;    out  (-2), a                ; 11T    Black border
 169+ B738 08               ex   af, af'                ; 4T
 170+ B739
 171+ B739 FB               ei                          ; 4T
 172+ B73A C9               ret                         ; 10T   Return with byte in A
 173+ B73B
 174+ B73B              ; 4 + 19 + 4 + 11 + 4 + 4 + 10 = 53T
 175+ B73B
 176+ B73B              rxError
 177+ B73B 21 47 B7         ld   hl, readErrors         ; 3T
 178+ B73E 34               inc  (hl)                   ; 11T
 179+ B73F C2 FF B6         jp   nz, rxRetry            ; 7/12T
 180+ B742
 181+ B742 3E 02            ld   a, 2                   ; 7T
 182+ B744 D3 FE            out  (-2), a                ; 11T
 183+ B746 C9               ret                         ; 10T
 184+ B747
 185+ B747              ; 3 + 11 + 12 = 26T
 186+ B747
 187+ B747              readErrors:
 188+ B747 00               db   0
 189+ B748
 190+ B748              ; saving the apartment takes 4 + 7 + 4 + 4 + 10 = 29T
 191+ B748              ; total 24 + 29 = 53T
 192+ B748              ; including line status detection, 75T with verification before start bit
 193+ B748              ; otherwise, you can directly wait for the next start bit
 194+ B748
# file closed: prtwifi.asm
 423  B748                  include "ring.asm"
# file opened: ring.asm
   1+ B748              ; Pushes A to ring buffer
   2+ B748              pushRing
   3+ B748 4F               ld   c, a                           ; Save byte in A to C
   4+ B749 06 20            ld   b, 32
   5+ B74B
   6+ B74B                  ; Copy bytes in buffer down one position
   7+ B74B
   8+ B74B 21 8A B7         ld   hl, ring_buffer + 1
   9+ B74E 11 89 B7         ld   de, ring_buffer
  10+ B751              1:
  11+ B751 7E               ld   a, (hl)
  12+ B752 12               ld   (de), a
  13+ B753 23               inc  hl
  14+ B754 13               inc  de
  15+ B755 10 FA            djnz 1B
  16+ B757
  17+ B757 79               ld   a, c                           ; Get byte back from C
  18+ B758 21 A8 B7         ld   hl, ring_buffer + 31           ; Write byte to end of buffer
  19+ B75B 77               ld   (hl), a
  20+ B75C C9               ret
  21+ B75D
  22+ B75D              ; Entry:
  23+ B75D              ;   HL: Search string (null terminated)
  24+ B75D              ; Exit:
  25+ B75D              ;   Fc: 1 Found
  26+ B75D              ;       0 Not found
  27+ B75D              searchRing:
  28+ B75D E5               push hl
  29+ B75E
  30+ B75E 06 00            ld   b, 0
  31+ B760 11 A9 B7         ld   de, ring_buffer + 32           ; Start at end of buffer
  32+ B763
  33+ B763              strlen:
  34+ B763 7E               ld   a, (hl)                        ; Get the length of the string to compare
  35+ B764 23               inc  hl                             ; Count bytes in B until we get to a 0
  36+ B765 1B               dec  de                             ; Move ring buffer search position back
  37+ B766 04               inc  b
  38+ B767 A7               and  a
  39+ B768 C2 63 B7         jp   nz, strlen
  40+ B76B
  41+ B76B 05               dec  b                              ; Don't count 0 string terminator
  42+ B76C 13               inc  de
  43+ B76D
  44+ B76D E1               pop  hl
  45+ B76E
  46+ B76E              strcmp:                                 ; B = strlen (without 0 terminator)
  47+ B76E 1A               ld   a, (de)
  48+ B76F BE               cp   (hl)
  49+ B770 C2 79 B7         jp   nz, .failed
  50+ B773 13               inc  de
  51+ B774 23               inc  hl
  52+ B775 10 F7            djnz strcmp
  53+ B777 37               scf
  54+ B778 C9               ret
  55+ B779
  56+ B779              .failed
  57+ B779 AF               xor  a
  58+ B77A C9               ret
  59+ B77B
  60+ B77B              clearRing:
  61+ B77B AF               xor  a
  62+ B77C 21 89 B7         ld   hl, ring_buffer
  63+ B77F 11 8A B7         ld   de, ring_buffer + 1
  64+ B782 01 20 00         ld   bc, 32
  65+ B785 77               ld   (hl), a
  66+ B786 ED B0            ldir
  67+ B788 C9               ret
  68+ B789
  69+ B789              ; dumpRing:
  70+ B789              ;     push af
  71+ B789              ;
  72+ B789              ;     ld   b, 32
  73+ B789              ;     ld   hl, ring_buffer
  74+ B789              ; 1:
  75+ B789              ;     ld   a, (hl)
  76+ B789              ;     cp   31
  77+ B789              ;     jr   c, 1F
  78+ B789              ; 2:
  79+ B789              ;     push bc
  80+ B789              ;     push hl
  81+ B789              ;     call putc
  82+ B789              ;     pop  hl
  83+ B789              ;     pop  bc
  84+ B789              ;
  85+ B789              ;     inc  hl
  86+ B789              ;     djnz 1B
  87+ B789              ;
  88+ B789              ;     ld   a, 13
  89+ B789              ;     call putc
  90+ B789              ;
  91+ B789              ;     pop  af
  92+ B789              ;     ret
  93+ B789              ; 1:
  94+ B789              ;     ld   a, '.'
  95+ B789              ;     jr   2B
  96+ B789
  97+ B789              ring_buffer
  98+ B789 00 00 00...      ds  32, 0
  99+ B7A9
# file closed: ring.asm
 424  B7A9                  include "utils.asm"
# file opened: utils.asm
   1+ B7A9              ;    IFNDEF ZX48
   2+ B7A9              ; ; This routine checks availability of extended(128K) memory.
   3+ B7A9              ; ; Output:
   4+ B7A9              ; ; Flag: Z - High memory available
   5+ B7A9              ; checkHighMem:
   6+ B7A9              ;     xor a : call changeBank : ld hl, #c000 : xor a : ld (hl), a ; Let's write in zero page zero value
   7+ B7A9              ;     inc a : call changeBank : ld a, 13 : ld (hl), a             ; In other page - any other value. Let's write luck 13
   8+ B7A9              ;     xor a : call changeBank : ld a, (hl) : and a                ; When we back to zero page - still there zero?!
   9+ B7A9              ;     ret
  10+ B7A9              ;
  11+ B7A9              ; ; A - memory bank
  12+ B7A9              ; changeBank:
  13+ B7A9              ;     ld bc, #7ffd : or #18 : out (c), a : ld (bankm), a
  14+ B7A9              ;     re
  15+ B7A9              ;     ENDIF
  16+ B7A9
  17+ B7A9              uartWriteStringZ:
  18+ B7A9              ;     IFDEF DEBUG
  19+ B7A9              ;     push hl
  20+ B7A9              ;     call putstr
  21+ B7A9              ;     pop  hl
  22+ B7A9              ;     ENDIF
  23+ B7A9
  24+ B7A9 7E           1:  ld   a, (hl)
  25+ B7AA A7               and  a
  26+ B7AB CA 93 B4         jp   z, restoreBorder               ; Return via restoreBorder
  27+ B7AE E5               push hl
  28+ B7AF CD CB B6         call uartWriteByte
  29+ B7B2 E1               pop  hl
  30+ B7B3
  31+ B7B3 ED 5F            ld   a, r
  32+ B7B5 E6 07            and  7
  33+ B7B7 D3 FE            out  (-2), a
  34+ B7B9
  35+ B7B9 23               inc  hl
  36+ B7BA 18 ED            jr   1B
  37+ B7BC
  38+ B7BC              ; Print zero-terminated string
  39+ B7BC              ; HL - string pointer
  40+ B7BC              ; putStringZ:
  41+ B7BC              ; printZ64:
  42+ B7BC              ;     IFNDEF ZX48
  43+ B7BC              ;     ld a, 7 : call changeBank
  44+ B7BC              ;     ENDIF
  45+ B7BC              ;     ld   b, 41
  46+ B7BC              ; 1:
  47+ B7BC              ;     ld   a, (hl) : and a : ret z
  48+ B7BC              ;     push bc
  49+ B7BC              ;     push hl : call putC : pop hl
  50+ B7BC              ;     inc  hl
  51+ B7BC              ;     pop  bc
  52+ B7BC              ;
  53+ B7BC              ;     dec  b                              ; Limit string display length
  54+ B7BC              ;     ld   a, b
  55+ B7BC              ;     or   a
  56+ B7BC              ;     ret  z
  57+ B7BC              ;     jr  1B
  58+ B7BC              ;
  59+ B7BC              ; printT64:
  60+ B7BC              ;     ld   b, 41
  61+ B7BC              ; 1:
  62+ B7BC              ;     xor  a : or b : ret z
  63+ B7BC              ;
  64+ B7BC              ;     ld   a, (hl)
  65+ B7BC              ;
  66+ B7BC              ;     and  a : ret z
  67+ B7BC              ;     cp   09 : ret z
  68+ B7BC              ;
  69+ B7BC              ;     push bc
  70+ B7BC              ;
  71+ B7BC              ;     push hl : call putC : pop hl
  72+ B7BC              ;
  73+ B7BC              ;     inc  hl : pop bc : dec b
  74+ B7BC              ;     jr   1B
  75+ B7BC              ;
  76+ B7BC              ; printL64:
  77+ B7BC              ;
  78+ B7BC              ;     ld b, 41
  79+ B7BC              ; .loop
  80+ B7BC              ;     xor a : or b : ret z
  81+ B7BC              ;     ld a, (hl)
  82+ B7BC              ;
  83+ B7BC              ;     and a : ret z
  84+ B7BC              ;     cp #0A : ret z
  85+ B7BC              ;     cp #0D : ret z;
  86+ B7BC              ;
  87+ B7BC              ;     push hl, bc : call putC : pop bc, hl
  88+ B7BC              ;     dec b
  89+ B7BC              ;     inc hl
  90+ B7BC              ;     jr .loop
  91+ B7BC
  92+ B7BC              ; HL - string
  93+ B7BC              ; Return: bc - len
  94+ B7BC              getStringLength:
  95+ B7BC 01 00 00         ld bc, 0
  96+ B7BF              strLnLp
  97+ B7BF 7E               ld a, (hl)
  98+ B7C0 A7               and a
  99+ B7C1 C8               ret z
 100+ B7C2 03               inc bc
 101+ B7C3 23               inc hl
 102+ B7C4 18 F9            jr strLnLp
 103+ B7C6
 104+ B7C6              SkipWhitespace:
 105+ B7C6 7E               ld a, (hl)
 106+ B7C7 FE 20            cp ' '
 106+ B7C9 C0             ret nz
 107+ B7CA 23               inc hl
 108+ B7CB 18 F9            jr SkipWhitespace
 109+ B7CD
 110+ B7CD              ; DE <= StringZ
 111+ B7CD              ; HL => output
 112+ B7CD              atoi:
 113+ B7CD 21 00 00         ld   hl, 0
 114+ B7D0 1A           1:  ld   a, (de)
 115+ B7D1 A7               and  a
 115+ B7D2 C8             ret z
 116+ B7D3 FE 0D            cp   13
 116+ B7D5 C8             ret z
 117+ B7D6 FE 09            cp   9
 117+ B7D8 C8             ret z
 118+ B7D9 CD DF B7         call atoi2
 119+ B7DC 13               inc  de
 120+ B7DD 18 F1            jr 1B
 121+ B7DF
 122+ B7DF              atoi2:
 123+ B7DF D6 30            sub  0x30
 124+ B7E1 4D               ld   c, l
 125+ B7E2 44               ld   b, h
 126+ B7E3 29               add  hl, hl
 127+ B7E4 29               add  hl, hl
 128+ B7E5 09               add  hl, bc
 129+ B7E6 29               add  hl, hl
 130+ B7E7 4F               ld   c, a
 131+ B7E8 06 00            ld   b, 0
 132+ B7EA 09               add  hl, bc
 133+ B7EB C9               ret
 134+ B7EC
 135+ B7EC              ;findEnd:
 136+ B7EC              ;    ld   a, (hl)
 137+ B7EC              ;    and  a
 138+ B7EC              ;    ret  z
 139+ B7EC              ;    inc  hl
 140+ B7EC              ;    jr   findEnd
 141+ B7EC
 142+ B7EC              ;;;;;;;;;;;;;;;;;;;;;;;;
 143+ B7EC
 144+ B7EC              ; Binary to decimal stuff
 145+ B7EC              ; From https://www.msx.org/forum/development/msx-development/32-bit-long-ascii
 146+ B7EC
 147+ B7EC              ; Combined routine for conversion of different sized binary numbers into
 148+ B7EC              ; directly printable ASCII(Z)-string
 149+ B7EC              ; Input value in registers, number size and -related to that- registers to fill
 150+ B7EC              ; is selected by calling the correct entry:
 151+ B7EC              ;
 152+ B7EC              ;  entry  inputregister(s)  decimal value 0 to:
 153+ B7EC              ;   B2D8             A                    255  (3 digits)
 154+ B7EC              ;   B2D16           HL                  65535   5   "
 155+ B7EC              ;   B2D24         E:HL               16777215   8   "
 156+ B7EC              ;   B2D32        DE:HL             4294967295  10   "
 157+ B7EC              ;   B2D48     BC:DE:HL        281474976710655  15   "
 158+ B7EC              ;   B2D64  IX:BC:DE:HL   18446744073709551615  20   "
 159+ B7EC              ;
 160+ B7EC              ; The resulting string is placed into a small buffer attached to this routine,
 161+ B7EC              ; this buffer needs no initialization and can be modified as desired.
 162+ B7EC              ; The number is aligned to the right, and leading 0's are replaced with spaces.
 163+ B7EC              ; On exit HL points to the first digit, (B)C = number of decimals
 164+ B7EC              ; This way any re-alignment / postprocessing is made easy.
 165+ B7EC              ; Changes: AF,BC,DE,HL,IX
 166+ B7EC              ; P.S. some examples below
 167+ B7EC
 168+ B7EC              ; by Alwin Henseler
 169+ B7EC
 170+ B7EC 26 00        B2D8:    LD H,0
 171+ B7EE 6F                    LD L,A
 172+ B7EF 1E 00        B2D16:   LD E,0
 173+ B7F1 16 00        B2D24:   LD D,0
 174+ B7F3 01 00 00     B2D32:   LD BC,0
 175+ B7F6 DD 21 00 00  B2D48:   LD IX,0          ; zero all non-used bits
 176+ B7FA 22 83 B8     B2D64:   LD (B2DINV),HL
 177+ B7FD ED 53 85 B8           LD (B2DINV+2),DE
 178+ B801 ED 43 87 B8           LD (B2DINV+4),BC
 179+ B805 DD 22 89 B8           LD (B2DINV+6),IX ; place full 64-bit input value in buffer
 180+ B809 21 8B B8              LD HL,B2DBUF
 181+ B80C 11 8C B8              LD DE,B2DBUF+1
 182+ B80F 36 20                 LD (HL)," "
 183+ B811              B2DFILC: EQU $-1         ; address of fill-character
 184+ B811 01 12 00              LD BC,18
 185+ B814 ED B0                 LDIR            ; fill 1st 19 bytes of buffer with spaces
 186+ B816 ED 43 9E B8           LD (B2DEND-1),BC ;set BCD value to "0" & place terminating 0
 187+ B81A 1E 01                 LD E,1          ; no. of bytes in BCD value
 188+ B81C 21 8B B8              LD HL,B2DINV+8  ; (address MSB input)+1
 189+ B81F 01 09 09              LD BC,0x0909
 190+ B822 AF                    XOR A
 191+ B823 05           B2DSKP0: DEC B
 192+ B824 28 29                 JR Z,B2DSIZ     ; all 0: continue with postprocessing
 193+ B826 2B                    DEC HL
 194+ B827 B6                    OR (HL)         ; find first byte <>0
 195+ B828 28 F9                 JR Z,B2DSKP0
 196+ B82A 0D           B2DFND1: DEC C
 197+ B82B 17                    RLA
 198+ B82C 30 FC                 JR NC,B2DFND1   ; determine no. of most significant 1-bit
 199+ B82E 1F                    RRA
 200+ B82F 57                    LD D,A          ; byte from binary input value
 201+ B830 E5           B2DLUS2: PUSH HL
 202+ B831 C5                    PUSH BC
 203+ B832 21 9E B8     B2DLUS1: LD HL,B2DEND-1  ; address LSB of BCD value
 204+ B835 43                    LD B,E          ; current length of BCD value in bytes
 205+ B836 CB 12                 RL D            ; highest bit from input value -> carry
 206+ B838 7E           B2DLUS0: LD A,(HL)
 207+ B839 8F                    ADC A,A
 208+ B83A 27                    DAA
 209+ B83B 77                    LD (HL),A       ; double 1 BCD byte from intermediate result
 210+ B83C 2B                    DEC HL
 211+ B83D 10 F9                 DJNZ B2DLUS0    ; and go on to double entire BCD value (+carry!)
 212+ B83F 30 03                 JR NC,B2DNXT
 213+ B841 1C                    INC E           ; carry at MSB -> BCD value grew 1 byte larger
 214+ B842 36 01                 LD (HL),1       ; initialize new MSB of BCD value
 215+ B844 0D           B2DNXT:  DEC C
 216+ B845 20 EB                 JR NZ,B2DLUS1   ; repeat for remaining bits from 1 input byte
 217+ B847 C1                    POP BC          ; no. of remaining bytes in input value
 218+ B848 0E 08                 LD C,8          ; reset bit-counter
 219+ B84A E1                    POP HL          ; pointer to byte from input value
 220+ B84B 2B                    DEC HL
 221+ B84C 56                    LD D,(HL)       ; get next group of 8 bits
 222+ B84D 10 E1                 DJNZ B2DLUS2    ; and repeat until last byte from input value
 223+ B84F 21 9F B8     B2DSIZ:  LD HL,B2DEND    ; address of terminating 0
 224+ B852 4B                    LD C,E          ; size of BCD value in bytes
 225+ B853 B7                    OR A
 226+ B854 ED 42                 SBC HL,BC       ; calculate address of MSB BCD
 227+ B856 54                    LD D,H
 228+ B857 5D                    LD E,L
 229+ B858 ED 42                 SBC HL,BC
 230+ B85A EB                    EX DE,HL        ; HL=address BCD value, DE=start of decimal value
 231+ B85B 41                    LD B,C          ; no. of bytes BCD
 232+ B85C CB 21                 SLA C           ; no. of bytes decimal (possibly 1 too high)
 233+ B85E 3E 30                 LD A,"0"
 234+ B860 ED 6F                 RLD             ; shift bits 4-7 of (HL) into bit 0-3 of A
 235+ B862 FE 30                 CP "0"          ; (HL) was > 9h?
 236+ B864 20 06                 JR NZ,B2DEXPH   ; if yes, start with recording high digit
 237+ B866 0D                    DEC C           ; correct number of decimals
 238+ B867 13                    INC DE          ; correct start address
 239+ B868 18 04                 JR B2DEXPL      ; continue with converting low digit
 240+ B86A ED 6F        B2DEXP:  RLD             ; shift high digit (HL) into low digit of A
 241+ B86C 12           B2DEXPH: LD (DE),A       ; record resulting ASCII-code
 242+ B86D 13                    INC DE
 243+ B86E ED 6F        B2DEXPL: RLD
 244+ B870 12                    LD (DE),A
 245+ B871 13                    INC DE
 246+ B872 23                    INC HL          ; next BCD-byte
 247+ B873 10 F5                 DJNZ B2DEXP     ; and go on to convert each BCD-byte into 2 ASCII
 248+ B875 ED 42                 SBC HL,BC       ; return with HL pointing to 1st decimal
 249+ B877 C9                    RET
 250+ B878
 251+ B878              AppendB2D:
 252+ B878              ; Append results of B2D to string at HL
 253+ B878 EB               ex      de, hl  ; Get destination into DE
 254+ B879 21 8B B8         ld      hl, B2DBUF
 255+ B87C CD C6 B7         call        SkipWhitespace
 256+ B87F ED B0            ldir
 257+ B881 EB               ex      de, hl  ; Get destination into DE
 258+ B882 C9               ret
 259+ B883
 260+ B883 00 00 00...  B2DINV:  DS 8            ; space for 64-bit input value (LSB first)
 261+ B88B 00 00 00...  B2DBUF:  DS 20           ; space for 20 decimal digits
 262+ B89F 00           B2DEND:  DB 0 ; space for terminating 0
 263+ B8A0
# file closed: utils.asm
 425  B8A0                  include "wifi.asm"
# file opened: wifi.asm
   1+ B8A0              ROM_OPEN_CHANNEL        EQU  0x1601             ; Open a channel
   2+ B8A0              ROM_PRINT               EQU  0x203C             ; Print a string
   3+ B8A0
   4+ B8A0                  macro dodos n
   5+ B8A0 ~                    ld   ix, n
   6+ B8A0 ~                    call dos_ix
   7+ B8A0                  endm
   8+ B8A0
   9+ B8A0              loadWiFiConfig:
  10+ B8A0 3E 01            ld      a, 1
  11+ B8A2 CD 01 16         call    ROM_OPEN_CHANNEL
  12+ B8A5 11 F3 BA         ld      de, loadingMsg
  13+ B8A8 01 19 00         ld      bc, loadingMsgLen
  14+ B8AB CD 3C 20         call    ROM_PRINT
  15+ B8AE
  16+ B8AE 06 01            ld      b, 1
  17+ B8B0 21 20 BC         ld      hl, conf_file
  18+ B8B3 0E 01            ld      c, ACCESS_MODE_EXCLUSIVE_READ
  19+ B8B5 16 00            ld      d, CREATE_ACTION_DONT_CREATE
  20+ B8B7 1E 01            ld      e, OPEN_ACTION_READ_HEADER
  21+ B8B9                  dodos   dos_open
  21+ B8B9 DD 21 06 01 >        ld   ix, dos_open
  21+ B8BD CD 91 B5    >        call dos_ix
  22+ B8C0 30 1D            jr      nc, .error
  23+ B8C2
  24+ B8C2 06 01            ld      b, 1
  25+ B8C4 0E 00            ld      c, 0
  26+ B8C6 11 A0 00         ld      de, 160
  27+ B8C9 21 2D BC         ld      hl, ssid
  28+ B8CC                  dodos   dos_read
  28+ B8CC DD 21 12 01 >        ld   ix, dos_read
  28+ B8D0 CD 91 B5    >        call dos_ix
  29+ B8D3 30 0A            jr      nc, .error
  30+ B8D5
  31+ B8D5 06 01            ld      b, 1
  32+ B8D7                  dodos   dos_close
  32+ B8D7 DD 21 09 01 >        ld   ix, dos_close
  32+ B8DB CD 91 B5    >        call dos_ix
  33+ B8DE C9               ret
  34+ B8DF
  35+ B8DF              .error
  36+ B8DF 3E 02            ld      a, 2
  37+ B8E1 D3 FE            out     (-2), a
  38+ B8E3 C9               ret
  39+ B8E4
  40+ B8E4              ; Initialize WiFi chip and connect to WiFi
  41+ B8E4              initWiFi
  42+ B8E4 3E 01            ld      a, 1
  43+ B8E6 CD 01 16         call    ROM_OPEN_CHANNEL
  44+ B8E9 11 0C BB         ld      de, connectingMsg
  45+ B8EC 01 19 00         ld      bc, connectingMsgLen
  46+ B8EF CD 3C 20         call    ROM_PRINT
  47+ B8F2
  48+ B8F2 CD AE B6         call    uartBegin
  49+ B8F5 21 11 BA         ld      hl, cmd_rst
  50+ B8F8 CD A9 B7         call    uartWriteStringZ
  51+ B8FB
  52+ B8FB              1
  53+ B8FB                  ; Flush ESP TX buffer
  54+ B8FB CD AE B6         call    uartBegin
  55+ B8FE
  56+ B8FE                  ; WiFi client mode
  57+ B8FE 21 21 BA         ld      hl, cmd_mode
  58+ B901 CD 59 B9         call    okErrCmd
  59+ B904 E6 01            and     1
  60+ B906 28 4B            jr      z, errInit
  61+ B908
  62+ B908                  ; Disable ECHO. BTW Basic UART test
  63+ B908 21 1A BA         ld      hl, cmd_at
  64+ B90B CD 59 B9         call    okErrCmd
  65+ B90E E6 01            and     1
  66+ B910 28 41            jr      z, errInit
  67+ B912
  68+ B912                  ; Lets disconnect from last AP
  69+ B912 21 41 BA         ld      hl, cmd_cwqap
  70+ B915 CD 59 B9         call    okErrCmd
  71+ B918 E6 01            and     1
  72+ B91A 28 37            jr      z, errInit
  73+ B91C
  74+ B91C                  ; Single connection mode
  75+ B91C 21 33 BA         ld      hl, cmd_cmux
  76+ B91F CD 59 B9         call    okErrCmd
  77+ B922 E6 01            and     1
  78+ B924 28 2D            jr      z, errInit
  79+ B926
  80+ B926                  ; FTP enables this info? We doesn't need it :-)
  81+ B926 21 4C BA         ld      hl, cmd_inf_off
  82+ B929 CD 59 B9         call    okErrCmd
  83+ B92C E6 01            and     1
  84+ B92E 28 23            jr      z, errInit
  85+ B930
  86+ B930              ; Access Point connection
  87+ B930 21 5C BA         ld      hl, cmd_cwjap1
  88+ B933 CD A9 B7         call    uartWriteStringZ
  89+ B936 21 2D BC         ld      hl, ssid
  90+ B939 CD A9 B7         call    uartWriteStringZ
  91+ B93C 21 6B BA         ld      hl, cmd_cwjap2
  92+ B93F CD A9 B7         call    uartWriteStringZ
  93+ B942 21 7D BC         ld      hl, pass
  94+ B945 CD A9 B7         call    uartWriteStringZ
  95+ B948 21 6F BA         ld      hl, cmd_cwjap3
  96+ B94B CD 59 B9         call    okErrCmd
  97+ B94E
  98+ B94E E6 01            and 1
  98+ B950 28 01         jr z, errInit
  99+ B952
 100+ B952 C9               ret
 101+ B953
 102+ B953              errInit
 103+ B953                  ; ld hl, log_err : call putStringZ
 104+ B953 3E 03            ld   a, 3
 105+ B955 D3 FE            out  (-2), a
 106+ B957 18 FE            jr $
 107+ B959
 108+ B959              ; Send AT-command and wait for result.
 109+ B959              ; HL - Z-terminated AT-command(with CR/LF)
 110+ B959              ; A:
 111+ B959              ;    1 - Success
 112+ B959              ;    0 - Failed
 113+ B959              okErrCmd
 114+ B959 CD A9 B7         call    uartWriteStringZ
 115+ B95C              okErrCmdLp
 116+ B95C CD F7 B6         call    uartReadBlocking
 117+ B95F CD 48 B7         call    pushRing
 118+ B962
 119+ B962 21 D5 BA         ld      hl, response_ok
 120+ B965 CD 5D B7         call    searchRing
 121+ B968 38 13            jr      c, okErrOk
 122+ B96A 21 DA BA         ld      hl, response_err
 123+ B96D CD 5D B7         call    searchRing
 124+ B970 38 0E            jr      c, okErrErr
 125+ B972 21 E4 BA         ld      hl, response_fail
 126+ B975 CD 5D B7         call    searchRing
 127+ B978 38 06            jr      c, okErrErr
 128+ B97A
 129+ B97A C3 5C B9         jp      okErrCmdLp
 130+ B97D              okErrOk
 131+ B97D 3E 01            ld      a, 1
 132+ B97F C9               ret
 133+ B980              okErrErr
 134+ B980 AF               xor     a
 135+ B981 C9               ret
 136+ B982
 137+ B982              ; Gets packet from network
 138+ B982              ; packet will be in var 'output_buffer'
 139+ B982              ; received packet size in var 'bytes_avail'
 140+ B982              ;
 141+ B982              ; If connection was closed it calls 'closed_callback'
 142+ B982              getPacket
 143+ B982 CD F7 B6         call    uartReadBlocking
 144+ B985 FE 2B            cp      '+'
 145+ B987 28 34            jr      z, .checkIpdStart
 146+ B989 FE 4F            cp      'O'
 147+ B98B 28 4A            jr      z, .checkClosed
 148+ B98D 18 F3            jr      getPacket
 149+ B98F
 150+ B98F              .readPacket
 151+ B98F CD FC B9         call    count_ipd_length
 152+ B992 22 ED BA         ld      (bytes_avail), hl
 153+ B995 E5               push    hl
 154+ B996 C1               pop     bc                      ; BC = byte count
 155+ B997
 156+ B997 2A BD BB         ld      hl, (data_pointer)
 157+ B99A              .readByte
 158+ B99A C5               push    bc
 159+ B99B E5               push    hl
 160+ B99C CD F7 B6         call    uartReadBlocking
 161+ B99F
 162+ B99F F3               di
 163+ B9A0
 164+ B9A0 F5               push    af
 165+ B9A1 3A ED B5         ld      a, (ddl_parms)
 166+ B9A4 CD C1 B5         call    ram_page_in
 167+ B9A7 F1               pop     af
 168+ B9A8
 169+ B9A8 E1               pop     hl
 170+ B9A9 C1               pop     bc
 171+ B9AA
 172+ B9AA 77               ld      (hl), a
 173+ B9AB 23               inc     hl
 174+ B9AC 0B               dec     bc
 175+ B9AD
 176+ B9AD C5               push    bc
 177+ B9AE E5               push    hl
 178+ B9AF CD CE B5         call    ram_page_out
 179+ B9B2 E1               pop     hl
 180+ B9B3 C1               pop     bc
 181+ B9B4
 182+ B9B4 78               ld      a, b
 183+ B9B5 B1               or      c
 184+ B9B6 20 E2            jr      nz, .readByte
 185+ B9B8
 186+ B9B8 22 BD BB         ld      (data_pointer), hl
 187+ B9BB FB               ei
 188+ B9BC C9               ret
 189+ B9BD
 190+ B9BD              .checkIpdStart
 191+ B9BD CD F7 B6         call uartReadBlocking
 191+ B9C0 FE 49          cp 'I'
 191+ B9C2 20 BE          jr nz, getPacket
 192+ B9C4 CD F7 B6         call uartReadBlocking
 192+ B9C7 FE 50          cp 'P'
 192+ B9C9 20 B7          jr nz, getPacket
 193+ B9CB CD F7 B6         call uartReadBlocking
 193+ B9CE FE 44          cp 'D'
 193+ B9D0 20 B0          jr nz, getPacket
 194+ B9D2 CD F7 B6         call uartReadBlocking ; Comma
 195+ B9D5 18 B8            jr   .readPacket
 196+ B9D7
 197+ B9D7              .checkClosed
 198+ B9D7 CD F7 B6         call uartReadBlocking
 198+ B9DA FE 53          cp 'S'
 198+ B9DC 20 A4          jr nz, getPacket
 199+ B9DE CD F7 B6         call uartReadBlocking
 199+ B9E1 FE 45          cp 'E'
 199+ B9E3 20 9D          jr nz, getPacket
 200+ B9E5 CD F7 B6         call uartReadBlocking
 200+ B9E8 FE 44          cp 'D'
 200+ B9EA 20 96          jr nz, getPacket
 201+ B9EC CD F7 B6         call uartReadBlocking
 201+ B9EF FE 0D          cp 13
 201+ B9F1 20 8F          jr nz, getPacket
 202+ B9F3 C3 F6 B9         jp   closed_callback
 203+ B9F6
 204+ B9F6              closed_callback:
 205+ B9F6 AF               xor  a
 206+ B9F7 32 19 BC         ld   (connectionOpen), a
 207+ B9FA FB               ei
 208+ B9FB C9               ret
 209+ B9FC
 210+ B9FC              count_ipd_length
 211+ B9FC 21 00 00         ld   hl, 0          ; count length
 212+ B9FF E5           1:  push hl
 213+ BA00 CD F7 B6         call uartReadBlocking
 214+ BA03 F5               push af
 215+ BA04 CD 48 B7         call pushRing
 216+ BA07 F1               pop  af
 217+ BA08 E1               pop  hl
 218+ BA09 FE 3A            cp   ':'
 219+ BA0B C8               ret  z
 220+ BA0C
 221+ BA0C CD DF B7         call atoi2
 222+ BA0F 18 EE            jr   1B
 223+ BA11
 224+ BA11 41 54 2B 52  cmd_rst     defb "AT+RST",13, 10, 0
 224+ BA15 53 54 0D 0A
 224+ BA19 00
 225+ BA1A 41 54 45 30  cmd_at      defb "ATE0", 13, 10, 0                  ; Disable echo - less to parse
 225+ BA1E 0D 0A 00
 226+ BA21 41 54 2B 43  cmd_mode    defb "AT+CWMODE_DEF=1",13,10,0          ; Client mode
 226+ BA25 57 4D 4F 44
 226+ BA29 45 5F 44 45
 226+ BA2D 46 3D 31 0D
 226+ BA31 0A 00
 227+ BA33 41 54 2B 43  cmd_cmux    defb "AT+CIPMUX=0",13,10,0              ; Single connection mode
 227+ BA37 49 50 4D 55
 227+ BA3B 58 3D 30 0D
 227+ BA3F 0A 00
 228+ BA41 41 54 2B 43  cmd_cwqap   defb "AT+CWQAP",13,10,0                 ; Disconnect from AP
 228+ BA45 57 51 41 50
 228+ BA49 0D 0A 00
 229+ BA4C 41 54 2B 43  cmd_inf_off defb "AT+CIPDINFO=0",13,10,0            ; doesn't send me info about remote port and ip
 229+ BA50 49 50 44 49
 229+ BA54 4E 46 4F 3D
 229+ BA58 30 0D 0A 00
 230+ BA5C
 231+ BA5C 41 54 2B 43  cmd_cwjap1  defb  "AT+CWJAP_CUR=", #22,0        ;Connect to AP. Send this -> SSID
 231+ BA60 57 4A 41 50
 231+ BA64 5F 43 55 52
 231+ BA68 3D 22 00
 232+ BA6B 22 2C 22 00  cmd_cwjap2  defb #22,',',#22,0                  ; -> This -> Password
 233+ BA6F 22 0D 0A 00  cmd_cwjap3  defb #22, 13, 10, 0                 ; -> And this
 234+ BA73
 235+ BA73 41 54 2B 43  cmd_open1   defb "AT+CIPSTART=", #22, "TCP", #22, ",", #22, 0
 235+ BA77 49 50 53 54
 235+ BA7B 41 52 54 3D
 235+ BA7F 22 54 43 50
 235+ BA83 22 2C 22 00
 236+ BA87 22 2C 00     cmd_open2   defb #22, ",", 0
 237+ BA8A 0D 0A 00     cmd_open3   defb 13, 10, 0
 238+ BA8D 41 54 2B 43  cmd_send    defb "AT+CIPSEND=", 0
 238+ BA91 49 50 53 45
 238+ BA95 4E 44 3D 00
 239+ BA99 41 54 2B 43  cmd_close   defb "AT+CIPCLOSE",13,10,0
 239+ BA9D 49 50 43 4C
 239+ BAA1 4F 53 45 0D
 239+ BAA5 0A 00
 240+ BAA7 41 54 2B 43  cmd_send_b  defb "AT+CIPSEND=1", 13, 10,0
 240+ BAAB 49 50 53 45
 240+ BAAF 4E 44 3D 31
 240+ BAB3 0D 0A 00
 241+ BAB6 43 4C 4F 53  closed      defb "CLOSED", 13, 10, 0
 241+ BABA 45 44 0D 0A
 241+ BABE 00
 242+ BABF 0D 0A 2B 49  ipd         defb 13, 10, "+IPD,", 0
 242+ BAC3 50 44 2C 00
 243+ BAC7
 244+ BAC7 72 65 61 64  response_rdy        defb 'ready', 0
 244+ BACB 79 00
 245+ BACD 69 6E 76 61  response_invalid    defb 'invalid', 0
 245+ BAD1 6C 69 64 00
 246+ BAD5 4F 4B 0D 0A  response_ok         defb 'OK', 13, 10, 0      ; Sucessful operation
 246+ BAD9 00
 247+ BADA 0D 0A 45 52  response_err        defb 13, 10, 'ERROR', 13, 10, 0      ; Failed operation
 247+ BADE 52 4F 52 0D
 247+ BAE2 0A 00
 248+ BAE4 0D 0A 46 41  response_fail       defb 13, 10, 'FAIL', 13, 10, 0       ; Failed connection to WiFi. For us same as ERROR
 248+ BAE8 49 4C 0D 0A
 248+ BAEC 00
 249+ BAED
 250+ BAED 00 00        bytes_avail   defw 0
 251+ BAEF 00 00        sbyte_buff    defb 0, 0
 252+ BAF1
 253+ BAF1 3E 00        send_prompt defb ">",0
 254+ BAF3
 255+ BAF3              loadingMsg:
 256+ BAF3 16 01 00 4C      defb 0x16, 1, 0, "Loading WiFi config..."
 256+ BAF7 6F 61 64 69
 256+ BAFB 6E 67 20 57
 256+ BAFF 69 46 69 20
 256+ BB03 63 6F 6E 66
 256+ BB07 69 67 2E 2E
 256+ BB0B 2E
 257+ BB0C              loadingMsgLen: equ $-loadingMsg
 258+ BB0C
 259+ BB0C              connectingMsg:
 260+ BB0C 16 01 00 43      defb 0x16, 1, 0, "Connecting...         "
 260+ BB10 6F 6E 6E 65
 260+ BB14 63 74 69 6E
 260+ BB18 67 2E 2E 2E
 260+ BB1C 20 20 20 20
 260+ BB20 20 20 20 20
 260+ BB24 20
 261+ BB25              connectingMsgLen equ $-connectingMsg
 262+ BB25
# file closed: wifi.asm
 426  BB25                  include "request.asm"
# file opened: request.asm
   1+ BB25              loadSector:
   2+ BB25 21 E5 BB         ld      hl, d_host
   3+ BB28 11 C5 BB         ld      de, d_path
   4+ BB2B 01 13 BC         ld      bc, d_port
   5+ BB2E
   6+ BB2E DD E5            push    ix
   7+ BB30 CD 39 BB         call    makeRequest
   8+ BB33 CD B2 BB         call    loadData
   9+ BB36 DD E1            pop     ix
  10+ BB38
  11+ BB38 C9               ret
  12+ BB39
  13+ BB39              ; HL - domain stringZ
  14+ BB39              ; DE - path stringZ
  15+ BB39              ; BC - port stringZ
  16+ BB39              makeRequest:
  17+ BB39 22 1A BC         ld      (srv_ptr), hl
  18+ BB3C ED 53 1C BC      ld      (path_ptr), de
  19+ BB40 ED 43 1E BC      ld      (port_ptr), bc
  20+ BB44
  21+ BB44                  ; Open TCP connection
  22+ BB44 21 73 BA         ld      hl, cmd_open1
  23+ BB47 CD A9 B7         call    uartWriteStringZ
  24+ BB4A 2A 1A BC         ld      hl, (srv_ptr)
  25+ BB4D CD A9 B7         call    uartWriteStringZ
  26+ BB50 21 87 BA         ld      hl, cmd_open2
  27+ BB53 CD A9 B7         call    uartWriteStringZ
  28+ BB56 2A 1E BC         ld      hl, (port_ptr)
  29+ BB59 CD A9 B7         call    uartWriteStringZ
  30+ BB5C 21 8A BA         ld      hl, cmd_open3
  31+ BB5F CD 59 B9         call    okErrCmd
  32+ BB62
  33+ BB62                  ; call    dumpRing
  34+ BB62 FE 01            cp      1
  35+ BB64 C2 AD BB         jp      nz, reqErr
  36+ BB67
  37+ BB67                  ; Send request
  38+ BB67 21 8D BA         ld      hl, cmd_send
  39+ BB6A CD A9 B7         call    uartWriteStringZ
  40+ BB6D 2A 1C BC         ld      hl, (path_ptr)
  41+ BB70 CD BC B7         call    getStringLength
  42+ BB73 C5               push    bc
  43+ BB74 E1               pop     hl
  44+ BB75 CD EF B7         call    B2D16
  45+ BB78
  46+ BB78 21 8B B8         ld      hl, B2DBUF
  47+ BB7B CD C6 B7         call    SkipWhitespace
  48+ BB7E CD A9 B7         call    uartWriteStringZ
  49+ BB81 21 C2 BB         ld      hl, crlf
  50+ BB84 CD 59 B9         call    okErrCmd
  51+ BB87
  52+ BB87                  ; call    dumpRing
  53+ BB87 FE 01            cp      1
  54+ BB89 C2 AD BB         jp      nz, reqErr
  55+ BB8C
  56+ BB8C              wPrmt:
  57+ BB8C CD F7 B6         call    uartReadBlocking
  58+ BB8F CD 48 B7         call    pushRing
  59+ BB92 21 F1 BA         ld      hl, send_prompt
  60+ BB95 CD 5D B7         call    searchRing
  61+ BB98 30 F2            jr      nc, wPrmt
  62+ BB9A
  63+ BB9A 2A 1C BC         ld      hl, (path_ptr)
  64+ BB9D CD A9 B7         call    uartWriteStringZ
  65+ BBA0
  66+ BBA0 21 C2 BB         ld      hl, crlf
  67+ BBA3 CD A9 B7         call    uartWriteStringZ
  68+ BBA6 3E 01            ld      a, 1
  69+ BBA8 32 19 BC         ld      (connectionOpen), a
  70+ BBAB AF               xor     a
  71+ BBAC C9               ret
  72+ BBAD
  73+ BBAD              reqErr:
  74+ BBAD 3E 02            ld      a, 2
  75+ BBAF D3 FE            out     (-2), a
  76+ BBB1 C9               ret
  77+ BBB2
  78+ BBB2              ; HL - data pointer
  79+ BBB2              ; data_pointer = pointer to buffer
  80+ BBB2              loadData:
  81+ BBB2 CD 82 B9         call    getPacket                ; Fetch next data packet
  82+ BBB5
  83+ BBB5 3A 19 BC         ld      a, (connectionOpen)      ; Check connection status
  84+ BBB8 B7               or      a                        ; Test if zero
  85+ BBB9 C8               ret     z                        ; Exit loop if connection closed
  86+ BBBA
  87+ BBBA C3 B2 BB         jp      loadData                 ; Process next packet
  88+ BBBD
  89+ BBBD 00 00        data_pointer    defw    0
  90+ BBBF 00 00        data_recv       defw    0
  91+ BBC1 00           fstream         defb    0
  92+ BBC2
  93+ BBC2 0D 0A 00     crlf            defb    13, 10, 0
  94+ BBC5
  95+ BBC5 00 00 00...  d_path          defs    32, 0
  96+ BBE5 31 39 32 2E  d_host          defb    '192.168.7.164', 0
  96+ BBE9 31 36 38 2E
  96+ BBED 37 2E 31 36
  96+ BBF1 34 00
  97+ BBF3 00 00 00...                  defs    32
  98+ BC13 37 36 35 30  d_port          db      '7650', 0
  98+ BC17 00
  99+ BC18 00                           defs    1
 100+ BC19
 101+ BC19 00           connectionOpen  db      0
 102+ BC1A
 103+ BC1A 00 00        srv_ptr         dw  0
 104+ BC1C 00 00        path_ptr        dw  0
 105+ BC1E 00 00        port_ptr        dw  0
 106+ BC20
# file closed: request.asm
 427  BC20              ;    include "screen42.asm"
 428  BC20              ;    include "font42.asm"
 429  BC20
 430  BC20              conf_file
 431  BC20 69 77 2E 63      defb "iw.cfg",0xff
 431  BC24 66 67 FF
 432  BC27 FF FF FF...      defs 13-($-conf_file), 0xff
 433  BC2D
 434  BC2D              ssid:
 435  BC2D 00 00 00...      defs    80
 436  BC7D              pass:
 437  BC7D 00 00 00...      defs    80
 438  BCCD
 439  BCCD              end:
 440  BCCD
 441  BCCD              ; ddl_parms layout
 442  BCCD
 443  BCCD              ; Off.    Size  Desc
 444  BCCD              ; +$00    1     Buffer page
 445  BCCD              ; +$01    2     Buffer address
 446  BCCD              ; +$03    2     Sector size in bytes
 447  BCCD              ; +$05    1     # Command bytes
 448  BCCD
 449  BCCD              ; READ
 450  BCCD
 451  BCCD              ; +$06    1     Command byte
 452  BCCD              ; +$07    1     Unit byte                   x x x x x H U1 U0
 453  BCCD              ; +$08    1     Track
 454  BCCD              ; +$09    1     Side
 455  BCCD              ; +$0A    1     1st sector id
 456  BCCD              ; +$0B    1     Sector size
 457  BCCD              ; +$0C    1     Last sector id (=1st)
 458  BCCD              ; +$0D    1     Gap size
 459  BCCD              ; +$0E    1     Dummy data length ($ff)
 460  BCCD
 461  BCCD                  save3dos "driven.bin", start, end-start
 462  BCCD                  savebin  "drvn.bin", start, end-start
 463  BCCD
# file closed: drive_n.asm
