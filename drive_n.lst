# file opened: drive_n.asm
   1  0000                      device ZXSPECTRUM128
   2  0000
   3  0000              bank1           equ 0x7ffd
   4  0000              bankm           equ 0x5B5c
   5  0000              xdpb_ptrs       equ 0xe2a0              ; This is the same on the +3e, +3 or +2A
   6  0000              bordcr          equ $5c48
   7  0000
   8  0000                  org     0xc000 - (3*1024)
   9  B400
  10  B400              start:
  11  B400                  display $
  12  B400
  13  B400 C3 08 B4         jp      1F
  14  B403
  15  B403 EB BB            defw   d_host                   ; Addresses so we can poke in IP address
  16  B405 19 BC            defw   d_port                   ; and port of server if needed
  17  B407              disk_type:
  18  B407 00               defb   0                        ; Disk type
  19  B408
  20  B408              1:
  21  B408                  ; Set up the stack and save HL' so we can return to BASIC
  22  B408
  23  B408 F3               di
  24  B409 ED 73 50 B6      ld   (old_sp), sp               ; Move stack so it doesn't get paged out
  25  B40D 31 B6 B6         ld   sp, tmp_stack              ; when calling +3DOS
  26  B410 D9               exx
  27  B411 22 10 B6         ld   (temp_hl), hl              ; Save HL' as it's needed if returning to BASIC
  28  B414 D9               exx
  29  B415 FB               ei
  30  B416
  31  B416                  ; Load WiFi config + init ESP
  32  B416
  33  B416 3A 12 B6         ld   a, (wifiConnected)
  34  B419 B7               or   a
  35  B41A 20 0B            jr   nz, 1F
  36  B41C              ;        call text_init
  37  B41C CD AD B8         call loadWiFiConfig
  38  B41F CD F1 B8         call initWiFi
  39  B422 3E 01            ld   a, 1                           ; Flag wifi as connected
  40  B424 32 12 B6         ld   (wifiConnected), a
  41  B427
  42  B427              1:
  43  B427                  ; Set up XDPB for drive 'N:'
  44  B427
  45  B427 3E 4E            ld      a, 'N'
  46  B429 CD 75 B5         call    getXDPBPtr              ; Return the pointer to XDPB for drive N
  47  B42C
  48  B42C F3               di
  49  B42D 3E 07            ld      a, 7
  50  B42F CD CB B5         call    ram_page_in
  51  B432
  52  B432 3E DC            ld      a, low xdpb             ; Set pointer to point to our XDPB
  53  B434 77               ld      (hl), a
  54  B435 23               inc     hl
  55  B436 3E B4            ld      a, high xdpb
  56  B438 77               ld      (hl), a
  57  B439 2B               dec     hl
  58  B43A
  59  B43A CD D8 B5         call    ram_page_out
  60  B43D FB               ei
  61  B43E
  62  B43E DD 21 DC B4      ld      ix, xdpb
  63  B442 3A 07 B4         ld      a, (disk_type)          ; 0 = Standard +3 format disk
  64  B445 21 50 B4         ld      hl, .return1
  65  B448 E5               push    hl
  66  B449 21 78 01         ld      hl, dd_sel_format
  67  B44C E5               push    hl
  68  B44D C3 A7 B5         jp      dos_tos
  69  B450
  70  B450              .return1
  71  B450 C3 8E B4         jp      exit                    ; Drive N is now available
  72  B453
  73  B453              login:
  74  B453 AF               xor a
  75  B454 37               scf                                 ; Signal success
  76  B455 C9               ret
  77  B456
  78  B456              ;    B = Page for C000h (49152)...FFFFh (65535)
  79  B456              ;    C = Unit (0/1)
  80  B456              ;    D = Logical track, 0 base
  81  B456              ;    E = Logical sector, 0 base
  82  B456              ;   HL = Address of buffer
  83  B456              ;   IX = Address of XDPB
  84  B456              read:
  85  B456 DD E5            push ix
  86  B458
  87  B458 3E 05            ld   a, 5
  88  B45A 32 FD B5         ld   (ddl_parms+$06), a             ; Read command
  89  B45D
  90  B45D E5               push hl
  91  B45E D5               push de
  92  B45F C5               push bc
  93  B460 CD 0C B5         call buildFloppyCmd                 ; Build command to ddl_parms
  94  B463 C1               pop  bc
  95  B464 D1               pop  de
  96  B465 E1               pop  hl
  97  B466
  98  B466 CD A8 B4         call floppyCmdToString              ; Convert to hex string
  99  B469
 100  B469 2A F8 B5         ld   hl, (ddl_parms+1)              ; buffer address for sector read
 101  B46C 22 C3 BB         ld   (data_pointer), hl
 102  B46F
 103  B46F 21 EB BB         ld   hl, d_host
 104  B472 11 CB BB         ld   de, d_path
 105  B475 01 19 BC         ld   bc, d_port
 106  B478
 107  B478 CD 39 BB         call loadSector
 108  B47B 20 08            jr   nz, 1F
 109  B47D
 110  B47D CD 9D B4         call restoreBorder
 111  B480 DD E1            pop  ix                             ; Restore IX
 112  B482 AF               xor  a
 113  B483 37               scf                                 ; Signal success
 114  B484 C9               ret
 115  B485
 116  B485              1:
 117  B485 DD E1            pop  ix
 118  B487              write:
 119  B487 CD 9D B4         call restoreBorder
 120  B48A AF               xor  a
 121  B48B 3E 02            ld   a, 2                           ; Seek fail
 122  B48D C9               ret
 123  B48E
 124  B48E              exit:
 125  B48E F3               di
 126  B48F ED 7B 50 B6      ld      sp, (old_sp)
 127  B493 D9               exx
 128  B494 2A 10 B6         ld      hl, (temp_hl)
 129  B497 D9               exx
 130  B498
 131  B498 CD 9D B4         call    restoreBorder
 132  B49B
 133  B49B FB               ei
 134  B49C C9               ret
 135  B49D
 136  B49D              restoreBorder:
 137  B49D 3A 48 5C         ld      a, (bordcr)                 ; Restore border colour
 138  B4A0 E6 38            and     $38
 139  B4A2 0F               rrca
 140  B4A3 0F               rrca
 141  B4A4 0F               rrca
 142  B4A5 D3 FE            out     (-2), a
 143  B4A7 C9               ret
 144  B4A8
 145  B4A8              floppyCmdToString:
 146  B4A8 21 FD B5         ld   hl, ddl_parms+6
 147  B4AB 01 09 00         ld   bc, 0x09
 148  B4AE 11 CB BB         ld   de, d_path
 149  B4B1 CD B7 B4         call bytesToHex
 150  B4B4 AF               xor  a                              ; Null terminate string
 151  B4B5 77               ld   (hl), a
 152  B4B6 C9               ret
 153  B4B7
 154  B4B7              bytesToHex:
 155  B4B7 7E           1:  ld   a, (hl)
 156  B4B8 C5               push bc
 157  B4B9 CD C8 B4         call hexToBuf
 158  B4BC C1               pop  bc
 159  B4BD 23               inc  hl
 160  B4BE 0B               dec  bc
 161  B4BF 78               ld   a, b
 162  B4C0 B1               or   c
 163  B4C1 C8               ret  z
 164  B4C2 3E 20            ld   a, ' '
 165  B4C4 12               ld   (de), a
 166  B4C5 13               inc  de
 167  B4C6 18 EF            jr   1B
 168  B4C8
 169  B4C8              ; Entry:
 170  B4C8              ;   A = Hex value
 171  B4C8              ;  DE = Output buffer
 172  B4C8              hexToBuf:
 173  B4C8 4F               ld   c, a
 174  B4C9 1F               rra
 175  B4CA 1F               rra
 176  B4CB 1F               rra
 177  B4CC 1F               rra
 178  B4CD CD D1 B4         call 1f
 179  B4D0 79               ld   a, c
 180  B4D1 E6 0F        1:  and  0x0f
 181  B4D3 C6 90            add  a, 0x90
 182  B4D5 27               daa
 183  B4D6 CE 40            adc  a, 0x40
 184  B4D8 27               daa
 185  B4D9 12               ld   (de), a
 186  B4DA 13               inc  de
 187  B4DB C9               ret
 188  B4DC
 189  B4DC              xdpb:
 190  B4DC 00 00 00...      defs $1b, 0
 191  B4F7
 192  B4F7              .l17f6
 193  B4F7 04 4E 00         defb    $04,'N',$00         ; flags,drive,unit
 194  B4FA 00 00 00 00      defb    $00,$00,$00,$00     ; last access,filesopen
 195  B4FE 00 00 00 00      defw    $0000,$0000         ; #free direntries,last used
 196  B502 13 B6 23 B6      defw    chksm_a,alloc_a     ; checksum vector,alloc bitmap
 197  B506 53 B4            defw    login               ; login disk
 198  B508 56 B4            defw    read                ; read sector
 199  B50A 87 B4            defw    write               ; write sector
 200  B50C
 201  B50C              ; Convert logical track / sector to physical
 202  B50C              ; Entry:
 203  B50C              ;   DE = Logical Track / Sector
 204  B50C              ;    C = Unit
 205  B50C
 206  B50C              buildFloppyCmd:
 207  B50C CD 37 B5         call    l1b9c                   ; setup basic parameter block data
 208  B50F 7B               ld      a,e
 209  B510 DD 86 14         add     a,(ix+$14)
 210  B513 5F               ld      e,a                     ; E=physical sector number
 211  B514 D5               push    de                      ; save physical track & sector numbers
 212  B515 7B               ld      a,e
 213  B516 32 01 B6         ld      (ddl_parms+$0a),a       ; store 1st sector ID
 214  B519 DD 6E 0F         ld      l,(ix+$0f)
 215  B51C 63               ld      h,e
 216  B51D 22 02 B6         ld      (ddl_parms+$0b),hl      ; store sector size & last(=1st) sector ID
 217  B520 DD 7E 17         ld      a,(ix+$17)
 218  B523 32 04 B6         ld      (ddl_parms+$0d),a       ; store gap length
 219  B526 60               ld      h,b
 220  B527 6A               ld      l,d
 221  B528 22 FF B5         ld      (ddl_parms+8),hl        ; store track & side numbers
 222  B52B 3E 09            ld      a,$09
 223  B52D 32 FC B5         ld      (ddl_parms+5),a         ; store # command bytes
 224  B530 21 05 B6         ld      hl,ddl_parms+$0e
 225  B533 36 FF            ld      (hl),$ff                ; store dummy data length
 226  B535 D1               pop     de
 227  B536 C9               ret
 228  B537
 229  B537              ; Subroutine to setup some of the parameter block for sector read/writes
 230  B537              ; (except # command bytes & additional command bytes)
 231  B537
 232  B537 22 F8 B5     l1b9c   ld      (ddl_parms+1),hl        ; store buffer address
 233  B53A 6F               ld      l,a
 234  B53B 78               ld      a,b
 235  B53C 32 F7 B5         ld      (ddl_parms),a           ; store buffer page
 236  B53F CD 50 B5         call    l1bb5                   ; C=physical side & unit byte
 237  B542 61               ld      h,c
 238  B543 22 FD B5         ld      (ddl_parms+6),hl        ; store command & unit byte
 239  B546 DD 6E 15         ld      l,(ix+$15)
 240  B549 DD 66 16         ld      h,(ix+$16)
 241  B54C 22 FA B5         ld      (ddl_parms+3),hl        ; store sector size as # bytes to transfer
 242  B54F C9               ret
 243  B550
 244  B550              ; Subroutine to return physical side (B) and track (D) given logical track (D)
 245  B550              ; Physical side is also ORed with unit number in C
 246  B550
 247  B550 DD 7E 11     l1bb5   ld      a,(ix+$11)
 248  B553 E6 7F            and     $7f                     ; A=sidedness
 249  B555 06 00            ld      b,$00                   ; side 0
 250  B557 C8               ret     z                       ; exit if single-sided (physical=logical)
 251  B558
 252  B558 3D               dec     a
 253  B559 20 08            jr      nz,l1bc8                ; move on if double-sided: successive sides
 254  B55B
 255  B55B 7A               ld      a,d
 256  B55C 1F               rra                             ; for alternate sides, halve track
 257  B55D 57               ld      d,a
 258  B55E 78               ld      a,b
 259  B55F 17               rla                             ; with side=remainder
 260  B560 47               ld      b,a
 261  B561 18 0C            jr      l1bd4                   ; move on to OR into unit number
 262  B563
 263  B563 7A           l1bc8   ld      a,d
 264  B564 DD 96 12         sub     (ix+$12)                ; subtract # tracks
 265  B567 38 06            jr      c,l1bd4                 ; if < # tracks, physical=logical so move on
 266  B569 DD 96 12         sub     (ix+$12)                ; on successive side, tracks count back down
 267  B56C 2F               cpl
 268  B56D 57               ld      d,a
 269  B56E 04               inc     b                       ; and use side 1
 270  B56F
 271  B56F 78           l1bd4   ld      a,b                     ; A = side (0 or 1)
 272  B570 87               add     a,a                     ; A*= 2
 273  B571 87               add     a,a
 274  B572 B1               or      c                       ; OR in unit number
 275  B573 4F               ld      c,a                     ; update unit number with side bit as bit 1
 276  B574 C9               ret
 277  B575
 278  B575              ; ----------------------------------------------------------------------------
 279  B575              ; Get the address of the pointer to an XDPB for a given drive letter
 280  B575              ; ----------------------------------------------------------------------------
 281  B575              ; Entry:
 282  B575              ;   A = Drive letter, 'A'...'P'
 283  B575              ; Exit
 284  B575              ;   HL = Address in page 7 of pointer, or 0 if error
 285  B575              ; ----------------------------------------------------------------------------
 286  B575              getXDPBPtr:
 287  B575 F5               push    af
 288  B576 3E 07            ld      a, 7
 289  B578 CD CB B5         call    ram_page_in
 290  B57B F1               pop     af
 291  B57C CD 83 B5         call    .getPtr
 292  B57F CD D8 B5         call    ram_page_out
 293  B582 C9               ret
 294  B583
 295  B583              .getPtr
 296  B583 21 A0 E2         ld      hl,xdpb_ptrs
 297  B586 D6 41            sub     'A'
 298  B588 38 0D            jr      c, .error         ; error if <A
 299  B58A FE 10            cp      $10
 300  B58C 30 09            jr      nc, .error        ; error if >P
 301  B58E 87               add     a,a
 302  B58F C6 A0            add     a, low xdpb_ptrs
 303  B591 6F               ld      l,a
 304  B592 CE E2            adc     a, high xdpb_ptrs
 305  B594 95               sub     l
 306  B595 67               ld      h, a             ; HL=xdpb_ptrs+2*drive
 307  B596 C9               ret
 308  B597              .error:
 309  B597 21 00 00         ld      hl, 0
 310  B59A C9               ret
 311  B59B
 312  B59B              ; Entry
 313  B59B              ;   IX = +3dos routine to call
 314  B59B              dos_ix:
 315  B59B F3               di
 316  B59C CD B7 B5         call dos_in
 317  B59F CD E1 B5         call call_ix                        ; Call routine in IX
 318  B5A2 CD E3 B5         call dos_out
 319  B5A5 FB               ei
 320  B5A6 C9               ret
 321  B5A7
 322  B5A7              dos_tos:
 323  B5A7 CD B7 B5         call dos_in
 324  B5AA D9               exx                  ; preserve parameters
 325  B5AB E1               pop  hl               ; address of the DOS routine
 326  B5AC 11 B3 B5         ld   de,dos_tos_return ; return address from the DOS routine
 327  B5AF D5               push de              ; force the return later
 328  B5B0 E5               push hl              ; address of the DOS routine
 329  B5B1 D9               exx                  ; restore parameters
 330  B5B2 C9               ret                  ; call routine in TOS, then continue at dos.ix.return
 331  B5B3
 332  B5B3              dos_tos_return:
 333  B5B3 CD E3 B5         call dos_out
 334  B5B6 C9               ret
 335  B5B7
 336  B5B7              ; ----------------------------------------------------------------------------
 337  B5B7              ; Page in +3dos
 338  B5B7              ; ----------------------------------------------------------------------------
 339  B5B7              dos_in:
 340  B5B7 F5               push af
 341  B5B8 C5               push bc              ; temp save registers while switching
 342  B5B9 01 FD 7F         ld   bc,bank1        ; port used for horiz. ROM switch and RAM paging
 343  B5BC 3A 5C 5B         ld   a,(bankm)       ; RAM/ROM switching system variable
 344  B5BF CB A7            res  4,a             ; and DOS ROM
 345  B5C1 F6 07            or   7               ; set bits 0-3: RAM 7
 346  B5C3 32 5C 5B         ld   (bankm),a       ; keep system variables up to date
 347  B5C6 ED 79            out  (c),a           ; RAM page 7 to top and DOS ROM
 348  B5C8 C1               pop  bc
 349  B5C9 F1               pop  af
 350  B5CA C9               ret
 351  B5CB
 352  B5CB              ; A = RAM page
 353  B5CB              ram_page_in:
 354  B5CB 5F               ld      e, a
 355  B5CC 01 FD 7F         ld      bc, $7ffd
 356  B5CF 3A 5C 5B         ld      a, (bankm)
 357  B5D2 E6 F8            and     %11111000       ; Lose RAM bits
 358  B5D4 B3               or      e               ; Or in RAM page
 359  B5D5 ED 79            out     (c), a
 360  B5D7 C9               ret
 361  B5D8
 362  B5D8              ram_page_out:
 363  B5D8 01 FD 7F         ld      bc, $7ffd
 364  B5DB 3A 5C 5B         ld      a, (bankm)
 365  B5DE ED 79            out     (c), a          ; restore memory configuration
 366  B5E0 C9               ret
 367  B5E1
 368  B5E1              call_ix:
 369  B5E1 DD E9            jp   (ix)                           ; Jump to IX and return
 370  B5E3
 371  B5E3              ; ----------------------------------------------------------------------------
 372  B5E3              ; Page out +3DOS
 373  B5E3              ; ----------------------------------------------------------------------------
 374  B5E3              dos_out:
 375  B5E3 F5               push af
 376  B5E4 C5               push bc
 377  B5E5 3A 5C 5B         ld   a,(bankm)
 378  B5E8 E6 F8            and  %11111000           ; reset bits 0-3: RAM 0
 379  B5EA CB E7            set  4,a                 ; switch to ROM 3 (48 BASIC)
 380  B5EC 01 FD 7F         ld   bc,bank1
 381  B5EF 32 5C 5B         ld   (bankm),a
 382  B5F2 ED 79            out  (c),a               ; switch back to RAM page 0 and 48 BASIC
 383  B5F4 C1               pop  bc
 384  B5F5 F1               pop  af
 385  B5F6 C9               ret
 386  B5F7
 387  B5F7              ; dosError:
 388  B5F7              ;     ld   (0x4000), a
 389  B5F7              ;     ld   a, 2
 390  B5F7              ;     out  (-2), a
 391  B5F7              ;     ret
 392  B5F7
 393  B5F7              ; Data
 394  B5F7
 395  B5F7              ; Space for floppy emulation command
 396  B5F7              ddl_parms
 397  B5F7 00 00 00...      defs    $6
 398  B5FD
 399  B5FD              dd_cmd
 400  B5FD 00 00 00...      defs    $13
 401  B610
 402  B610              temp_hl:
 403  B610 00 00            defw    0
 404  B612
 405  B612              wifiConnected:
 406  B612 00               defb    0
 407  B613
 408  B613              chksm_a
 409  B613 00 00 00...      defs $10, 0
 410  B623
 411  B623              alloc_a
 412  B623 00 00 00...      defs $2d, 0
 413  B650
 414  B650              old_sp:
 415  B650 00 00            defw 0
 416  B652
 417  B652 00 00 00...      defs 100
 418  B6B6              tmp_stack:
 419  B6B6 00 00            defw 0
 420  B6B8
 421  B6B8                  include "p3dos.asm"
# file opened: p3dos.asm
   1+ B6B8              ; ZX Spectrum +3DOS
   2+ B6B8
   3+ B6B8              ; By Marcos Cruz (programandala.net)
   4+ B6B8
   5+ B6B8              ; Credit:
   6+ B6B8              ;
   7+ B6B8              ; This file is Part 27 of Chapter 8 of the ZX Spectrum +3
   8+ B6B8              ; manual, transcribed by Russell Marks et al. and published in
   9+ B6B8              ; HTML format in <http://worldofspectrum.org>.  I simply
  10+ B6B8              ; converted it to be usable as Z80 source.
  11+ B6B8
  12+ B6B8              ; --------------------------------------------------------------
  13+ B6B8              ; Change history
  14+ B6B8
  15+ B6B8              ; 2015-01-12: Start.
  16+ B6B8              ;
  17+ B6B8              ; 2015-07-13: Add labels for DOS GET 1346 and DOS SET 1346.
  18+ B6B8              ; Fix typos (also in the original HTML document).
  19+ B6B8              ;
  20+ B6B8              ; 2017-02-06: Add all symbols for low-level "DD" entry points.
  21+ B6B8              ; Improve the credit note.
  22+ B6B8
  23+ B6B8              ; --------------------------------------------------------------
  24+ B6B8
  25+ B6B8              ; Part 27
  26+ B6B8              ; Guide to +3DOS
  27+ B6B8              ;
  28+ B6B8              ; Subjects covered...
  29+ B6B8              ;
  30+ B6B8              ;         ROMs
  31+ B6B8              ;         +3DOS interface
  32+ B6B8              ;         File attributes and headers
  33+ B6B8              ;         Disk format and specification
  34+ B6B8              ;         Tracks and sectors
  35+ B6B8              ;         Disk parameter blocks
  36+ B6B8              ;         CP/M file compatibility
  37+ B6B8              ;         Changing disks
  38+ B6B8              ;         Logical to physical drive mapping
  39+ B6B8              ;         +3DOS messages and requirements
  40+ B6B8              ;         +3DOS routines
  41+ B6B8              ;
  42+ B6B8              ;
  43+ B6B8              ; This section describes +3DOS - the disk operating system of the
  44+ B6B8              ; +3. The information will probably be of most interest to people
  45+ B6B8              ; familiar with assembly language (machine code) programming (see part
  46+ B6B8              ; 26 of this chapter for more information on this subject). What follows
  47+ B6B8              ; is highly technical, and should not be used by the uninitiated.
  48+ B6B8              ;
  49+ B6B8              ; The operating software of the +3 is, in effect, held in four ROMs
  50+ B6B8              ; (though the information is actually contained in just two ICs). All
  51+ B6B8              ; four ROMs are addressed between 0000h and 3FFFh, although only one is
  52+ B6B8              ; switched in at a time.
  53+ B6B8              ;
  54+ B6B8              ; ROM 0 is the 'editor' ROM and is the one entered when the +3 is first
  55+ B6B8              ; switched on. This controls the high level 'menuing' and editing
  56+ B6B8              ; functions.
  57+ B6B8              ;
  58+ B6B8              ; ROM 1 is the 'syntax' ROM and handles the high level control of +3
  59+ B6B8              ; BASIC. It contains the code for the BASIC parts of most of the disk
  60+ B6B8              ; based commands.
  61+ B6B8              ;
  62+ B6B8              ; ROM 3 is the '48 BASIC' ROM and is virtually identical to the ROM used
  63+ B6B8              ; in the very first Spectrum. The only real area where it is different
  64+ B6B8              ; is in the code executed when an interrupt occurs. If non-zero, a
  65+ B6B8              ; 'ticker' variable is decremented every second interrupt, and when it
  66+ B6B8              ; reaches zero, the disk motor is switched off. This variable is held in
  67+ B6B8              ; page 7 along with some of the editor and DOS variables. Page 7 will
  68+ B6B8              ; only be switched in (and this variable decremented) if bit 4 in the
  69+ B6B8              ; FLAGS system variable is set - this is used by the software to
  70+ B6B8              ; identify whether it is running 48 BASIC or +3 BASIC. When 48 BASIC is
  71+ B6B8              ; selected (from the main menu or by the SPECTRUM command), this bit is
  72+ B6B8              ; reset so that this page-switching and ticker-decrementing won't
  73+ B6B8              ; happen. However, if bit 4 in the FLAGS system variable is subsequently
  74+ B6B8              ; set by your own program, this process will start again while interrupt
  75+ B6B8              ; mode 1 is still selected.
  76+ B6B8              ;
  77+ B6B8              ; The keypad scanning routines of the Spectrum 128 and +2 have been
  78+ B6B8              ; removed from ROM 3 in the +3.
  79+ B6B8              ;
  80+ B6B8              ; A 'bug' in the original 48 BASIC ROM has been fixed in the +3. When a
  81+ B6B8              ; non-maskable interrupt (NMI) occurs, a jump is made to location
  82+ B6B8              ; 66h. This now checks the contents of the NMIADD system variable. If it
  83+ B6B8              ; is zero, a RETN is executed, otherwise a jump is made to the routine
  84+ B6B8              ; address held in NMIADD. The NMI code in ROM 2 consists of just a RETN.
  85+ B6B8              ;
  86+ B6B8              ; ROM 3 not only provides the 48 BASIC mode for program compatibility,
  87+ B6B8              ; but executes the majority of +3 BASIC commands that don't make use of
  88+ B6B8              ; the more advanced hardware of the +3.
  89+ B6B8              ;
  90+ B6B8              ; The fourth ROM (ROM 2) holds +3DOS - the disk operating system. This
  91+ B6B8              ; is the subject of this section. Unlike the other ROMs, which are
  92+ B6B8              ; unlikely to be of much use for assembler programmers (except the 48
  93+ B6B8              ; BASIC ROM perhaps), the +3DOS ROM has a wealth of routines that may
  94+ B6B8              ; well be of use in your own programs. We strongly recommend that any
  95+ B6B8              ; software that uses the disk drives makes use of these routines as they
  96+ B6B8              ; provide most of the facilities that one could wish for (more than are
  97+ B6B8              ; currently used by BASIC, in fact). Furthermore, the routines should
  98+ B6B8              ; only be accessed via the jump block. This not only makes it easier to
  99+ B6B8              ; write software that can be adapted to and from the AMSTRAD CPC range
 100+ B6B8              ; of computers, but also affords upwards compatibility for the
 101+ B6B8              ; future. The entry points for each routine are held in a jump table at
 102+ B6B8              ; address 0100h (256) in the ROM. Part 26 of this chapter gave a couple
 103+ B6B8              ; of examples of the way in which these routines can be called.
 104+ B6B8              ;
 105+ B6B8              ; +3DOS provides the following facilities:
 106+ B6B8              ;
 107+ B6B8              ;         - Support for one or two floppy disk drives and a RAMdisk.
 108+ B6B8              ;         - CP/M Plus and CP/M 2.2 file compatibility.
 109+ B6B8              ;         - AMSTRAD CPC range and PCW range file and media
 110+ B6B8              ;             compatibility.
 111+ B6B8              ;         - Up to 16 files open at the same time.
 112+ B6B8              ;         - Reading and writing files to or from any page in memory.
 113+ B6B8              ;         - Byte level random access.
 114+ B6B8              ;         - Deleting disk files; renaming disk files; changing disk
 115+ B6B8              ;             files' attributes.
 116+ B6B8              ;         - Selecting the default drive and user.
 117+ B6B8              ;         - Booting a game or operating system.
 118+ B6B8              ;         - Low level access to floppy disk driver.
 119+ B6B8              ;         - Optional mapping of two logical drives (A: or B:) onto one
 120+ B6B8              ;             physical drive (unit 0).
 121+ B6B8              ;
 122+ B6B8              ;
 123+ B6B8              ; +3DOS interface
 124+ B6B8              ;
 125+ B6B8              ; +3DOS's interface is a set of routines accessed via a jump block. The
 126+ B6B8              ; routines provided fall into three categories:
 127+ B6B8              ;
 128+ B6B8              ;         - Essential filing system routines.
 129+ B6B8              ;         - Additional routines for games and operating systems.
 130+ B6B8              ;         - Low level floppy disk access routines for disk formatting,
 131+ B6B8              ;             copying, etc.
 132+ B6B8              ;
 133+ B6B8              ; The following is a list of the routines in each of these categories
 134+ B6B8              ; (together with brief descriptions of the routines' functions):
 135+ B6B8              ;
 136+ B6B8              ;
 137+ B6B8              ; Essential filing system routines
 138+ B6B8              ;
 139+ B6B8              ; NAME OF ROUTINE         FUNCTION
 140+ B6B8              ;
 141+ B6B8              ; DOS INITIALISE          Initialise +3DOS
 142+ B6B8              ; DOS VERSION             Get +3DOS issue and version numbers
 143+ B6B8              ; DOS OPEN                Create and/or open a file
 144+ B6B8              ; DOS CLOSE               Close a file
 145+ B6B8              ; DOS ABANDON             Abandon a file
 146+ B6B8              ; DOS REF HEAD            Point at the header data for this file
 147+ B6B8              ; DOS READ                Read bytes into memory
 148+ B6B8              ; DOS WRITE               Write bytes from memory
 149+ B6B8              ; DOS BYTE READ           Read a byte
 150+ B6B8              ; DOS BYTE WRITE          Write a byte
 151+ B6B8              ; DOS CATALOG             Catalog disk directory
 152+ B6B8              ; DOS FREE SPACE          Free space on disk
 153+ B6B8              ; DOS DELETE              Delete a file
 154+ B6B8              ; DOS RENAME              Rename a file
 155+ B6B8              ; DOS BOOT                Boot an operating system or other program
 156+ B6B8              ; DOS SET DRIVE           Set/get default drive
 157+ B6B8              ; DOS SET USER            Set/get default user number
 158+ B6B8              ;
 159+ B6B8              ;
 160+ B6B8              ; Additional routines for games and operating systems
 161+ B6B8              ;
 162+ B6B8              ; NAME OF ROUTINE         FUNCTION
 163+ B6B8              ;
 164+ B6B8              ; DOS GET POSITION        Get file pointer for random access
 165+ B6B8              ; DOS SET POSITION        Set file pointer for random access
 166+ B6B8              ; DOS GET EOF             Get end of file position for random access
 167+ B6B8              ; DOS GET 1346            Get memory usage in pages 1, 3, 4, 6
 168+ B6B8              ; DOS SET 1346            Re-allocate memory usage in pages 1, 3, 4, 6
 169+ B6B8              ; DOS FLUSH               Bring disk up to date
 170+ B6B8              ; DOS SET ACCESS          Change open file's access mode
 171+ B6B8              ; DOS SET ATTRIBUTES      Change a file's attributes
 172+ B6B8              ; DOS OPEN DRIVE          Open a drive as a single file
 173+ B6B8              ; DOS SET MESSAGE         Enable/disable error messages
 174+ B6B8              ; DOS REF XDPB            Point at XDPB for low level disk access
 175+ B6B8              ; DOS MAP B               Map B: onto unit 0 or 1
 176+ B6B8              ;
 177+ B6B8              ;
 178+ B6B8              ; Low level floppy disk driving routines
 179+ B6B8              ;
 180+ B6B8              ; NAME OF ROUTINE         FUNCTION
 181+ B6B8              ;
 182+ B6B8              ; DD INTERFACE            Is the floppy disk driver interface present?
 183+ B6B8              ; DD INIT                 Initialise disk driver
 184+ B6B8              ; DD SETUP                Specify drive parameters
 185+ B6B8              ; DD SET RETRY            Set try/retry count
 186+ B6B8              ; DD READ SECTOR          Read a sector
 187+ B6B8              ; DD WRITE SECTOR         Write a sector
 188+ B6B8              ; DD CHECK SECTOR         Check a sector
 189+ B6B8              ; DD FORMAT               Format a track
 190+ B6B8              ; DD READ ID              Read a sector identifier
 191+ B6B8              ; DD TEST UNSUITABLE      Test media suitability
 192+ B6B8              ; DD LOGIN                Log in disk, initialise XDPB
 193+ B6B8              ; DD SEL FORMAT           Pre-initialise XDPB for DD FORMAT
 194+ B6B8              ; DD ASK 1                Is unit 1 (external drive) present?
 195+ B6B8              ; DD DRIVE STATUS         Fetch drive status
 196+ B6B8              ; DD EQUIPMENT            What type of drive?
 197+ B6B8              ; DD ENCODE               Set intercept routine for copy protection
 198+ B6B8              ; DD L XDPB               Initialise an XDPB from a disk specification
 199+ B6B8              ; DD L DPB                Initialise a DPB from a disk specification
 200+ B6B8              ; DD L SEEK               uPD765A seek driver
 201+ B6B8              ; DD L READ               uPD765A read driver
 202+ B6B8              ; DD L WRITE              uPD765A write driver
 203+ B6B8              ; DD L ON MOTOR           Motor on, wait for motor-on time
 204+ B6B8              ; DD L T OFF MOTOR        Start the motor-off ticker
 205+ B6B8              ; DD L OFF MOTOR          Turn the motor off
 206+ B6B8              ;
 207+ B6B8              ;
 208+ B6B8              ; Games and other non-BASIC programs
 209+ B6B8              ;
 210+ B6B8              ; +3DOS provides facilities specifically for non-BASIC programs:
 211+ B6B8              ;
 212+ B6B8              ; - Use DOS BOOT to load a single bootstrap sector, then take over the
 213+ B6B8              ; whole machine (see the second example in part 26 of this chapter).
 214+ B6B8              ;
 215+ B6B8              ; - Claim some store from +3DOS using DOS SET 1346. This enables a
 216+ B6B8              ; non-BASIC program to take control of the machine but still use the
 217+ B6B8              ; facilities of +3DOS if required. If +3DOS is not required, then the
 218+ B6B8              ; non-BASIC program should call DD L OFF MOTOR to force the drive motor
 219+ B6B8              ; off and disable the motor ticker. Bit 4 in the FLAGS system variable
 220+ B6B8              ; should be reset to prevent any back switching/variable decrementing on
 221+ B6B8              ; interrupt.
 222+ B6B8              ;
 223+ B6B8              ; - A drive can be opened as a single file. This enables files and
 224+ B6B8              ; directories to be examined without going via the file structure.
 225+ B6B8              ;
 226+ B6B8              ;
 227+ B6B8              ; Using +3DOS without a floppy disk interface
 228+ B6B8              ;
 229+ B6B8              ; [This is the case on a +2A.]
 230+ B6B8              ;
 231+ B6B8              ; Even if the floppy disk interface were not present, +3DOS could still
 232+ B6B8              ; be used as follows:
 233+ B6B8              ;
 234+ B6B8              ;         - Only drive M: is available (the RAMdisk).
 235+ B6B8              ;         - The default drive for filenames is initialised to M: rather
 236+ B6B8              ;             than A:.
 237+ B6B8              ;         - Any attempt to use drives A: or B: will fail with error '22
 238+ B6B8              ;             - Drive not found'.
 239+ B6B8              ;         - As the sector cache is not required for use with the
 240+ B6B8              ;             RAMdisk, is increased to 64K (the whole of pages 1, 3, 4,
 241+ B6B8              ;             6). This will give 62K of data and 2K of directory (64
 242+ B6B8              ;             entries).
 243+ B6B8              ;         - The presence of the floppy disk interface can be determined
 244+ B6B8              ;             by calling DD INTERFACE. If the interface were not
 245+ B6B8              ;             present, then none of the other low level floppy disk
 246+ B6B8              ;             routines (DD... etc.) could be called; the effect of doing
 247+ B6B8              ;             so is undefined.
 248+ B6B8              ;
 249+ B6B8              ;
 250+ B6B8              ; File attributes
 251+ B6B8              ;
 252+ B6B8              ; Bit 7 of the name and type field characters are the file
 253+ B6B8              ; attributes. The top bits of the name field characters are denoted
 254+ B6B8              ; f1...f8. The top bits of the type field characters are denoted
 255+ B6B8              ; t1...t3. They have the following meanings:
 256+ B6B8              ;
 257+ B6B8              ;         f1...f4 - Available to the user
 258+ B6B8              ;         f5...f8 - Reserved (always 0)
 259+ B6B8              ;              t1 - 0 means file is read-write; 1 means file is
 260+ B6B8              ;                     read-only
 261+ B6B8              ;              t2 - 0 means not system file; 1 means system file
 262+ B6B8              ;              t3 - 0 means not archived; 1 means archived
 263+ B6B8              ;
 264+ B6B8              ; A read-only file cannot be written to, erased or renamed. System files
 265+ B6B8              ; can, optionally, be omitted from the directory catalog. The archive
 266+ B6B8              ; attribute is ignored by +3DOS.
 267+ B6B8              ;
 268+ B6B8              ; Newly created files have all attributes set to 0. An existing file's
 269+ B6B8              ; attributes can only be changed by DOS SET ATTRIBUTES (as used by
 270+ B6B8              ; BASIC's MOVE command).
 271+ B6B8              ;
 272+ B6B8              ;
 273+ B6B8              ; File headers
 274+ B6B8              ;
 275+ B6B8              ; Tape files have headers which contain some system information. +3DOS
 276+ B6B8              ; files may, or may not, have headers. All files created by BASIC's SAVE
 277+ B6B8              ; command will have headers.
 278+ B6B8              ;
 279+ B6B8              ; The +3DOS header mechanism provides a dedicated 8 byte area in each
 280+ B6B8              ; headed file reserved for BASIC's use. The remainder of the header is
 281+ B6B8              ; reserved for +3DOS. This 8 byte header is utilised in files created by
 282+ B6B8              ; BASIC commands (see DOS OPEN description).
 283+ B6B8              ;
 284+ B6B8              ; +3DOS files may have a single header in the first 128 bytes of the
 285+ B6B8              ; file - the header record. These headers are detected by a 'signature'
 286+ B6B8              ; and checksum. If the signature and checksum are as expected, then a
 287+ B6B8              ; header is present; if not, these is no header. Thus, it is possible,
 288+ B6B8              ; but unlikely, that a file without a header could be mistaken for one
 289+ B6B8              ; with a header.
 290+ B6B8              ;
 291+ B6B8              ; The format of the header record is as follows:
 292+ B6B8              ;
 293+ B6B8              ;         Bytes 0...7     - +3DOS signature - 'PLUS3DOS'
 294+ B6B8              ;         Byte 8          - 1Ah (26) Soft-EOF (end of file)
 295+ B6B8              ;         Byte 9          - Issue number
 296+ B6B8              ;         Byte 10         - Version number
 297+ B6B8              ;         Bytes 11...14   - Length of the file in bytes, 32 bit number,
 298+ B6B8              ;                             least significant byte in lowest address
 299+ B6B8              ;         Bytes 15...22   - +3 BASIC header data
 300+ B6B8              ;         Bytes 23...126  - Reserved (set to 0)
 301+ B6B8              ;         Byte 127        - Checksum (sum of bytes 0...126 modulo 256)
 302+ B6B8              ;
 303+ B6B8              ; The issue and version numbers are provided for any future
 304+ B6B8              ; expansion. The issue number must equal the software's issue number;
 305+ B6B8              ; the version number must be less than or equal to the software's
 306+ B6B8              ; version number.
 307+ B6B8              ;
 308+ B6B8              ; +3DOS performs all the necessary header 'house-keeping'. A pointer to
 309+ B6B8              ; +3 BASIC's 8 byte header area may be returned using DOS REF HEAD. It
 310+ B6B8              ; is never necessary to write directly to the 128 byte header.
 311+ B6B8              ;
 312+ B6B8              ; AMSDOS headers (as used on the AMSTRAD CPC range of computers) will
 313+ B6B8              ; not be recognised. AMSDOS files will be treated by +3DOS as
 314+ B6B8              ; headerless, and vice versa.
 315+ B6B8              ;
 316+ B6B8              ;
 317+ B6B8              ; Disk formats
 318+ B6B8              ;
 319+ B6B8              ; +3DOS supports exactly the same disk format as CP/M Plus and
 320+ B6B8              ; LocoScript on the AMSTRAD PCW range of computer/word processors
 321+ B6B8              ; (i.e. the first format listed below).
 322+ B6B8              ;
 323+ B6B8              ; The following formats are automatically detected when the disk is
 324+ B6B8              ; first accessed:
 325+ B6B8              ;
 326+ B6B8              ;         - AMSTRAD PCW range single track (e.g. as used on model
 327+ B6B8              ;             PCW8256)
 328+ B6B8              ;         - AMSTRAD PCW range double track (e.g. as used on model
 329+ B6B8              ;             PCW8512)
 330+ B6B8              ;         - AMSTRAD CPC range system format
 331+ B6B8              ;         - AMSTRAD CPC range vendor format
 332+ B6B8              ;         - AMSTRAD CPC range data only format
 333+ B6B8              ;
 334+ B6B8              ; Note that the AMSTRAD CPC range's IBM format is not supported.
 335+ B6B8              ;
 336+ B6B8              ; Other disk formats can be used by patching the XDPB for a drive. The
 337+ B6B8              ; XDPB is the same as for the first format listed above; it is not the
 338+ B6B8              ; same as on the CPC range.
 339+ B6B8              ;
 340+ B6B8              ; Disk formats are subject to the following restrictions:
 341+ B6B8              ;
 342+ B6B8              ;         - 512 byte sector size
 343+ B6B8              ;         - Maximum of 255 sectors per track
 344+ B6B8              ;         - Maximum of 255 tracks
 345+ B6B8              ;         - Maximum of 256 directory entries
 346+ B6B8              ;         - Maximum of 360 allocation units
 347+ B6B8              ;
 348+ B6B8              ;
 349+ B6B8              ; Logical tracks and sectors
 350+ B6B8              ;
 351+ B6B8              ; The disk driver routines require 'logical' tracks and sectors. These
 352+ B6B8              ; are used to hide information concerning the number of sides and the
 353+ B6B8              ; actual sector numbers from +3DOS, which knows nothing about them.
 354+ B6B8              ;
 355+ B6B8              ; Logical track numbers on a single sided disk are the same as physical
 356+ B6B8              ; track numbers.
 357+ B6B8              ;
 358+ B6B8              ; For double sided disks, two options are available:
 359+ B6B8              ;
 360+ B6B8              ; 1. Alternating sides...
 361+ B6B8              ;
 362+ B6B8              ;         side 0 track 0 = logical track 0
 363+ B6B8              ;         side 1 track 0 = logical track 1
 364+ B6B8              ;         side 0 track 1 = logical track 2
 365+ B6B8              ;         side 1 track 1 = logical track 3
 366+ B6B8              ;         ...to...
 367+ B6B8              ;         side 0 last track = logical track n-1
 368+ B6B8              ;         side 1 last track = logical track n
 369+ B6B8              ;
 370+ B6B8              ; 2. Successive sides...
 371+ B6B8              ;
 372+ B6B8              ;         side 0 track 0 = logical track 0
 373+ B6B8              ;         side 0 track 1 = logical track 1
 374+ B6B8              ;         side 0 track 2 = logical track 2
 375+ B6B8              ;         ...to...
 376+ B6B8              ;         side 0 last track = logical track n/2-1
 377+ B6B8              ;         ...and then...
 378+ B6B8              ;         side 1 last track-1 = logical track n/2
 379+ B6B8              ;         side 1 last track-2 = logical track n/2+1
 380+ B6B8              ;         side 1 last track-3 = logical track n/2+2
 381+ B6B8              ;         ...to...
 382+ B6B8              ;         side 1 track 0 = logical track n
 383+ B6B8              ;
 384+ B6B8              ; ...where n is the total number of logical tracks (i.e. 2 x number of
 385+ B6B8              ; tracks per side).
 386+ B6B8              ;
 387+ B6B8              ; Logical sectors hide the actual physical sector numbers. Logical
 388+ B6B8              ; sector numbers always start from 0.
 389+ B6B8              ;
 390+ B6B8              ;         Logical sector = physical sector - first sector
 391+ B6B8              ;
 392+ B6B8              ;
 393+ B6B8              ; Disk specification
 394+ B6B8              ;
 395+ B6B8              ; The PCW range disk format (used by the +3) is, in fact, a family of
 396+ B6B8              ; formats the precise member of which is defined in the 'disk
 397+ B6B8              ; specification' which is recorded on bytes 0...15 of sector 1, track 0
 398+ B6B8              ; side 0. The format used on the +3 is the same as disk type 0
 399+ B6B8              ; below. The sector holding this specification is also that used for a
 400+ B6B8              ; bootstrap program. An example of how it may be set up is shown in the
 401+ B6B8              ; second example in part 26 of this chapter.
 402+ B6B8              ;
 403+ B6B8              ; Byte 0          Disk type
 404+ B6B8              ;                         0 = Standard PCW range DD SS ST (and +3)
 405+ B6B8              ;                         1 = Standard CPC range DD SS ST system format
 406+ B6B8              ;                         2 = Standard CPC range DD SS ST data only format
 407+ B6B8              ;                         3 = Standard PCW range DD DS DT
 408+ B6B8              ;                         All other values reserved
 409+ B6B8              ;
 410+ B6B8              ; Byte 1          Bits 0...1 Sidedness
 411+ B6B8              ;                         0 = Single sided
 412+ B6B8              ;                         1 = Double sided (alternating sides)
 413+ B6B8              ;                         2 = Double sided (successive sides)
 414+ B6B8              ;                 Bits 2...6 Reserved (set to 0)
 415+ B6B8              ;                 Bit 7 Double track
 416+ B6B8              ;
 417+ B6B8              ; Byte 2          Number of tracks per side
 418+ B6B8              ;
 419+ B6B8              ; Byte 3          Number of sectors per track
 420+ B6B8              ;
 421+ B6B8              ; Byte 4          Log2(sector size) - 7
 422+ B6B8              ;
 423+ B6B8              ; Byte 5          Number of reserved tracks
 424+ B6B8              ;
 425+ B6B8              ; Byte 6          Log2(block size / 128)
 426+ B6B8              ;
 427+ B6B8              ; Byte 7          Number of directory blocks
 428+ B6B8              ;
 429+ B6B8              ; Byte 8          Gap length (read/write)
 430+ B6B8              ;
 431+ B6B8              ; Byte 9          Gap length (format)
 432+ B6B8              ;
 433+ B6B8              ; Bytes 10...14   Reserved
 434+ B6B8              ;
 435+ B6B8              ; Byte 15         Checksum (used only if disk is bootable)
 436+ B6B8              ;
 437+ B6B8              ;
 438+ B6B8              ; When a disk is logged on, the disk specification is used to initialise
 439+ B6B8              ; the relevant XDPB.
 440+ B6B8              ;
 441+ B6B8              ;
 442+ B6B8              ; Extended disk parameter blocks (XDPB)
 443+ B6B8              ;
 444+ B6B8              ; Associated with each (logical) drive is an extended disk parameter
 445+ B6B8              ; block (XDPB). This contains a standard DPB which is the same as that
 446+ B6B8              ; used by CP/M Plus. It also contains information required by +3DOS to
 447+ B6B8              ; support the different formats. It may be patched in order to use
 448+ B6B8              ; differently formatted disks (provided that the restrictions detailed
 449+ B6B8              ; in the previous table are obeyed).
 450+ B6B8              ;
 451+ B6B8              ; XDPB structure:
 452+ B6B8              ;
 453+ B6B8              ; Bytes 0...1     SPT records per track
 454+ B6B8              ; Byte 2          BSH log2(block size / 128)
 455+ B6B8              ; Byte 3          BLM block size / 128 - 1
 456+ B6B8              ; Byte 4          EXM extent mask
 457+ B6B8              ; Bytes 5...6     DSM last block number
 458+ B6B8              ; Bytes 7...8     DRM last directory entry number
 459+ B6B8              ; Byte 9          AL0 directory bit map
 460+ B6B8              ; Byte 10         AL1 directory bit map
 461+ B6B8              ; Bytes 11...12   CKS size of checksum vector (bit 15 = permanent)
 462+ B6B8              ; Bytes 13...14   OFF number of reserved tracks
 463+ B6B8              ; Byte 15         PSH log2(sector size / 128)
 464+ B6B8              ; Byte 16         PHM sector size / 128 - 1
 465+ B6B8              ; Byte 17         Bits 0...1 Sidedness
 466+ B6B8              ;                         0 = Single sided
 467+ B6B8              ;                         1 = Double sided (alternating sides)
 468+ B6B8              ;                         2 = Double sided (successive sides)
 469+ B6B8              ;                 Bits 2...6 Reserved (set to 0)
 470+ B6B8              ;                 Bit 7 Double track
 471+ B6B8              ; Byte 18         Number of tracks per side
 472+ B6B8              ; Byte 19         Number of sectors per track
 473+ B6B8              ; Byte 20         First sector number
 474+ B6B8              ; Bytes 21...22   Sector size
 475+ B6B8              ; Byte 23         Gap length (read/write)
 476+ B6B8              ; Byte 24         Gap length (format)
 477+ B6B8              ; Byte 25         Bit 7 Multi-track operation
 478+ B6B8              ;                         1 = multi-track
 479+ B6B8              ;                         0 = single track
 480+ B6B8              ;                 Bit 6 Modulation mode
 481+ B6B8              ;                         1 = MFM mode
 482+ B6B8              ;                         0 = FM mode
 483+ B6B8              ;                 Bit 5 Skip deleted data address mark
 484+ B6B8              ;                         1 = skip deleted data address mark
 485+ B6B8              ;                         0 = don't skip deleted address mark
 486+ B6B8              ;                 Bits 0...4 = 0
 487+ B6B8              ; Byte 26         Freeze flag
 488+ B6B8              ;                         00h (0) = auto-detect disk format
 489+ B6B8              ;                         FFh (255) = don't auto-detect disk format
 490+ B6B8              ;
 491+ B6B8              ; Byte 25 is normally set to 60h (96). Multi-track operation is not
 492+ B6B8              ; recommended.
 493+ B6B8              ;
 494+ B6B8              ; Setting the freeze flag (byte 26) prevents +3DOS from trying to
 495+ B6B8              ; determine the format of a disk. This should be used when patching an
 496+ B6B8              ; XDPB for a non-standard format.
 497+ B6B8              ;
 498+ B6B8              ; The XDPBs for the three main formats are as follows:
 499+ B6B8              ;
 500+ B6B8              ; AMSTRAD PCW range single track format (type 0)
 501+ B6B8              ; (As used by the +3)
 502+ B6B8              ;
 503+ B6B8              ; 36              SPT, records per track
 504+ B6B8              ; 3               BSH, block shift
 505+ B6B8              ; 7               BLM, block mask
 506+ B6B8              ; 0               EXM, extent mask
 507+ B6B8              ; 174             DSM, number of blocks - 1
 508+ B6B8              ; 63              DRM, number of directory entries - 1
 509+ B6B8              ; C0h (192)       AL0, 2 directory blocks
 510+ B6B8              ; 00h (0)         AL1
 511+ B6B8              ; 16              CKS, size of checksum vector
 512+ B6B8              ; 1               OFF, reserved tracks
 513+ B6B8              ; 2               PSH, physical sector shift
 514+ B6B8              ; 3               PHM, physical sector mask
 515+ B6B8              ;
 516+ B6B8              ; 0               Single sided
 517+ B6B8              ; 40              Tracks per side
 518+ B6B8              ; 9               Sectors per track
 519+ B6B8              ; 1               First sector number
 520+ B6B8              ; 512             Sector size
 521+ B6B8              ; 42              Gap length (read/write)
 522+ B6B8              ; 82              Gap length (format)
 523+ B6B8              ; 60h (96)        MFM mode, skip deleted data address mark
 524+ B6B8              ; 0               Do auto select format
 525+ B6B8              ;
 526+ B6B8              ;
 527+ B6B8              ; AMSTRAD CPC range SYSTEM format (type 1)
 528+ B6B8              ;
 529+ B6B8              ; 36              SPT, records per track
 530+ B6B8              ; 3               BSH, block shift
 531+ B6B8              ; 7               BLM, block mask
 532+ B6B8              ; 0               EXM, extent mask
 533+ B6B8              ; 170             DSM, number of blocks - 1
 534+ B6B8              ; 63              DRM, number of directory entries - 1
 535+ B6B8              ; C0h (192)       AL0, 2 directory blocks
 536+ B6B8              ; 00h (0)         AL1
 537+ B6B8              ; 16              CKS, size of checksum vector
 538+ B6B8              ; 2               OFF, reserved tracks
 539+ B6B8              ; 2               PSH, physical sector shift
 540+ B6B8              ; 3               PHM, physical sector mask
 541+ B6B8              ;
 542+ B6B8              ; 0               Single sided
 543+ B6B8              ; 40              Tracks per side
 544+ B6B8              ; 9               Sectors per track
 545+ B6B8              ; 41h (65)        First sector number
 546+ B6B8              ; 512             Sector size
 547+ B6B8              ; 42              Gap length (read/write)
 548+ B6B8              ; 82              Gap length (format)
 549+ B6B8              ; 60h (96)        MFM mode, skip deleted data address mark
 550+ B6B8              ; 0               Do auto select format
 551+ B6B8              ;
 552+ B6B8              ;
 553+ B6B8              ; AMSTRAD CPC range DATA ONLY format (type 2)
 554+ B6B8              ;
 555+ B6B8              ; 36              SPT, records per track
 556+ B6B8              ; 3               BSH, block shift
 557+ B6B8              ; 7               BLM, block mask
 558+ B6B8              ; 0               EXM, extent mask
 559+ B6B8              ; 179             DSM, number of blocks - 1
 560+ B6B8              ; 63              DRM, number of directory entries - 1
 561+ B6B8              ; C0h (192)       AL0, 2 directory blocks
 562+ B6B8              ; 00h (0)         AL1
 563+ B6B8              ; 16              CKS, size of checksum vector
 564+ B6B8              ; 0               OFF, reserved tracks
 565+ B6B8              ; 2               PSH, physical sector shift
 566+ B6B8              ; 3               PHM, physical sector mask
 567+ B6B8              ;
 568+ B6B8              ; 0               Single sided
 569+ B6B8              ; 40              Tracks per side
 570+ B6B8              ; 9               Sectors per track
 571+ B6B8              ; C1h (193)       First sector number
 572+ B6B8              ; 512             Sector size
 573+ B6B8              ; 42              Gap length (read/write)
 574+ B6B8              ; 82              Gap length (format)
 575+ B6B8              ; 60h (96)        MFM mode, skip deleted data address mark
 576+ B6B8              ; 0               Do auto select format
 577+ B6B8              ;
 578+ B6B8              ;
 579+ B6B8              ; CP/M File compatibility
 580+ B6B8              ;
 581+ B6B8              ; +3DOS uses the CP/M file structure, subject to the following
 582+ B6B8              ; restrictions:
 583+ B6B8              ;
 584+ B6B8              ;         - Maximum file size of 8 megabytes (CP/M Plus supports a
 585+ B6B8              ;             maximum of 32 megabytes).
 586+ B6B8              ;
 587+ B6B8              ;         - Maximum drive size of 8 megabytes (CP/M Plus supports a
 588+ B6B8              ;             maximum of 128 megabytes).
 589+ B6B8              ;
 590+ B6B8              ;         - Directory labels are ignored.
 591+ B6B8              ;
 592+ B6B8              ;         - No passwords. XFCBs will be erased, renamed, etc., along
 593+ B6B8              ;             with their file(s) but are otherwise ignored.
 594+ B6B8              ;
 595+ B6B8              ;         - No date and time stamps. SFCBs are initialised to zero when
 596+ B6B8              ;             a file is created, but are otherwise ignored.
 597+ B6B8              ;
 598+ B6B8              ;         - The archive file attribute is ignored, i.e. it is unaffected
 599+ B6B8              ;             by all routines except DOS SET ATTRIBUTES.
 600+ B6B8              ;
 601+ B6B8              ;
 602+ B6B8              ; File model
 603+ B6B8              ;
 604+ B6B8              ; A file is an array of bytes which may be of any length from 0 to 8
 605+ B6B8              ; megabytes. Associated with each open file is a 24 bit file
 606+ B6B8              ; pointer. The file pointer is the address of the next byte to be
 607+ B6B8              ; written or read. The file pointer is automatically advanced after each
 608+ B6B8              ; read or write operation, however, the user may set it to any value
 609+ B6B8              ; required for random access.
 610+ B6B8              ;
 611+ B6B8              ; The end of file position (EOF) is the lowest byte position that is
 612+ B6B8              ; greater than all written byte positions. Files without headers can
 613+ B6B8              ; only record their EOF position to the start of the next 128 byte
 614+ B6B8              ; record, i.e. ceiling(EOF/128). Files with headers have their EOF
 615+ B6B8              ; position recorded exactly.
 616+ B6B8              ;
 617+ B6B8              ; Writing a byte after the EOF position will extend the file and advance
 618+ B6B8              ; the EOF position.
 619+ B6B8              ;
 620+ B6B8              ; Reading a byte at (or beyond) the EOF position will return an EOF
 621+ B6B8              ; error.
 622+ B6B8              ;
 623+ B6B8              ; Reading an unwritten byte below the EOF position will either return a
 624+ B6B8              ; nonsensical byte or an EOF error. (Reading unwritten bytes is not
 625+ B6B8              ; recommended.)
 626+ B6B8              ;
 627+ B6B8              ;
 628+ B6B8              ; Changing disks
 629+ B6B8              ;
 630+ B6B8              ; Under +3DOS, a disk may be changed or removed whenever the drive is
 631+ B6B8              ; not being accessed (and there are no files open on that drive). There
 632+ B6B8              ; is no need to log in a disk.
 633+ B6B8              ;
 634+ B6B8              ; A disk should not be changed while there are files open on it. If,
 635+ B6B8              ; however, a disk is changed while there are still files open on it,
 636+ B6B8              ; then as soon as +3DOS detects this, the user will be prompted to
 637+ B6B8              ; insert the correct disk. +3DOS can only detect this changed when it
 638+ B6B8              ; reads the directory from the disk.
 639+ B6B8              ;
 640+ B6B8              ; Note that changing a disk while it is still being written to may
 641+ B6B8              ; corrupt the data on the disk.
 642+ B6B8              ;
 643+ B6B8              ;
 644+ B6B8              ; Logical to physical drive mapping
 645+ B6B8              ;
 646+ B6B8              ; If required, two logical drives (A: and B:) can be mapped onto a
 647+ B6B8              ; single physical drive (unit 0). This may be useful for single disk
 648+ B6B8              ; drive systems.
 649+ B6B8              ;
 650+ B6B8              ; To enable this mapping, the routine DOS MAP B is called, passing to it
 651+ B6B8              ; the address of a routine CHANGE DISK. Whenever unit 0 is accessed, a
 652+ B6B8              ; check is made to see if the disk in unit 0 is for the required logical
 653+ B6B8              ; drive. If not, then CHANGE DISK is called. CHANGE DISK is passed the
 654+ B6B8              ; address of a message and the required logical drive, and the user
 655+ B6B8              ; should be prompted with the message...
 656+ B6B8              ;
 657+ B6B8              ;         Please put the disk for x: into the drive then press any key
 658+ B6B8              ;
 659+ B6B8              ; ...(where x is the name of the logical drive, e.g. 'A:' or 'B:'). The
 660+ B6B8              ; routine should then wait for a key to be pressed before returning,
 661+ B6B8              ; after which it is assumed that the disk in unit 0 is for the required
 662+ B6B8              ; logical drive.
 663+ B6B8              ;
 664+ B6B8              ; DOS MAP B can also be used to re-map B onto unit 1. If unit 1 does not
 665+ B6B8              ; exist, then drive B: is disabled.
 666+ B6B8              ;
 667+ B6B8              ;
 668+ B6B8              ; +3DOS Error codes
 669+ B6B8              ;
 670+ B6B8              ; Many +3DOS routines can fail. This is indicated with 'carry' false and
 671+ B6B8              ; an error code in the A register. The error codes are...
 672+ B6B8              ;
 673+ B6B8              ; Recoverable disk errors:
 674+ B6B8              ;
 675+ B6B8              ; 0       Drive not ready
 676+ B6B8              ; 1       Disk is write protected
 677+ B6B8              ; 2       Seek fail
 678+ B6B8              ; 3       CRC data error
 679+ B6B8              ; 4       No data
 680+ B6B8              ; 5       Missing address mark
 681+ B6B8              ; 6       Unrecognised disk format
 682+ B6B8              ; 7       Unknown disk error
 683+ B6B8              ; 8       Disk changed whilst +3DOS was using it
 684+ B6B8              ; 9       Unsuitable media for drive
 685+ B6B8              ;
 686+ B6B8              ; Non-recoverable errors:
 687+ B6B8              ;
 688+ B6B8              ; 20      Bad filename
 689+ B6B8              ; 21      Bad parameter
 690+ B6B8              ; 22      Drive not found
 691+ B6B8              ; 23      File not found
 692+ B6B8              ; 24      File already exists
 693+ B6B8              ; 25      End of file
 694+ B6B8              ; 26      Disk full
 695+ B6B8              ; 27      Directory full
 696+ B6B8              ; 28      Read-only file
 697+ B6B8              ; 29      File number not open (or open with wrong access)
 698+ B6B8              ; 30      Access denied (file is in use already)
 699+ B6B8              ; 31      Cannot rename between drives
 700+ B6B8              ; 32      Extent missing (which should be there)
 701+ B6B8              ; 33      Uncached (software error)
 702+ B6B8              ; 34      File too big (trying to read or write past 8 megabytes)
 703+ B6B8              ; 35      Disk not bootable (boot sector is not acceptable to DOS BOOT)
 704+ B6B8              ; 36      Drive in use (trying to re-map or remove a drive with files
 705+ B6B8              ;           open)
 706+ B6B8              ;
 707+ B6B8              ; As an example, the report 'Unsuitable media for drive' is caused by
 708+ B6B8              ; trying to write to a single track disk in a double track drive, or
 709+ B6B8              ; trying to read or write a double track disk in a single track drive.
 710+ B6B8              ;
 711+ B6B8              ; The report 'Missing address mark' is the error returned when trying to
 712+ B6B8              ; access a disk that is not formatted (although this is not the sole
 713+ B6B8              ; reason for the error).
 714+ B6B8              ;
 715+ B6B8              ;
 716+ B6B8              ; +3DOS Messages
 717+ B6B8              ;
 718+ B6B8              ; If error messages are enabled (DOS SET MESSAGE) then, in the event of
 719+ B6B8              ; a recoverable disk error, +3DOS will pass the ALERT routine a message
 720+ B6B8              ; and the user should be prompted to '- Retry, Ignore or Cancel?' If the
 721+ B6B8              ; user replies 'R', then the disk operation is retried. If the reply is
 722+ B6B8              ; 'I', then the error is ignored, and if the reply is 'C', then the
 723+ B6B8              ; operation is cancelled and an error condition is returned to the
 724+ B6B8              ; caller. If error messages are disabled or if the error is not
 725+ B6B8              ; recoverable, then no message is displayed and an error condition is
 726+ B6B8              ; returned to the caller.
 727+ B6B8              ;
 728+ B6B8              ;
 729+ B6B8              ; Essential filing system routines
 730+ B6B8              ;
 731+ B6B8
 732+ B6B8              dos_initialise: equ 0x0100 ; (256)
 733+ B6B8
 734+ B6B8              ; Initialise +3DOS.
 735+ B6B8              ; Initialise disk drivers.
 736+ B6B8              ; Initialise cache and the RAMdisk.
 737+ B6B8              ; All files closed.
 738+ B6B8              ; All drives logged out.
 739+ B6B8              ; Default drive A: (if disk interface present), else M:.
 740+ B6B8              ; Default user 0.
 741+ B6B8              ; Retry count 15.
 742+ B6B8              ; Error messages disabled.
 743+ B6B8              ;
 744+ B6B8              ; ENTRY CONDITIONS
 745+ B6B8              ;         None
 746+ B6B8              ;
 747+ B6B8              ; EXIT CONDITIONS
 748+ B6B8              ;         If OK:
 749+ B6B8              ;                 Carry true
 750+ B6B8              ;                 A corrupt
 751+ B6B8              ;         Otherwise:
 752+ B6B8              ;                 Carry false
 753+ B6B8              ;                 A=Error code
 754+ B6B8              ;         Always:
 755+ B6B8              ;                 BC DE HL IX corrupt
 756+ B6B8              ;                 All other registers preserved
 757+ B6B8              ;
 758+ B6B8              ;
 759+ B6B8
 760+ B6B8              dos_version: equ 0x0103 ; (259)
 761+ B6B8
 762+ B6B8              ; Get the DOS issue and version numbers.
 763+ B6B8              ;
 764+ B6B8              ; ENTRY CONDITIONS
 765+ B6B8              ;         None
 766+ B6B8              ;
 767+ B6B8              ; EXIT CONDITIONS
 768+ B6B8              ;                 D=Issue
 769+ B6B8              ;                 E=Version (within issue)
 770+ B6B8              ;         Always:
 771+ B6B8              ;                 AF BC HL IX corrupt
 772+ B6B8              ;                 All other registers preserved
 773+ B6B8              ;
 774+ B6B8              ;
 775+ B6B8
 776+ B6B8              dos_open: equ 0x0106 ; (262)
 777+ B6B8
 778+ B6B8              ; Create and/or open a file
 779+ B6B8              ;
 780+ B6B8              ; There is a choice of action depending on whether or not the file
 781+ B6B8              ; already exists. The choices are 'open action' or 'create action', and
 782+ B6B8              ; are specified in DE. If the file already exists, then the open action
 783+ B6B8              ; is followed; otherwise the create action is followed.
 784+ B6B8              ;
 785+ B6B8              ; Open action
 786+ B6B8              ;
 787+ B6B8              ;         0. Error - File already exists.
 788+ B6B8              ;
 789+ B6B8              ;         1. Open the file, read the header (if any). Position file
 790+ B6B8              ;            pointer after header.
 791+ B6B8              ;
 792+ B6B8              ;         2. Open the file, ignore any header. Position file pointer at
 793+ B6B8              ;            000000h (0).
 794+ B6B8              ;
 795+ B6B8              ;         3. Assume given filename is 'filename.type'. Erase
 796+ B6B8              ;            'filename.BAK' (if it exists). Rename 'filename.type' to
 797+ B6B8              ;            'filename.BAK'. Follow create action.
 798+ B6B8              ;
 799+ B6B8              ;         4. Erase existing version. Follow create action.
 800+ B6B8              ;
 801+ B6B8              ; Create action
 802+ B6B8              ;
 803+ B6B8              ;         0. Error - File does not exist.
 804+ B6B8              ;
 805+ B6B8              ;         1. Create and open new file with a header. Position file
 806+ B6B8              ;            pointer after header.
 807+ B6B8              ;
 808+ B6B8              ;         2. Create and open new file without a header. Position file
 809+ B6B8              ;            pointer at 000000h (0).
 810+ B6B8              ;
 811+ B6B8              ; (Example: To simulate the tape action of... 'if the file exists open
 812+ B6B8              ; it, otherwise create it with a header', set open action = 1, create
 813+ B6B8              ; action = 1.)
 814+ B6B8              ;
 815+ B6B8              ; (Example: To open a file and report an error if it does not exist, set
 816+ B6B8              ; open action = 1, create action = 0.)
 817+ B6B8              ;
 818+ B6B8              ; (Example: To create a new file with a header, first renaming any
 819+ B6B8              ; existing version to '.BAK', set open action = 3, create action = 1.)
 820+ B6B8              ;
 821+ B6B8              ; Files with headers have their EOF position recorded as the smallest
 822+ B6B8              ; byte position greater than all written byte positions.
 823+ B6B8              ;
 824+ B6B8              ; Files without headers have their EOF position recorded as the byte at
 825+ B6B8              ; the start of the smallest 128 byte record position greater than all
 826+ B6B8              ; written record positions.
 827+ B6B8              ;
 828+ B6B8              ; Soft-EOF is the character 1Ah (26) and is nothing to do with the EOF
 829+ B6B8              ; position, only the routine DOS BYTE READ knows about soft-EOF.
 830+ B6B8              ;
 831+ B6B8              ; The header data area is 8 bytes long and may be used by the caller for
 832+ B6B8              ; any purpose whatsoever. If open action = 1, and the file exists (and
 833+ B6B8              ; has a header), then the header data is read from the file, otherwise
 834+ B6B8              ; the header data is zeroised. The header data is available even if the
 835+ B6B8              ; file does not have a header. Call DOS REF HEAD to access the header
 836+ B6B8              ; data.
 837+ B6B8              ;
 838+ B6B8              ; Note that +3 BASIC makes use of the first 7 of these 8 bytes as
 839+ B6B8              ; follows:
 840+ B6B8              ;
 841+ B6B8              ; +---------------+-------+-------+-------+-------+-------+-------+-------+
 842+ B6B8              ; | BYTE          |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
 843+ B6B8              ; +---------------+-------+-------+-------+-------+-------+-------+-------+
 844+ B6B8              ; | Program           0   file length     8000h or LINE   offset to prog  |
 845+ B6B8              ; | Numeric array     1   file length     xxx     name    xxx     xxx     |
 846+ B6B8              ; | Character array   2   file length     xxx     name    xxx     xxx     |
 847+ B6B8              ; | CODE or SCREEN$   3   file length     load address    xxx     xxx     |
 848+ B6B8              ; +-----------------------------------------------------------------------+
 849+ B6B8              ;
 850+ B6B8              ; (xxx = doesn't matter)
 851+ B6B8              ;
 852+ B6B8              ; If creating a file that will subsequently be LOADed within BASIC, then
 853+ B6B8              ; these bytes should be filled with the relevant values.
 854+ B6B8              ;
 855+ B6B8              ; If the file is opened with exclusive-write or exclusive-read-write
 856+ B6B8              ; access (and the file has a header), then the header is updated when
 857+ B6B8              ; the file is closed.
 858+ B6B8              ;
 859+ B6B8              ; A file that is already open for shared-read access on another file
 860+ B6B8              ; number may only be opened for shared-read access on this file number.
 861+ B6B8              ;
 862+ B6B8              ; A file that is already open for exclusive-read or exclusive-write or
 863+ B6B8              ; exclusive-read-write access on another file number may not be opened
 864+ B6B8              ; on this file number.
 865+ B6B8              ;
 866+ B6B8              ; ENTRY CONDITIONS
 867+ B6B8              ;         B = File number 0...15
 868+ B6B8              ;         C = Access mode required
 869+ B6B8              ;                 Bits 0...2 values:
 870+ B6B8              ;                         1 = exclusive-read
 871+ B6B8              ;                         2 = exclusive-write
 872+ B6B8              ;                         3 = exclusive-read-write
 873+ B6B8              ;                         5 = shared-read
 874+ B6B8              ;                 Bits 3...7 = 0 (reserved)
 875+ B6B8              ;         D = Create action
 876+ B6B8              ;         E = Open action
 877+ B6B8              ;         HL = Address of filename (no wildcards)
 878+ B6B8              ;
 879+ B6B8              ; EXIT CONDITIONS
 880+ B6B8              ;         If file newly created:
 881+ B6B8              ;                 Carry true
 882+ B6B8              ;                 Zero true
 883+ B6B8              ;                 A corrupt
 884+ B6B8              ;         If existing file opened:
 885+ B6B8              ;                 Carry true
 886+ B6B8              ;                 Zero false
 887+ B6B8              ;                 A corrupt
 888+ B6B8              ;         Otherwise:
 889+ B6B8              ;                 Carry false
 890+ B6B8              ;                 A = Error code
 891+ B6B8              ;         Always:
 892+ B6B8              ;                 BC DE HL IX corrupt
 893+ B6B8              ;                 All other registers preserved
 894+ B6B8              ;
 895+ B6B8              ;
 896+ B6B8
 897+ B6B8              dos_close: equ 0x0109 ; (265)
 898+ B6B8
 899+ B6B8              ; Close a file.
 900+ B6B8              ;
 901+ B6B8              ; Write the header (if there is one).
 902+ B6B8              ;
 903+ B6B8              ; Write any outstanding data.
 904+ B6B8              ;
 905+ B6B8              ; Update the directory.
 906+ B6B8              ;
 907+ B6B8              ; Release the file number.
 908+ B6B8              ;
 909+ B6B8              ; All opened files must eventually be closed (or abandoned). A file
 910+ B6B8              ; number cannot be reused until it is closed (or abandoned).
 911+ B6B8              ;
 912+ B6B8              ; ENTRY CONDITIONS
 913+ B6B8              ;         B = File number
 914+ B6B8              ;
 915+ B6B8              ; EXIT CONDITIONS
 916+ B6B8              ;         If OK:
 917+ B6B8              ;                 Carry true
 918+ B6B8              ;                 A corrupt
 919+ B6B8              ;         Otherwise:
 920+ B6B8              ;                 Carry false
 921+ B6B8              ;                 A = Error code
 922+ B6B8              ;         Always:
 923+ B6B8              ;                 BC DE HL IX corrupt
 924+ B6B8              ;                 All other registers preserved
 925+ B6B8              ;
 926+ B6B8              ;
 927+ B6B8
 928+ B6B8              dos_abandon: equ 0x010C ; (268)
 929+ B6B8
 930+ B6B8              ; Abandon a file.
 931+ B6B8              ;
 932+ B6B8              ; Similar to DOS CLOSE, except that any header, or data, or directory
 933+ B6B8              ; data yet to be written to disk is discarded. This routine should only
 934+ B6B8              ; be used to force a file closed in the event that DOS CLOSE is unable
 935+ B6B8              ; to close the file (for example, if the media is damaged or permanently
 936+ B6B8              ; changed or removed).
 937+ B6B8              ;
 938+ B6B8              ; ENTRY CONDITIONS
 939+ B6B8              ;         B = File number
 940+ B6B8              ;
 941+ B6B8              ; EXIT CONDITIONS
 942+ B6B8              ;         If OK:
 943+ B6B8              ;                 Carry true
 944+ B6B8              ;                 A corrupt
 945+ B6B8              ;         Otherwise:
 946+ B6B8              ;                 Carry false
 947+ B6B8              ;                 A = Error code
 948+ B6B8              ;         Always:
 949+ B6B8              ;                 BC DE HL IX corrupt
 950+ B6B8              ;                 All other registers preserved
 951+ B6B8              ;
 952+ B6B8              ;
 953+ B6B8
 954+ B6B8              dos_ref_head: equ 0x010F ; (271)
 955+ B6B8
 956+ B6B8              ; Point at the header data for this file.
 957+ B6B8              ;
 958+ B6B8              ; The header data area is 8 bytes long and may be used by the caller for
 959+ B6B8              ; any purpose whatsoever. It is available even if the file does not have
 960+ B6B8              ; a header; however, only files with a header and opened with write
 961+ B6B8              ; access will have the header data recorded on disk.
 962+ B6B8              ;
 963+ B6B8              ; Note that +3 BASIC uses these 8 bytes (see the note under DOS OPEN
 964+ B6B8              ; which gives the details). If creating a file that will subsequently be
 965+ B6B8              ; LOADed within BASIC, then those bytes should be filled with the
 966+ B6B8              ; relevant values.
 967+ B6B8              ;
 968+ B6B8              ; ENTRY CONDITIONS
 969+ B6B8              ;         B = File number
 970+ B6B8              ;
 971+ B6B8              ; EXIT CONDITIONS
 972+ B6B8              ;         If OK, but file doesn't have a header:
 973+ B6B8              ;                 Carry true
 974+ B6B8              ;                 Zero true
 975+ B6B8              ;                 A corrupt
 976+ B6B8              ;                 IX = Address of header data in page 7
 977+ B6B8              ;         If OK, file has a header:
 978+ B6B8              ;                 Carry true
 979+ B6B8              ;                 Zero false
 980+ B6B8              ;                 A corrupt
 981+ B6B8              ;                 IX = Address of header data in page 7
 982+ B6B8              ;         Otherwise:
 983+ B6B8              ;                 Carry false
 984+ B6B8              ;                 A = Error code
 985+ B6B8              ;                 IX corrupt
 986+ B6B8              ;         Always:
 987+ B6B8              ;                 BC DE HL corrupt
 988+ B6B8              ;                 All other registers preserved
 989+ B6B8              ;
 990+ B6B8              ;
 991+ B6B8
 992+ B6B8              dos_read: equ 0x0112 ; (274)
 993+ B6B8
 994+ B6B8              ; Read bytes from a file into memory.
 995+ B6B8              ;
 996+ B6B8              ; Advance the file pointer.
 997+ B6B8              ;
 998+ B6B8              ; The destination buffer is in the following memory configuration:
 999+ B6B8              ;
1000+ B6B8              ;         C000h...FFFFh (49152...65535)   - Page specified in C
1001+ B6B8              ;         8000h...BFFFh (32768...49151)   - Page 2
1002+ B6B8              ;         4000h...7FFFh (16384...32767)   - Page 5
1003+ B6B8              ;         0000h...3FFFh (0...16383)       - DOS ROM
1004+ B6B8              ;
1005+ B6B8              ; The routine does not consider soft-EOF.
1006+ B6B8              ;
1007+ B6B8              ; Reading EOF will produce an error.
1008+ B6B8              ;
1009+ B6B8              ; ENTRY CONDITIONS
1010+ B6B8              ;         B = File number
1011+ B6B8              ;         C = Page for C000h (49152)...FFFFh (65535)
1012+ B6B8              ;         DE = Number of bytes to read (0 means 64K)
1013+ B6B8              ;         HL = Address for bytes to be read
1014+ B6B8              ;
1015+ B6B8              ; EXIT CONDITIONS
1016+ B6B8              ;         If OK:
1017+ B6B8              ;                 Carry true
1018+ B6B8              ;                 A DE corrupt
1019+ B6B8              ;         Otherwise:
1020+ B6B8              ;                 Carry false
1021+ B6B8              ;                 A = Error code
1022+ B6B8              ;                 DE = Number of bytes remaining unread
1023+ B6B8              ;         Always:
1024+ B6B8              ;                 BC HL IX corrupt
1025+ B6B8              ;                 All other registers preserved
1026+ B6B8              ;
1027+ B6B8              ;
1028+ B6B8
1029+ B6B8              dos_write: equ 0x0115 ; (277)
1030+ B6B8
1031+ B6B8              ; Write bytes to a file from memory.
1032+ B6B8              ;
1033+ B6B8              ; Advance the file pointer.
1034+ B6B8              ;
1035+ B6B8              ; The source buffer is in the following memory configuration:
1036+ B6B8              ;
1037+ B6B8              ;         C000h...FFFFh (49152...65535)   - Page specified in C
1038+ B6B8              ;         8000h...BFFFh (32768...49151)   - Page 2
1039+ B6B8              ;         4000h...7FFFh (16384...32767)   - Page 5
1040+ B6B8              ;         0000h...3FFFh (0...16383)       - DOS ROM
1041+ B6B8              ;
1042+ B6B8              ; ENTRY CONDITIONS
1043+ B6B8              ;         B = File number
1044+ B6B8              ;         C = Page for C000h (49152)...FFFFh (65535)
1045+ B6B8              ;         DE = Number of bytes to write (0 means 64K)
1046+ B6B8              ;         HL = Address for bytes to write
1047+ B6B8              ;
1048+ B6B8              ; EXIT CONDITIONS
1049+ B6B8              ;         If OK:
1050+ B6B8              ;                 Carry true
1051+ B6B8              ;                 A DE corrupt
1052+ B6B8              ;         Otherwise:
1053+ B6B8              ;                 Carry false
1054+ B6B8              ;                 A = Error code
1055+ B6B8              ;                 DE = Number of bytes remaining unwritten
1056+ B6B8              ;         Always:
1057+ B6B8              ;                 BC HL IX corrupt
1058+ B6B8              ;                 All other registers preserved
1059+ B6B8              ;
1060+ B6B8              ;
1061+ B6B8
1062+ B6B8              dos_byte_read: equ 0x0118 ; (280)
1063+ B6B8
1064+ B6B8              ; Read a byte from a file.
1065+ B6B8              ;
1066+ B6B8              ; Advance the file pointer.
1067+ B6B8              ;
1068+ B6B8              ; Tests for soft-EOF (1Ah (26)). As this condition is not latched, it is
1069+ B6B8              ; possible to read past soft-EOF.
1070+ B6B8              ;
1071+ B6B8              ; EOF is latched.
1072+ B6B8              ;
1073+ B6B8              ; The caller must decide whether or not soft-EOF is of interest. This
1074+ B6B8              ; would normally be the case only when reading an ASCII file.
1075+ B6B8              ;
1076+ B6B8              ; Reading EOF will produce an error.
1077+ B6B8              ;
1078+ B6B8              ; ENTRY CONDITIONS
1079+ B6B8              ;         B = File number
1080+ B6B8              ;
1081+ B6B8              ; EXIT CONDITIONS
1082+ B6B8              ;         If OK - Byte <> 1Ah (26) (soft-EOF)
1083+ B6B8              ;                 Carry true
1084+ B6B8              ;                 Zero false
1085+ B6B8              ;                 A corrupt
1086+ B6B8              ;                 C = Byte
1087+ B6B8              ;         If OK - Byte = 1Ah (26) (soft-EOF)
1088+ B6B8              ;                 Carry true
1089+ B6B8              ;                 Zero true
1090+ B6B8              ;                 A corrupt
1091+ B6B8              ;                 C = Byte
1092+ B6B8              ;         Otherwise:
1093+ B6B8              ;                 Carry false
1094+ B6B8              ;                 A = Error code
1095+ B6B8              ;                 C corrupt
1096+ B6B8              ;         Always:
1097+ B6B8              ;                 B DE HL IX corrupt
1098+ B6B8              ;                 All other registers preserved
1099+ B6B8              ;
1100+ B6B8              ;
1101+ B6B8
1102+ B6B8              dos_byte_write: equ 0x011B ; (283)
1103+ B6B8
1104+ B6B8              ; Write a byte to a file.
1105+ B6B8              ;
1106+ B6B8              ; Advance the file pointer.
1107+ B6B8              ;
1108+ B6B8              ; ENTRY CONDITIONS
1109+ B6B8              ;         B = File number
1110+ B6B8              ;         C = Byte to write
1111+ B6B8              ;
1112+ B6B8              ; EXIT CONDITIONS
1113+ B6B8              ;         If OK:
1114+ B6B8              ;                 Carry true
1115+ B6B8              ;                 A corrupt
1116+ B6B8              ;         Otherwise:
1117+ B6B8              ;                 Carry false
1118+ B6B8              ;                 A = Error code
1119+ B6B8              ;         Always:
1120+ B6B8              ;                 BC DE HL IX corrupt
1121+ B6B8              ;                 All otehr registers preserved
1122+ B6B8              ;
1123+ B6B8              ;
1124+ B6B8
1125+ B6B8              dos_catalog: equ 0x011E ; (286)
1126+ B6B8
1127+ B6B8              ; Fills a buffer with part of the directory (sorted).
1128+ B6B8              ;
1129+ B6B8              ; The filename specifies the drive, user and a (possibly ambiguous)
1130+ B6B8              ; filename.
1131+ B6B8              ;
1132+ B6B8              ; Since the size of a directory is variable (and may be quite large),
1133+ B6B8              ; this routine permits the directory to be catalogued in a number of
1134+ B6B8              ; small sections. The caller passes a buffer pre-loaded with the first
1135+ B6B8              ; required filename, or zeroes for the start of the directory. The
1136+ B6B8              ; buffer is loaded with part (or all, if it fits) of the directory
1137+ B6B8              ; sorted in ASCII order. If more of the directory is required, this
1138+ B6B8              ; routine is re-called with the buffer re-initialised with the last file
1139+ B6B8              ; previously returned. This procedure is followed repeatedly until all
1140+ B6B8              ; of the directory has been catalogued.
1141+ B6B8              ;
1142+ B6B8              ; Note that +3DOS format disks (which are the same as single-sided,
1143+ B6B8              ; single track AMSTRAD PCW range format disks) may have a maximum of 64
1144+ B6B8              ; directory entries.
1145+ B6B8              ;
1146+ B6B8              ; Buffer format:
1147+ B6B8              ;
1148+ B6B8              ;         Entry 0
1149+ B6B8              ;         Entry 1
1150+ B6B8              ;         Entry 2
1151+ B6B8              ;         Entry 3
1152+ B6B8              ;         ...to...
1153+ B6B8              ;         Entry n
1154+ B6B8              ;
1155+ B6B8              ; Entry 0 must be preloaded with the first 'filename.type'
1156+ B6B8              ; required. Entry 1 will contain the first matching filename greater
1157+ B6B8              ; than the preloaded entry (if any). A zeroised preload entry is OK.
1158+ B6B8              ;
1159+ B6B8              ; If the buffer is too small for the directory, this routine can be
1160+ B6B8              ; called again with entry 0 replaced by entry n to fetch the next part
1161+ B6B8              ; of the directory.
1162+ B6B8              ;
1163+ B6B8              ; Entry format (13 bytes long):
1164+ B6B8              ;
1165+ B6B8              ;         Bytes 0...7     - Filename (ASCII) left justified, space
1166+ B6B8              ;                            filled
1167+ B6B8              ;         Bytes 6...10    - Type (ASCII) left justified, space filledd
1168+ B6B8              ;         Bytes 11...12   - Size in kilobytes (binary)
1169+ B6B8              ;
1170+ B6B8              ; The file size is the amount of disk space allocated to the file, not
1171+ B6B8              ; necessarily the same as the amount used by the file.
1172+ B6B8              ;
1173+ B6B8              ; ENTRY CONDITIONS
1174+ B6B8              ;         B = n+1, size of buffer in entries, >=2
1175+ B6B8              ;         C = Filter
1176+ B6B8              ;                 bit 0 = include system files (is set)
1177+ B6B8              ;                 bits 1...7 = 0 (reserved)
1178+ B6B8              ;         DE = Address of buffer (first entry initialised)
1179+ B6B8              ;         HL = Address of filename (wildcards permitted)
1180+ B6B8              ;
1181+ B6B8              ; EXIT CONDITIONS
1182+ B6B8              ;         If OK:
1183+ B6B8              ;                 Carry true
1184+ B6B8              ;                 A corrupt
1185+ B6B8              ;                 B = Number of completed entries in buffer, 0...n.
1186+ B6B8              ;                     (If B = n, there may be more to come).
1187+ B6B8              ;
1188+ B6B8              ;         Otherwise:
1189+ B6B8              ;                 Carry false
1190+ B6B8              ;                 A = Error code
1191+ B6B8              ;                 B corrupt
1192+ B6B8              ;         Always:
1193+ B6B8              ;                 C DE HL IX corrupt
1194+ B6B8              ;                 All other registers preserved
1195+ B6B8              ;
1196+ B6B8              ;
1197+ B6B8
1198+ B6B8              dos_free_space: equ 0x0121 ; (289)
1199+ B6B8
1200+ B6B8              ; How much free space is there on this drive?
1201+ B6B8              ;
1202+ B6B8              ; ENTRY CONDITIONS
1203+ B6B8              ;         A = Drive, ASCII 'A'...'P'
1204+ B6B8              ;
1205+ B6B8              ; EXIT CONDITIONS
1206+ B6B8              ;         If OK:
1207+ B6B8              ;                 Carry true
1208+ B6B8              ;                 A corrupt
1209+ B6B8              ;                 HL = Free space (in kilobytes)
1210+ B6B8              ;         Otherwise:
1211+ B6B8              ;                 Carry false
1212+ B6B8              ;                 A = Error code
1213+ B6B8              ;                 HL corrupt
1214+ B6B8              ;         Always:
1215+ B6B8              ;                 BC DE IX corrupt
1216+ B6B8              ;                 All other registers preserved
1217+ B6B8              ;
1218+ B6B8              ;
1219+ B6B8
1220+ B6B8              dos_delete: equ 0x0124 ; (292)
1221+ B6B8
1222+ B6B8              ; XXX This call is not documented in the WoS' HTML version of the +3 manual,
1223+ B6B8              ; but first guessed and finally confirmet it with the original Spanish manual.
1224+ B6B8
1225+ B6B8              ; Delete an existing file.
1226+ B6B8              ;
1227+ B6B8              ; File must not be open on any file number.
1228+ B6B8              ;
1229+ B6B8              ; ENTRY CONDITIONS HL = Address of filename (wildcards permitted)
1230+ B6B8              ;
1231+ B6B8              ; EXIT CONDITIONS If OK: Carry true A corrupt Otherwise: Carry false A = Error
1232+ B6B8              ; code Always: BC DE HL IX corrupt All other registers preserved
1233+ B6B8
1234+ B6B8              dos_rename: equ 0x0127 ; (295)
1235+ B6B8
1236+ B6B8              ; Rename an existing file.
1237+ B6B8              ;
1238+ B6B8              ; File must not be open on any file number. A file with the new filename
1239+ B6B8              ; must not exist. The new name must specify, or default to, the sme
1240+ B6B8              ; drive as the old name.
1241+ B6B8              ;
1242+ B6B8              ; ENTRY CONDITIONS
1243+ B6B8              ;         DE = Address of new filename (no wildcards)
1244+ B6B8              ;         HL = Address of old filename (no wildcards)
1245+ B6B8              ;
1246+ B6B8              ; EXIT CONDITIONS
1247+ B6B8              ;         If OK:
1248+ B6B8              ;                 Carry true
1249+ B6B8              ;                 A corrupt
1250+ B6B8              ;         Otherwise:
1251+ B6B8              ;                 Carry false
1252+ B6B8              ;                 A = Error code
1253+ B6B8              ;         Always:
1254+ B6B8              ;                 BC DE HL IX corrupt
1255+ B6B8              ;                 All other registers preserved
1256+ B6B8              ;
1257+ B6B8              ;
1258+ B6B8
1259+ B6B8              dos_boot: equ 0x012A ; (298)
1260+ B6B8
1261+ B6B8              ; Boot from disk.
1262+ B6B8              ;
1263+ B6B8              ; This routine loads a single bootstrap sector from the disk in drive A:
1264+ B6B8              ; into memory and enters it. This is for loading games or other
1265+ B6B8              ; operating systems.
1266+ B6B8              ;
1267+ B6B8              ; Bootstrap environment:
1268+ B6B8              ;
1269+ B6B8              ;         C000h...FFFFh (49152...65535)   - Page 3
1270+ B6B8              ;         8000h...BFFFh (32768...49151)   - Page 6
1271+ B6B8              ;         4000h...7FFFh (16384...32767)   - Page 7
1272+ B6B8              ;         0000h...3FFFh (0...16383)       - Page 4
1273+ B6B8              ;
1274+ B6B8              ; The bootstrap sector is on side 0, track 0, sector 1. It is loaded at
1275+ B6B8              ; FE00h (65024) and entered at FE10h (65040). Interrupts are disabled.
1276+ B6B8              ; SP is at FE00h (65024). The sum of all bytes in the sector must equal
1277+ B6B8              ; 3 MOD 256 (byte 15 can be set to the required value to achieve this).
1278+ B6B8              ;
1279+ B6B8              ; ENTRY CONDITIONS
1280+ B6B8              ;         None
1281+ B6B8              ;
1282+ B6B8              ; EXIT CONDITIONS
1283+ B6B8              ;         If OK:
1284+ B6B8              ;                 No exit (as the bootstrap will be entered)
1285+ B6B8              ;         Otherwise:
1286+ B6B8              ;                 Carry false
1287+ B6B8              ;                 A = Error code
1288+ B6B8              ;         Always:
1289+ B6B8              ;                 BC DE HL IX corrupt
1290+ B6B8              ;                 All other registers preserved
1291+ B6B8              ;
1292+ B6B8              ;
1293+ B6B8
1294+ B6B8              dos_set_drive: equ 0x012D ; (301)
1295+ B6B8
1296+ B6B8              ; Set the default drive (i.e. the drive implied by all filenames that do
1297+ B6B8              ; not specify a drive).
1298+ B6B8              ;
1299+ B6B8              ; The default drive is initially A:.
1300+ B6B8              ;
1301+ B6B8              ; Does not access the drive, but merely checks that there is a driver
1302+ B6B8              ; for it (which does not imply that the drive exists).
1303+ B6B8              ;
1304+ B6B8              ; This only affects routines that take filename parameters.
1305+ B6B8              ;
1306+ B6B8              ; ENTRY CONDITIONS
1307+ B6B8              ;         A = Drive, ASCII 'A'...'P' (FFh (255) = get default drive)
1308+ B6B8              ;
1309+ B6B8              ; EXIT CONDITIONS
1310+ B6B8              ;         If OK:
1311+ B6B8              ;                 Carry true
1312+ B6B8              ;                 A = Default drive
1313+ B6B8              ;         Otherwise:
1314+ B6B8              ;                 Carry false
1315+ B6B8              ;                 A = Error code
1316+ B6B8              ;         Always:
1317+ B6B8              ;                 BC DE HL IX corrupt
1318+ B6B8              ;                 All other registers preserved
1319+ B6B8              ;
1320+ B6B8              ;
1321+ B6B8
1322+ B6B8              dos_set_user: equ 0x0130 ; (304)
1323+ B6B8
1324+ B6B8              ; Set the default user area, i.e. the user area implied by all filenames
1325+ B6B8              ; that do not specify a user number.
1326+ B6B8              ;
1327+ B6B8              ; The default user number is intially 0.
1328+ B6B8              ;
1329+ B6B8              ; This only affects routines that take filename parameters.
1330+ B6B8              ;
1331+ B6B8              ; ENTRY CONDITIONS
1332+ B6B8              ;         A = User 0...15 (FFh (255) = get default user)
1333+ B6B8              ;
1334+ B6B8              ; EXIT CONDITIONS
1335+ B6B8              ;         If OK:
1336+ B6B8              ;                 Carry true
1337+ B6B8              ;                 A = Default user
1338+ B6B8              ;         Otherwise:
1339+ B6B8              ;                 Carry false
1340+ B6B8              ;                 A = Error code
1341+ B6B8              ;         Always:
1342+ B6B8              ;                 BC DE HL IX corrupt
1343+ B6B8              ;                 All other registers preserved
1344+ B6B8              ;
1345+ B6B8              ;
1346+ B6B8              ;
1347+ B6B8              ; Additional routines for games and operating systems
1348+ B6B8              ;
1349+ B6B8
1350+ B6B8              dos_get_position: equ 0x0133 ; (307)
1351+ B6B8
1352+ B6B8              ; Get the file pointer.
1353+ B6B8              ;
1354+ B6B8              ; ENTRY CONDITIONS
1355+ B6B8              ;         B = File number
1356+ B6B8              ;
1357+ B6B8              ; EXIT CONDITIONS
1358+ B6B8              ;         If OK:
1359+ B6B8              ;                 Carry true
1360+ B6B8              ;                 A corrupt
1361+ B6B8              ;                 E HL = File pointer 000000h...FFFFFFh (0...16777215)
1362+ B6B8              ;                 (E holds most significant byte; L holds leat
1363+ B6B8              ;                 significant byte)
1364+ B6B8              ;         Otherwise:
1365+ B6B8              ;                 Carry false
1366+ B6B8              ;                 A = Error code
1367+ B6B8              ;                 E HL corrupt
1368+ B6B8              ;         Always:
1369+ B6B8              ;                 BC D IX corrupt
1370+ B6B8              ;                 All other registers preserved
1371+ B6B8              ;
1372+ B6B8              ;
1373+ B6B8
1374+ B6B8              dos_set_position: equ 0x0136 ; (310)
1375+ B6B8
1376+ B6B8              ; Set the file pointer.
1377+ B6B8              ;
1378+ B6B8              ; Does not access the disk.
1379+ B6B8              ;
1380+ B6B8              ; Does not check (or care) if pointer is >= 8 megabytes.
1381+ B6B8              ;
1382+ B6B8              ; ENTRY CONDITIONS
1383+ B6B8              ;         B = File numbers
1384+ B6B8              ;         E HL = File pointer 000000h...FFFFFFh (0...16777215)
1385+ B6B8              ;         (E holds most significant byte; L holds leat
1386+ B6B8              ;         significant byte)
1387+ B6B8              ;
1388+ B6B8              ; EXIT CONDITIONS
1389+ B6B8              ;         If OK:
1390+ B6B8              ;                 Carry true
1391+ B6B8              ;                 A corrupt
1392+ B6B8              ;         Otherwise:
1393+ B6B8              ;                 Carry false
1394+ B6B8              ;                 A = Error code
1395+ B6B8              ;         Always:
1396+ B6B8              ;                 BC DE HL IX corrupt
1397+ B6B8              ;                 All other registers preserved
1398+ B6B8              ;
1399+ B6B8              ;
1400+ B6B8
1401+ B6B8              dos_get_eof: equ 0x0139 ; (313)
1402+ B6B8
1403+ B6B8              ; Get the end of file (EOF) file position greater than all written byte
1404+ B6B8              ; positions.
1405+ B6B8              ;
1406+ B6B8              ; Does not affect the file pointer.
1407+ B6B8              ;
1408+ B6B8              ; Does not consider soft-EOF.
1409+ B6B8              ;
1410+ B6B8              ; ENTRY CONDITIONS
1411+ B6B8              ;         B = File number
1412+ B6B8              ;
1413+ B6B8              ; EXIT CONDTITIONS
1414+ B6B8              ;         If OK:
1415+ B6B8              ;                 Carry true
1416+ B6B8              ;                 A corrupt
1417+ B6B8              ;                 E HL = File pointer 000000h...FFFFFFh (0...16777215)
1418+ B6B8              ;                 (E holds most significant byte; L holds leat
1419+ B6B8              ;                 significant byte)
1420+ B6B8              ;         Otherwise:
1421+ B6B8              ;                 Carry false
1422+ B6B8              ;                 A = Error code
1423+ B6B8              ;                 E HL Corrupt
1424+ B6B8              ;         Always:
1425+ B6B8              ;                 BC D IX corrupt
1426+ B6B8              ;                 All other registers preserved
1427+ B6B8              ;
1428+ B6B8              ;
1429+ B6B8              dos_get_1346: equ 0x013C ; (316)
1430+ B6B8              ;
1431+ B6B8              ; Get the current location of the cache and RAMdisk.
1432+ B6B8              ;
1433+ B6B8              ; Pages 1, 3, 4, 6 are considered as an array of 128 sector buffers
1434+ B6B8              ; (numbered 0...127), each of 512 bytes. The cache and RAMdisk occupy
1435+ B6B8              ; two separate (contiguous) areas of this array.
1436+ B6B8              ;
1437+ B6B8              ; Any unused sector buffers may be used by the caller.
1438+ B6B8              ;
1439+ B6B8              ; Note that the sizes may be smaller than those specified in DOS SET
1440+ B6B8              ; 1346, as there is an (unpublished) maximum size of cache and a minimum
1441+ B6B8              ; size of RAMdisk (4 sectors).
1442+ B6B8              ;
1443+ B6B8              ; ENTRY CONDITIONS
1444+ B6B8              ;         None
1445+ B6B8              ;
1446+ B6B8              ; EXIT CONDITIONS
1447+ B6B8              ;                 D = First buffer of cache
1448+ B6B8              ;                 E = Number of cache sector buffers
1449+ B6B8              ;                 H = First buffer of RAMdisk
1450+ B6B8              ;                 L = Number of RAMdisk sector buffers
1451+ B6B8              ;         Always:
1452+ B6B8              ;                 AF BC IX corrupt
1453+ B6B8              ;                 All other registers preserved
1454+ B6B8              ;
1455+ B6B8              ;
1456+ B6B8              dos_set_1346: equ 0x013F ; (319)
1457+ B6B8              ;
1458+ B6B8              ; Rebuild the sector cache and RAMdisk.
1459+ B6B8              ;
1460+ B6B8              ; This routine is used to make some store available to the user, or to
1461+ B6B8              ; return store to DOS.
1462+ B6B8              ;
1463+ B6B8              ; Note that if the RAMdisk is moved, ot its size is changed, then all
1464+ B6B8              ; files thereon are erased.
1465+ B6B8              ;
1466+ B6B8              ; Pages 1, 3, 4, 6 are considered as an array of 128 sector buffers
1467+ B6B8              ; (numbered 0...127), each of 512 bytes. The cache and RAMdisk occupy
1468+ B6B8              ; two separate (contiguous) areas of this array.
1469+ B6B8              ;
1470+ B6B8              ; The location and size of the cache and RAMdisk can be specified
1471+ B6B8              ; separately; any remaining buffers are unused by DOS and are available
1472+ B6B8              ; to the caller.
1473+ B6B8              ;
1474+ B6B8              ; Note that the sizes actually used may be smaller than those specified
1475+ B6B8              ; as in practice, there is a maximum cache size and a minimum size of
1476+ B6B8              ; RAMdisk (4 sectors).
1477+ B6B8              ;
1478+ B6B8              ; A cache size of 0 will still work but will seriously impair the floppy
1479+ B6B8              ; disk performance.
1480+ B6B8              ;
1481+ B6B8              ; This routine will fail if there are any files open on drive M:.
1482+ B6B8              ;
1483+ B6B8              ; ENTRY CONDITIONS
1484+ B6B8              ;         D = First buffer for cache
1485+ B6B8              ;         E = Number of cache sector buffers
1486+ B6B8              ;         H = First buffer for RAMdisk
1487+ B6B8              ;         L = Number of RAMdisk sector buffers
1488+ B6B8              ;         (Note that E + L <= 128)
1489+ B6B8              ;
1490+ B6B8              ; EXIT CONDITIONS
1491+ B6B8              ;         If OK:
1492+ B6B8              ;                 Carry true
1493+ B6B8              ;                 A corrupt
1494+ B6B8              ;         Otherwise:
1495+ B6B8              ;                 Carry false
1496+ B6B8              ;                 A = Error code
1497+ B6B8              ;         Always:
1498+ B6B8              ;                 BC DE HL IX corrupt
1499+ B6B8              ;                 All other registers preserved
1500+ B6B8              ;
1501+ B6B8              ;
1502+ B6B8
1503+ B6B8              dos_flush: equ 0x0142 ; (322)
1504+ B6B8
1505+ B6B8              ; Write any pending headers, data, directory entries for this drive.
1506+ B6B8              ;
1507+ B6B8              ; This routine ensures that the disk is up to date. It can be called at
1508+ B6B8              ; any time, even when files are open.
1509+ B6B8              ;
1510+ B6B8              ; ENTRY CONDITIONS
1511+ B6B8              ;         A = Drive, ASCII 'A'...'P'
1512+ B6B8              ;
1513+ B6B8              ; EXIT CONDITIONS
1514+ B6B8              ;         If OK:
1515+ B6B8              ;                 Carry true
1516+ B6B8              ;                 A corrupt
1517+ B6B8              ;         Otherwise:
1518+ B6B8              ;                 Carry false
1519+ B6B8              ;                 A = Error code
1520+ B6B8              ;         Always:
1521+ B6B8              ;                 BC DE HL IX corrupt
1522+ B6B8              ;                 All other registers preserved
1523+ B6B8              ;
1524+ B6B8              ;
1525+ B6B8
1526+ B6B8              dos_set_access: equ 0x0145 ; (325)
1527+ B6B8
1528+ B6B8              ; Try to change the access mode of an open file.
1529+ B6B8              ;
1530+ B6B8              ; This routine will fail if the file is already open, in an incompatible
1531+ B6B8              ; access mode, or if write access is required for a read-only file or
1532+ B6B8              ; disk.
1533+ B6B8              ;
1534+ B6B8              ; ENTRY CONDITIONS
1535+ B6B8              ;         B = File number
1536+ B6B8              ;         C = Access mode required
1537+ B6B8              ;                 Bits 0...2 values:
1538+ B6B8              ;                         1 = exclusive-read
1539+ B6B8              ;                         2 = exclusive-write
1540+ B6B8              ;                         3 = exclusive-read-write
1541+ B6B8              ;                         5 = shared-read
1542+ B6B8              ;                         (all other bit settings reserved)
1543+ B6B8              ;                 Bits 3...7 = 0 (reserved)
1544+ B6B8              ;
1545+ B6B8              ; EXIT CONDITIONS
1546+ B6B8              ;         If OK:
1547+ B6B8              ;                 Carry true
1548+ B6B8              ;                 A corrupt
1549+ B6B8              ;         Otherwise:
1550+ B6B8              ;                 Carry false
1551+ B6B8              ;                 A = Error code
1552+ B6B8              ;         Always:
1553+ B6B8              ;                 BC DE HL IX corrupt
1554+ B6B8              ;                 All other registers preserved
1555+ B6B8              ;
1556+ B6B8              ;
1557+ B6B8
1558+ B6B8              dos_set_attributes: equ 0x0148 ; (328)
1559+ B6B8
1560+ B6B8              ; Set a file's attributes.
1561+ B6B8              ;
1562+ B6B8              ; Only the file attributes f1'...f4', t1'...t3' can be set or
1563+ B6B8              ; cleared. The interface attributes f5'...f8' are always 0.
1564+ B6B8              ;
1565+ B6B8              ; This routine first sets the attributes specified in D, then clears
1566+ B6B8              ; those attributes specified in E, i.e. E has priority.
1567+ B6B8              ;
1568+ B6B8              ; ENTRY CONDITIONS
1569+ B6B8              ;         D = Attributes to set
1570+ B6B8              ;                 bit 0 = t3' Archive
1571+ B6B8              ;                 bit 1 = t2' System
1572+ B6B8              ;                 bit 2 = t1' Read-only
1573+ B6B8              ;                 bit 3 = f4'
1574+ B6B8              ;                 bit 4 = f3'
1575+ B6B8              ;                 bit 5 = f2'
1576+ B6B8              ;                 bit 6 = f1'
1577+ B6B8              ;         E = Attributes to clear
1578+ B6B8              ;                 bit 0 = t3' Archive
1579+ B6B8              ;                 bit 1 = t2' System
1580+ B6B8              ;                 bit 2 = t1' Read-only
1581+ B6B8              ;                 bit 3 = f4'
1582+ B6B8              ;                 bit 4 = f3'
1583+ B6B8              ;                 bit 5 = f2'
1584+ B6B8              ;                 bit 6 = f1'
1585+ B6B8              ;         HL = Address of filename (wildcards permitted)
1586+ B6B8              ;
1587+ B6B8              ; EXIT CONDITIONS
1588+ B6B8              ;         If OK:
1589+ B6B8              ;                 Carry true
1590+ B6B8              ;                 A corrupt
1591+ B6B8              ;         Otherwise:
1592+ B6B8              ;                 Carry false
1593+ B6B8              ;                 A = Error code
1594+ B6B8              ;         Always:
1595+ B6B8              ;                 BC DE HL IX corrupt
1596+ B6B8              ;                 All other registers preserved
1597+ B6B8              ;
1598+ B6B8              ;
1599+ B6B8
1600+ B6B8              dos_open_drive: equ 0x014B ; (331)
1601+ B6B8
1602+ B6B8              ; Open the disk in this drive as a single file.
1603+ B6B8              ;
1604+ B6B8              ; The whole disk is presented as a single file regardless of any real
1605+ B6B8              ; files on the disk. This routine can be used to examine/poke
1606+ B6B8              ; directories, files, etc. It should not be used by the uninitiated, the
1607+ B6B8              ; faint hearted, or by anyone who values their files!
1608+ B6B8              ;
1609+ B6B8              ; Sets file pointer to 000000h (0).
1610+ B6B8              ;
1611+ B6B8              ; If there are any files open on this drive from other file numbers with
1612+ B6B8              ; shared-read access, then the disk can only be opened with shared-read
1613+ B6B8              ; access from this file number.
1614+ B6B8              ;
1615+ B6B8              ; If there are any file open on this drive from other file numbers with
1616+ B6B8              ; exclusive access, then the disk cannot be opened from this file
1617+ B6B8              ; number.
1618+ B6B8              ;
1619+ B6B8              ; ENTRY CONDITIONS
1620+ B6B8              ;         A = Drive, ASCII 'A'...'P'
1621+ B6B8              ;         B = File number
1622+ B6B8              ;         C = Access mode required
1623+ B6B8              ;                 Bits 0...2 values:
1624+ B6B8              ;                         1 = exclusive-read
1625+ B6B8              ;                         2 = exclusive-write
1626+ B6B8              ;                         3 = exclusive-read-write
1627+ B6B8              ;                         5 = shared-read
1628+ B6B8              ;                         (all other bit settings reserved)
1629+ B6B8              ;                 Bits 3...7 = 0 (reserved)
1630+ B6B8              ;
1631+ B6B8              ; EXIT CONDITIONS
1632+ B6B8              ;         If OK:
1633+ B6B8              ;                 Carry true
1634+ B6B8              ;                 A corrupt
1635+ B6B8              ;         Otherwise:
1636+ B6B8              ;                 Carry false
1637+ B6B8              ;                 A = Error code
1638+ B6B8              ;         Always:
1639+ B6B8              ;                 BC DE HL corrupt
1640+ B6B8              ;                 All other registers preserved
1641+ B6B8              ;
1642+ B6B8              ;
1643+ B6B8
1644+ B6B8              dos_set_message: equ 0x014E ; (334)
1645+ B6B8
1646+ B6B8              ; Enable/disable disk error messages.
1647+ B6B8              ;
1648+ B6B8              ; This should be used to make +3DOS aware of your own ALERT subroutine.
1649+ B6B8              ; When +3DOS detects an error, it will call your ALERT subroutine,
1650+ B6B8              ; passing to it the values documented below. The ALERT subroutine should
1651+ B6B8              ; print the text of the message that +3DOS passes it, then should wait
1652+ B6B8              ; for the user to press a key. If the key is in the reply string (that
1653+ B6B8              ; +3DOS also passes - version V1.0 only), then a 'ret' should be made
1654+ B6B8              ; with A = 0, 1 or 2, or containing the character (depending on the
1655+ B6B8              ; version of +3DOS).
1656+ B6B8              ;
1657+ B6B8              ; ENTRY CONDITIONS
1658+ B6B8              ;         A = Enable/disable
1659+ B6B8              ;                 FFh (255) = enable
1660+ B6B8              ;                 00h (0) = disable
1661+ B6B8              ;         HL = Address of ALERT routine (if enabled)
1662+ B6B8              ;
1663+ B6B8              ; EXIT CONDITIONS
1664+ B6B8              ;         HL = address of previous ALERT routine (0 if none)
1665+ B6B8              ; Always:
1666+ B6B8              ;         AF BC DE IX corrupt
1667+ B6B8              ;         All other registers preserved
1668+ B6B8              ;
1669+ B6B8              ; NOTE
1670+ B6B8              ;
1671+ B6B8              ;         Note that if you are substituting your own ALERT subroutine,
1672+ B6B8              ;         the 'entry conditions' are the conditions passed to your
1673+ B6B8              ;         subroutine and the 'exit conditions' are the values that your
1674+ B6B8              ;         subroutine must produce and the registers you are allowed to
1675+ B6B8              ;         corrupt.
1676+ B6B8              ;
1677+ B6B8              ;         Note that there are two routine interfaces for ALERT. The
1678+ B6B8              ;         first, (which is used in machines with +3DOS version V1.0)
1679+ B6B8              ;         should have the entry and exit conditions shown ahead.
1680+ B6B8              ;
1681+ B6B8              ;         ALERT (VERSION V1.0 ONLY)
1682+ B6B8              ;
1683+ B6B8              ;         ENTRY CONDITIONS
1684+ B6B8              ;                 DE = Address of reply string (in page 7) terminated by
1685+ B6B8              ;                         FFh (255)
1686+ B6B8              ;                 HL = Address of error message (in page 7) terminated
1687+ B6B8              ;                         by FFh (255)
1688+ B6B8              ;
1689+ B6B8              ;         EXIT CONDITIONS
1690+ B6B8              ;                         A = Reply character
1691+ B6B8              ;                 Always:
1692+ B6B8              ;                         F BC DE HL IX corrupt
1693+ B6B8              ;                         All other registers preserved
1694+ B6B8              ;
1695+ B6B8              ;         The second version of ALERT, which allows the user to provide
1696+ B6B8              ;         non-UK error messages and is generally more flexible, is
1697+ B6B8              ;         present in +3DOS versions V1.1 and upwards.
1698+ B6B8              ;
1699+ B6B8              ;         ALERT (VERSION V1.1 AND ABOVE)
1700+ B6B8              ;
1701+ B6B8              ;         ENTRY CONDITIONS
1702+ B6B8              ;                 B = Error number
1703+ B6B8              ;                 C = Drive, ASCII 'A'...'P'
1704+ B6B8              ;                 D = Logical track (if required for message)
1705+ B6B8              ;                 E = Logical sector (if required for message)
1706+ B6B8              ;                 HL = Address of UK error message (page 7) terminated
1707+ B6B8              ;                         by FFh (255)
1708+ B6B8              ;
1709+ B6B8              ;         EXIT CONDITIONS
1710+ B6B8              ;                         A = Reply
1711+ B6B8              ;                                 0 = cancel
1712+ B6B8              ;                                 1 = retry
1713+ B6B8              ;                                 2 = ignore
1714+ B6B8              ;                 Always:
1715+ B6B8              ;                         F BC DE HL IX corrupt
1716+ B6B8              ;                         All other registers preserved
1717+ B6B8              ;
1718+ B6B8              ;         If you provide an ALERT function, you should have two
1719+ B6B8              ;         subroutines (or one with switchable entry and exit
1720+ B6B8              ;         conditions), and check the +3DOS version number before
1721+ B6B8              ;         deciding which one to use.
1722+ B6B8              ;
1723+ B6B8              ;
1724+ B6B8
1725+ B6B8              dos_ref_xdpb: equ 0x0151 ; (337)
1726+ B6B8
1727+ B6B8              ; Point at the XDPB for this drive. (The XDPB is required by the floppy
1728+ B6B8              ; disk driver routines.)
1729+ B6B8              ;
1730+ B6B8              ; ENTRY CONDITIONS
1731+ B6B8              ;         A = Drive, ASCII 'A'...'P'
1732+ B6B8              ;
1733+ B6B8              ; EXIT CONDITIONS
1734+ B6B8              ;         If OK:
1735+ B6B8              ;                 Carry true
1736+ B6B8              ;                 A corrupt
1737+ B6B8              ;                 IX = Address of XDPB
1738+ B6B8              ;         Otherwise:
1739+ B6B8              ;                 Carry false
1740+ B6B8              ;                 A = Error code
1741+ B6B8              ;                 IX corrupt
1742+ B6B8              ;         Always:
1743+ B6B8              ;                 BC DE HL corrupt
1744+ B6B8              ;                 All other registers preserved
1745+ B6B8              ;
1746+ B6B8              ;
1747+ B6B8
1748+ B6B8              dos_map_b: equ 0x0154 ; (340)
1749+ B6B8
1750+ B6B8              ; Map drive B: to unit 0 or unit 1. (This routine will fail if drive B:
1751+ B6B8              ; has files open.)
1752+ B6B8              ;
1753+ B6B8              ; If mapping B: to unit 0, then each time unit 0 is accessed, a check is
1754+ B6B8              ; made that the drive mapping is correct. If it isn't, then a reverse
1755+ B6B8              ; call to CHANGE DISK is made, to ask the user to change the disk in
1756+ B6B8              ; unit 0.
1757+ B6B8              ;
1758+ B6B8              ; If mapping B: to unit 1, then if unit 1 does not exist, drive B: is
1759+ B6B8              ; disabled.
1760+ B6B8              ;
1761+ B6B8              ; ENTRY CONDITIONS
1762+ B6B8              ;         C = Unit (0/1)
1763+ B6B8              ;         HL = Address of CHANGE DISK routine if unit = 0
1764+ B6B8              ;
1765+ B6B8              ; EXIT CONDITIONS
1766+ B6B8              ;         If OK:
1767+ B6B8              ;                 Carry true
1768+ B6B8              ;                 A corrupt
1769+ B6B8              ;                 HL = Address of previous CHANGE DISK routine (0 if
1770+ B6B8              ;                         none)
1771+ B6B8              ;         Otherwise:
1772+ B6B8              ;                 Carry false
1773+ B6B8              ;                 A HL corrupt
1774+ B6B8              ;         Always
1775+ B6B8              ;                 BC DE IX corrupt
1776+ B6B8              ;                 All other registers preserved
1777+ B6B8              ;
1778+ B6B8              ; NOTE
1779+ B6B8              ;         The definition of the subroutine CHANGE DISK is as shown
1780+ B6B8              ;         ahead. Note that if you are substituting your own CHANGE DISK
1781+ B6B8              ;         subroutine, the 'entry conditions' are the conditions passed
1782+ B6B8              ;         to your subroutine, and the 'exit conditions' are registers
1783+ B6B8              ;         you are allowed to corrupt.
1784+ B6B8              ;
1785+ B6B8              ;         CHANGE DISK
1786+ B6B8              ;
1787+ B6B8              ;         Ask the user to change the disk in unit 0.
1788+ B6B8              ;
1789+ B6B8              ;         Wait for the user to acknowledge the change.
1790+ B6B8              ;
1791+ B6B8              ;         ENTRY CONDITIONS
1792+ B6B8              ;                 A = Logical drive, ASCII 'A'...'P'
1793+ B6B8              ;                 HL = Address of message (page 7) terminated by FFh
1794+ B6B8              ;                         (255)
1795+ B6B8              ;
1796+ B6B8              ;         EXIT CONDITIONS
1797+ B6B8              ;                 Always:
1798+ B6B8              ;                         AF BC DE HL IX corrupt
1799+ B6B8              ;                         All other registers preserved
1800+ B6B8              ;
1801+ B6B8              ;
1802+ B6B8              ;
1803+ B6B8              ; Low level floppy disk driving routines
1804+ B6B8              ;
1805+ B6B8              ; The following are the floppy disk driver routines. The unit number is
1806+ B6B8              ; 0...3 for the uPD765A. On the +3, unit 0 is drive A: and unit 1 is
1807+ B6B8              ; drive B:, or optionally, both A: and B: may be mapped onto unit 0.
1808+ B6B8              ; Units 2 and 3 are not used.
1809+ B6B8              ;
1810+ B6B8              ; With the exception of DD INTERFACE, none of these routines may be
1811+ B6B8              ; called if the floppy disk interface is not present.
1812+ B6B8              ;
1813+ B6B8              ; All routines assume that interrupts are enabled on entry, and will
1814+ B6B8              ; still be enabled on exit.
1815+ B6B8              ;
1816+ B6B8
1817+ B6B8              dd_interface: equ 0x0157 ; (343)
1818+ B6B8
1819+ B6B8              ; Is the floppy disk drive interface present? (This information is also
1820+ B6B8              ; held by BASIC in bit 4 of the FLAGS3 system variable.)
1821+ B6B8              ;
1822+ B6B8              ; ENTRY CONDITIONS
1823+ B6B8              ;         None
1824+ B6B8              ;
1825+ B6B8              ; EXIT CONDITIONS
1826+ B6B8              ;         If present:
1827+ B6B8              ;                 Carry true
1828+ B6B8              ;         Otherwise:
1829+ B6B8              ;                 Carry false
1830+ B6B8              ;         Always:
1831+ B6B8              ;                 A BC DE HL IX corrupt
1832+ B6B8              ;                 All other registers preserved
1833+ B6B8              ;
1834+ B6B8
1835+ B6B8              dd_init: equ 0x015a ; (346)
1836+ B6B8
1837+ B6B8              ; Initialise the disk driver.
1838+ B6B8              ;
1839+ B6B8              ; ENTRY CONDITIONS
1840+ B6B8              ;         None
1841+ B6B8              ;
1842+ B6B8              ; EXIT CONDITIONS
1843+ B6B8              ;         Always:
1844+ B6B8              ;                 AF BC DE HL IX corrupt
1845+ B6B8              ;                 All other registers preserved
1846+ B6B8              ;
1847+ B6B8
1848+ B6B8              dd_setup: equ 0x015d ; (349)
1849+ B6B8
1850+ B6B8              ; Set up disk parameters.
1851+ B6B8              ;
1852+ B6B8              ; Send a specify command.
1853+ B6B8              ;
1854+ B6B8              ; Parameter block format:
1855+ B6B8              ;
1856+ B6B8              ;         Byte 0 - Motor on time (in 100 mS units)
1857+ B6B8              ;         Byte 1 - Motor off time (in 100 mS units)
1858+ B6B8              ;         Byte 2 - Write off time (in 10 uS units)
1859+ B6B8              ;         Byte 3 - Head settle time (in mS units)
1860+ B6B8              ;         Byte 4 - Step rate (in mS units)
1861+ B6B8              ;         Byte 5 - Head unload time (in 32 mS units, 32...480)
1862+ B6B8              ;         Byte 6 - (Head load time x 2) + 1, (in 4 mS units, 4...508)
1863+ B6B8              ;
1864+ B6B8              ; ENTRY CONDITIONS
1865+ B6B8              ;         HL = Address of parameter block
1866+ B6B8              ;
1867+ B6B8              ; EXIT CONDITIONS
1868+ B6B8              ;         Always:
1869+ B6B8              ;                 AF BC DE HL IX corrupt
1870+ B6B8              ;                 All other registers preserved
1871+ B6B8              ;
1872+ B6B8
1873+ B6B8              dd_set_retry: equ 0x0160 ; (352)
1874+ B6B8
1875+ B6B8              ; Set the try and retry count. (A value of 1 will try the operation
1876+ B6B8              ; once, i.e. no retry.)
1877+ B6B8              ;
1878+ B6B8              ; ENTRY CONDITIONS
1879+ B6B8              ;         A = Try/retry count >= 1
1880+ B6B8              ;
1881+ B6B8              ; EXIT CONDITIONS
1882+ B6B8              ;         Always:
1883+ B6B8              ;                 AF BC DE HL IX corrupt
1884+ B6B8              ;                 All other registers preserved
1885+ B6B8              ;
1886+ B6B8
1887+ B6B8              dd_read_sector: equ 0x0163 ; (355)
1888+ B6B8
1889+ B6B8              ; Read a sector.
1890+ B6B8              ;
1891+ B6B8              ; ENTRY CONDITIONS
1892+ B6B8              ;         B = Page for C000h (49152)...FFFFh (65535)
1893+ B6B8              ;         C = Unit (0/1)
1894+ B6B8              ;         D = Logical track, 0 base
1895+ B6B8              ;         E = Logical sector, 0 base
1896+ B6B8              ;         HL = Address of buffer
1897+ B6B8              ;         IX = Address of XDPB
1898+ B6B8              ;
1899+ B6B8              ; EXIT CONDITIONS
1900+ B6B8              ;         If OK:
1901+ B6B8              ;                 Carry true
1902+ B6B8              ;                 A corrupt
1903+ B6B8              ;         Otherwise:
1904+ B6B8              ;                 Carry false
1905+ B6B8              ;                 A = Error code
1906+ B6B8              ;         Always:
1907+ B6B8              ;                 BC DE HL IX corrupt
1908+ B6B8              ;                 All other registers preserved
1909+ B6B8              ;
1910+ B6B8
1911+ B6B8              dd_write_sector: equ 0x0166 ; (358)
1912+ B6B8
1913+ B6B8              ; Write a sector.
1914+ B6B8              ;
1915+ B6B8              ; ENTRY CONDITIONS
1916+ B6B8              ;         B = Page for C000h (49152)...FFFFh (65535)
1917+ B6B8              ;         C = Unit (0/1)
1918+ B6B8              ;         D = Logical track, 0 base
1919+ B6B8              ;         E = Logical sector, 0 base
1920+ B6B8              ;         HL = Address of buffer
1921+ B6B8              ;         IX = Address of XDPB
1922+ B6B8              ;
1923+ B6B8              ; EXIT CONDITIONS
1924+ B6B8              ;         If OK:
1925+ B6B8              ;                 Carry true
1926+ B6B8              ;                 A corrupt
1927+ B6B8              ;         Otherwise:
1928+ B6B8              ;                 Carry false
1929+ B6B8              ;                 A = Error code
1930+ B6B8              ;         Always:
1931+ B6B8              ;                 BC DE HL IX corrupt
1932+ B6B8              ;                 All other registers preserved
1933+ B6B8              ;
1934+ B6B8
1935+ B6B8              dd_check_sector: equ 0x0169 ; (361)
1936+ B6B8
1937+ B6B8              ; Check a sector. (Uses the uPD765A scan equal command.)
1938+ B6B8              ;
1939+ B6B8              ; Checks that the sector on disk is the same as the copy in memory.
1940+ B6B8              ;
1941+ B6B8              ; Note that FFh (255) on disk or in memory always matches anything (see
1942+ B6B8              ; uPD765A specification for further details).
1943+ B6B8              ;
1944+ B6B8              ; ENTRY CONDITIONS
1945+ B6B8              ;         B = Page for C000h (49152)...FFFFh (65535)
1946+ B6B8              ;         C = Unit (0/1)
1947+ B6B8              ;         D = Logical track, 0 base
1948+ B6B8              ;         E = Logical sector, 0 base
1949+ B6B8              ;         HL = Address of copy of sector
1950+ B6B8              ;         IX = Address of XDPB
1951+ B6B8              ;
1952+ B6B8              ; EXIT CONDITIONS
1953+ B6B8              ;         If OK (equal):
1954+ B6B8              ;                 Carry true
1955+ B6B8              ;                 Zero true
1956+ B6B8              ;                 A corrupt
1957+ B6B8              ;         If OK (not equal):
1958+ B6B8              ;                 Carry true
1959+ B6B8              ;                 Zero false
1960+ B6B8              ;                 A corrupt
1961+ B6B8              ;         Otherwise:
1962+ B6B8              ;                 Carry false
1963+ B6B8              ;                 A = Error code
1964+ B6B8              ;         Always:
1965+ B6B8              ;                 BC DE HL IX corrupt
1966+ B6B8              ;                 All other registers preserved
1967+ B6B8              ;
1968+ B6B8
1969+ B6B8              dd_format: equ 0x016c ; (364)
1970+ B6B8
1971+ B6B8              ; Format a track. (Uses the uPD765A format track command.)
1972+ B6B8              ;
1973+ B6B8              ; Buffer contains 4 bytes for each sector as follows:
1974+ B6B8              ;
1975+ B6B8              ;         C - Track number        (0...39)
1976+ B6B8              ;         H - Head number         (always 0 on the +3's single-sided
1977+ B6B8              ;                                 drives)
1978+ B6B8              ;         R - Sector number       (0...255)
1979+ B6B8              ;         N - Log2(sector size)-7 (2 for 512 byte sectors)
1980+ B6B8              ;
1981+ B6B8              ; ENTRY CONDITIONS
1982+ B6B8              ;         B = Page for C000h (49152)...FFFFh (65535)
1983+ B6B8              ;         C = Unit (0/1)
1984+ B6B8              ;         D = Logical track, 0 base
1985+ B6B8              ;         E = Filler byte, usually E5h (229)
1986+ B6B8              ;         HL = Address of format buffer
1987+ B6B8              ;         IX = Address of XDPB
1988+ B6B8              ;
1989+ B6B8              ; EXIT CONDITIONS
1990+ B6B8              ;         If OK:
1991+ B6B8              ;                 Carry true
1992+ B6B8              ;                 A corrupt
1993+ B6B8              ;         Otherwise:
1994+ B6B8              ;                 Carry false
1995+ B6B8              ;                 A = Error code
1996+ B6B8              ;         Always:
1997+ B6B8              ;                 BC DE HL IX corrupt
1998+ B6B8              ;                 All other registers preserved
1999+ B6B8              ;
2000+ B6B8
2001+ B6B8              dd_read_id: equ 0x016f ; (367)
2002+ B6B8
2003+ B6B8              ; Read a sector identifier.
2004+ B6B8              ;
2005+ B6B8              ; ENTRY CONDITIONS
2006+ B6B8              ;         C = Unit (0/1)
2007+ B6B8              ;         D = Logical track, 0 base
2008+ B6B8              ;         IX = Address of XDPB
2009+ B6B8              ;
2010+ B6B8              ; EXIT CONDITIONS
2011+ B6B8              ;         If OK:
2012+ B6B8              ;                 Carry true
2013+ B6B8              ;                 A = Sector number from identifier
2014+ B6B8              ;         Otherwise:
2015+ B6B8              ;                 Carry false
2016+ B6B8              ;                 A = Error code
2017+ B6B8              ;         Always:
2018+ B6B8              ;                 HL = Address of result buffer in page 7
2019+ B6B8              ;                 BC DE IX corrupt
2020+ B6B8              ;                 All other registers preserved
2021+ B6B8              ;
2022+ B6B8
2023+ B6B8              dd_test_unsuitable: equ 0x0172 ; (370)
2024+ B6B8
2025+ B6B8              ; Check that disk is suitable to write to.
2026+ B6B8              ;
2027+ B6B8              ; A single track disk will not work in a double track drive, and vice
2028+ B6B8              ; versa.
2029+ B6B8              ;
2030+ B6B8              ; ENTRY CONDITIONS
2031+ B6B8              ;         C = Unit (0/1)
2032+ B6B8              ;         IX = Address of XDPB
2033+ B6B8              ;
2034+ B6B8              ; EXIT CONDITIONS
2035+ B6B8              ;         If suitable:
2036+ B6B8              ;                 Carry true
2037+ B6B8              ;                 A corrupt
2038+ B6B8              ;         Otherwise:
2039+ B6B8              ;                 Carry false
2040+ B6B8              ;                 A = Error code
2041+ B6B8              ;         Always:
2042+ B6B8              ;                 BC DE HL IX corrupt
2043+ B6B8              ;                 All other registers preserved
2044+ B6B8              ;
2045+ B6B8
2046+ B6B8              dd_login: equ 0x0175 ; (373)
2047+ B6B8
2048+ B6B8              ; Log in a new disk.
2049+ B6B8              ;
2050+ B6B8              ; Initialise the XDPB.
2051+ B6B8              ;
2052+ B6B8              ; This routine does not affect or consider the freeze flag.
2053+ B6B8              ;
2054+ B6B8              ; ENTRY CONDITIONS
2055+ B6B8              ;         C = Unit (0/1)
2056+ B6B8              ;         IX = Address of destination XDPB
2057+ B6B8              ;
2058+ B6B8              ; EXIT CONDITIONS
2059+ B6B8              ;         If OK:
2060+ B6B8              ;                 Carry true
2061+ B6B8              ;                 A = Disk type
2062+ B6B8              ;                 DE = Size of allocation vector
2063+ B6B8              ;                 HL = Size of hash table
2064+ B6B8              ;         Otherwise:
2065+ B6B8              ;                 Carry false
2066+ B6B8              ;                 A = Error code
2067+ B6B8              ;                 DE HL corrupt
2068+ B6B8              ;         Always:
2069+ B6B8              ;                 BC IX corrupt
2070+ B6B8              ;                 All other registers preserved
2071+ B6B8              ;
2072+ B6B8
2073+ B6B8              dd_sel_format: equ 0x0178 ; (376)
2074+ B6B8
2075+ B6B8              ; Initialise an XDPB for a standard format.
2076+ B6B8              ;
2077+ B6B8              ; This routine does not affect or consider the freeze flag.
2078+ B6B8              ;
2079+ B6B8              ; ENTRY CONDITIONS
2080+ B6B8              ;         A = Disk type
2081+ B6B8              ;                 0 = Spectrum +3 format (AMSTRAD PCW range - DD SS ST)
2082+ B6B8              ;                 1 = AMSTRAD CPC range system format
2083+ B6B8              ;                 2 = AMSTRAD CPC range data-only format
2084+ B6B8              ;                 3 = AMSTRAD PCW range - DD SS DT
2085+ B6B8              ;                 (other values = error)
2086+ B6B8              ;         IX = Address of XDPB
2087+ B6B8              ;
2088+ B6B8              ; EXIT CONDITIONS
2089+ B6B8              ;         If OK:
2090+ B6B8              ;                 Carry true
2091+ B6B8              ;                 A = Disk type
2092+ B6B8              ;                 DE = Size of 2 bit allocation vector
2093+ B6B8              ;                 HL = Size of hash table
2094+ B6B8              ;         Otherwise:
2095+ B6B8              ;                 Carry false
2096+ B6B8              ;                 A = Error code
2097+ B6B8              ;                 DE HL corrupt
2098+ B6B8              ;         Always:
2099+ B6B8              ;                 BC IX corrupt
2100+ B6B8              ;                 All other registers preserved
2101+ B6B8              ;
2102+ B6B8
2103+ B6B8              dd_ask_1: equ 0x017b ; (379)
2104+ B6B8
2105+ B6B8              ; Check to see if unit 1 is present. (BASIC holds this information in
2106+ B6B8              ; bit 5 of the FLAGS3 system variable.)
2107+ B6B8              ;
2108+ B6B8              ; Turn motor on.
2109+ B6B8              ;
2110+ B6B8              ; Fetch drive status.
2111+ B6B8              ;
2112+ B6B8              ; If unit 1 is not-ready and write-protected, then unit 1 is missing.
2113+ B6B8              ; Start motor off timeout.
2114+ B6B8              ;
2115+ B6B8              ; Note that this routine can be fooled by disks which are almost, but
2116+ B6B8              ; not quite, inserted in the drive.
2117+ B6B8              ;
2118+ B6B8              ; This routine assumes that when a disk is not in the drive, then
2119+ B6B8              ; write-protect is true. This is indeed the case for 3 inch and 8 inch
2120+ B6B8              ; disk drives, but is not the case for 5 1/4 inch disk drives.
2121+ B6B8              ;
2122+ B6B8              ; ENTRY CONDITIONS
2123+ B6B8              ;         None
2124+ B6B8              ;
2125+ B6B8              ; EXIT CONDITIONS
2126+ B6B8              ;         If unit 1 present:
2127+ B6B8              ;                 Carry true
2128+ B6B8              ;         Otherwise:
2129+ B6B8              ;                 Carry false
2130+ B6B8              ;         Always:
2131+ B6B8              ;                 A BC DE HL IX corrupt
2132+ B6B8              ;                 All other registers preserved
2133+ B6B8              ;
2134+ B6B8
2135+ B6B8              dd_drive_status: equ 0x017e ; (382)
2136+ B6B8
2137+ B6B8              ; Issue a sense drive status command.
2138+ B6B8              ;
2139+ B6B8              ; ENTRY CONDITIONS
2140+ B6B8              ;         C = Unit/head
2141+ B6B8              ;                 bits 0...1 = unit
2142+ B6B8              ;                 bit 2 = head
2143+ B6B8              ;                 bits 3...7 = 0
2144+ B6B8              ;
2145+ B6B8              ; EXIT CONDITIONS
2146+ B6B8              ;                 A = ST3 (Status register 3 of uPD765A)
2147+ B6B8              ;         Always:
2148+ B6B8              ;                 F BC DE HL IX corrupt
2149+ B6B8              ;                 All other registers preserved
2150+ B6B8              ;
2151+ B6B8
2152+ B6B8              dd_equipment: equ 0x0181 ; (385)
2153+ B6B8
2154+ B6B8              ; Ask what type of drive this is (i.e. single/double track,
2155+ B6B8              ; single/double sided).
2156+ B6B8              ;
2157+ B6B8              ; Track information can only be determined once a disk has been seen and
2158+ B6B8              ; had its type identified during logging in.
2159+ B6B8              ;
2160+ B6B8              ; Side information can only be detected after a double sided disk has
2161+ B6B8              ; been seen and has its type identified during logging in.
2162+ B6B8              ;
2163+ B6B8              ; ENTRY CONDITIONS
2164+ B6B8              ;         C = Unit (0/1)
2165+ B6B8              ;         IX = Address of XDPB
2166+ B6B8              ;
2167+ B6B8              ; EXIT CONDITIONS
2168+ B6B8              ;                 A = Side/track information
2169+ B6B8              ;                         bits 0...1 = side information
2170+ B6B8              ;                                 0 = unknown
2171+ B6B8              ;                                 1 = single sided
2172+ B6B8              ;                                 2 = double sided
2173+ B6B8              ;                         bits 2...3 = track information
2174+ B6B8              ;                                 0 = unknown
2175+ B6B8              ;                                 1 = single track
2176+ B6B8              ;                                 2 = double track
2177+ B6B8              ;         Always:
2178+ B6B8              ;                 F BC DE HL IX corrupt
2179+ B6B8              ;                 All other registers preserved
2180+ B6B8              ;
2181+ B6B8
2182+ B6B8              dd_encode: equ 0x0184 ; (388)
2183+ B6B8
2184+ B6B8              ; Set the copy protection ENCODE subroutine.
2185+ B6B8              ;
2186+ B6B8              ; Copy protected disks have some of their track and sector numbers
2187+ B6B8              ; encoded on disk. Before each disk access, the ENCODE subroutine is
2188+ B6B8              ; called to encode the physical track and sector numbers.
2189+ B6B8              ;
2190+ B6B8              ; These encoded track and sector numbers must match those in the sector
2191+ B6B8              ; identifier.
2192+ B6B8              ;
2193+ B6B8              ; Note that tracks 0...2 on either side of a disk should not be encoded.
2194+ B6B8              ;
2195+ B6B8              ; ENTRY CONDTIONS
2196+ B6B8              ;         A = Enable/disable
2197+ B6B8              ;                 00h (0) = disable
2198+ B6B8              ;                 FFh (255) = enable
2199+ B6B8              ;         HL = (If enabled) address of ENCODE subroutine
2200+ B6B8              ;
2201+ B6B8              ; EXIT CONDITIONS
2202+ B6B8              ;                 HL = Address of previous ENCODE subroutine (0 if none)
2203+ B6B8              ;         Always:
2204+ B6B8              ;                 AF BC DE IX corrupt
2205+ B6B8              ;                 All other registers preserved
2206+ B6B8              ;
2207+ B6B8              ; NOTE
2208+ B6B8              ;         The definition of the subroutine ENCODE is as shown ahead.
2209+ B6B8              ;         Note that if you are substituting your own ENCODE subroutine,
2210+ B6B8              ;         the 'entry conditions' are the conditions passed to your
2211+ B6B8              ;         subroutine, and the 'exit conditions' are the values that your
2212+ B6B8              ;         subroutine must produce and the registers you are allowed to
2213+ B6B8              ;         corrupt.
2214+ B6B8              ;
2215+ B6B8              ;         ENCODE
2216+ B6B8              ;
2217+ B6B8              ;         ENTRY CONDITIONS
2218+ B6B8              ;                 C = Unit/side
2219+ B6B8              ;                         bits 0...1 = unit
2220+ B6B8              ;                         bit 2 = side
2221+ B6B8              ;                         bits 3...7 = 0
2222+ B6B8              ;                 D = Physical track
2223+ B6B8              ;                 E = Physical sector
2224+ B6B8              ;                 IX = Address of DPB
2225+ B6B8              ;
2226+ B6B8              ;         EXIT CONDITIONS
2227+ B6B8              ;                         D = Encoded physical track
2228+ B6B8              ;                         E = Encoded physical sector
2229+ B6B8              ;                 Always:
2230+ B6B8              ;                         AF corrupt
2231+ B6B8              ;                         All other registers preserved
2232+ B6B8              ;
2233+ B6B8
2234+ B6B8              dd_l_xdpb: equ 0x0187 ; (391)
2235+ B6B8
2236+ B6B8              ; Initialise an XDPB for a given format.
2237+ B6B8              ;
2238+ B6B8              ; This routine does not affect or consider the freeze flag.
2239+ B6B8              ;
2240+ B6B8              ; ENTRY CONDITIONS
2241+ B6B8              ;         IX = Address of destination XDPB
2242+ B6B8              ;         HL = Address of source disk specification
2243+ B6B8              ;
2244+ B6B8              ; EXIT CONDITIONS
2245+ B6B8              ;         If OK:
2246+ B6B8              ;                 Carry true
2247+ B6B8              ;                 A = Disk type recorded on disk
2248+ B6B8              ;                 DE = Size of allocation vector
2249+ B6B8              ;                 HL = Size of hash table
2250+ B6B8              ;         If bad format:
2251+ B6B8              ;                 Carry false
2252+ B6B8              ;                 A = Error code
2253+ B6B8              ;                 DE HL corrupt
2254+ B6B8              ;         Always:
2255+ B6B8              ;                 BC IX corrupt
2256+ B6B8              ;                 All other registers preserved
2257+ B6B8              ;
2258+ B6B8
2259+ B6B8              dd_l_dpb: equ 0x018a ; (394)
2260+ B6B8
2261+ B6B8              ; Initialise a DPB for a given format.
2262+ B6B8              ;
2263+ B6B8              ; This routine does not affect or consider the freeze flag.
2264+ B6B8              ;
2265+ B6B8              ; ENTRY CONDITIONS
2266+ B6B8              ;         IX = Address of destination DPB
2267+ B6B8              ;         HL = Address of source disk specification
2268+ B6B8              ;
2269+ B6B8              ; EXIT CONDITIONS
2270+ B6B8              ;         If OK:
2271+ B6B8              ;                 Carry true
2272+ B6B8              ;                 A = Disk type recorded on disk
2273+ B6B8              ;                 DE = Size of allocation vector
2274+ B6B8              ;                 HL = Size of hash table
2275+ B6B8              ;         If bad format:
2276+ B6B8              ;                 Carry false
2277+ B6B8              ;                 A = Error code
2278+ B6B8              ;                 DE HL corrupt
2279+ B6B8              ;         Always:
2280+ B6B8              ;                 BC IX corrupt
2281+ B6B8              ;                 All other registers preserved
2282+ B6B8              ;
2283+ B6B8
2284+ B6B8              dd_l_seek: equ 0x018d ; (397)
2285+ B6B8
2286+ B6B8              ; Seek to required track.
2287+ B6B8              ;
2288+ B6B8              ; Retry if fails.
2289+ B6B8              ;
2290+ B6B8              ; ENTRY CONDITIONS
2291+ B6B8              ;         C = Unit/head
2292+ B6B8              ;                 bits 0...1 = unit
2293+ B6B8              ;                 bit 2 = head
2294+ B6B8              ;                 bits 3...7 = 0
2295+ B6B8              ;         D = Track
2296+ B6B8              ;         IX = Address of XDPB
2297+ B6B8              ;
2298+ B6B8              ; EXIT CONDITIONS
2299+ B6B8              ;         If OK:
2300+ B6B8              ;                 Carry true
2301+ B6B8              ;                 A corrupt
2302+ B6B8              ;         Otherwise:
2303+ B6B8              ;                 Carry false
2304+ B6B8              ;                 A = Error report
2305+ B6B8              ;         Always:
2306+ B6B8              ;                 BC DE HL IX corrupt
2307+ B6B8              ;                 All other registers preserved
2308+ B6B8              ;
2309+ B6B8
2310+ B6B8              dd_l_read: equ 0x0190 ; (400)
2311+ B6B8
2312+ B6B8              ; Low level uPD765A read command.
2313+ B6B8              ;
2314+ B6B8              ; Read data.
2315+ B6B8              ;
2316+ B6B8              ; Read deleted data.
2317+ B6B8              ;
2318+ B6B8              ; Read a track.
2319+ B6B8              ;
2320+ B6B8              ; Parameter block format:
2321+ B6B8              ;
2322+ B6B8              ;         Byte 0          - Page for C000h (49152)...FFFFh (65535)
2323+ B6B8              ;         Bytes 1...2     - Address of buffer
2324+ B6B8              ;         Bytes 3...4     - Number of bytes to transfer
2325+ B6B8              ;         Byte 5          - Number of command bytes
2326+ B6B8              ;         Bytes 6...      - Command bytes
2327+ B6B8              ;
2328+ B6B8              ; Writes commands.
2329+ B6B8              ;
2330+ B6B8              ; Reads data.
2331+ B6B8              ;
2332+ B6B8              ; Reads results.
2333+ B6B8              ;
2334+ B6B8              ; Motor must be running.
2335+ B6B8              ;
2336+ B6B8              ; ENTRY CONDITIONS
2337+ B6B8              ;         HL = Address of parameter block
2338+ B6B8              ;
2339+ B6B8              ; EXIT CONDITIONS
2340+ B6B8              ;                 HL = Address of result buffer in page 7
2341+ B6B8              ;         Always:
2342+ B6B8              ;                 AF BC DE IX corrupt
2343+ B6B8              ;                 All other registers preserved
2344+ B6B8              ;
2345+ B6B8
2346+ B6B8              dd_l_write: equ 0x0193 ; (403)
2347+ B6B8
2348+ B6B8              ; Low level uPD765A write command.
2349+ B6B8              ;
2350+ B6B8              ; Write data.
2351+ B6B8              ;
2352+ B6B8              ; Write deleted data.
2353+ B6B8              ;
2354+ B6B8              ; Format a track.
2355+ B6B8              ;
2356+ B6B8              ; Scan equal.
2357+ B6B8              ;
2358+ B6B8              ; Scan low or equal.
2359+ B6B8              ;
2360+ B6B8              ; Scan high or equal.
2361+ B6B8              ;
2362+ B6B8              ; Parameter block format:
2363+ B6B8              ;
2364+ B6B8              ;         Byte 0          - Page for C000h (49152)...FFFFh (65535)
2365+ B6B8              ;         Bytes 1...2     - Address of buffer
2366+ B6B8              ;         Bytes 3...4     - Number of bytes to transfer
2367+ B6B8              ;         Byte 5          - Number of command bytes
2368+ B6B8              ;         Bytes 6...      - Command bytes
2369+ B6B8              ;
2370+ B6B8              ; Writes commands.
2371+ B6B8              ;
2372+ B6B8              ; Writes data.
2373+ B6B8              ;
2374+ B6B8              ; Reads results.
2375+ B6B8              ;
2376+ B6B8              ; Motor must be running.
2377+ B6B8              ;
2378+ B6B8              ; ENTRY CONDITIONS
2379+ B6B8              ;         HL = Address of parameter block
2380+ B6B8              ;
2381+ B6B8              ; EXIT CONDITIONS
2382+ B6B8              ;                 HL = Address of result buffer in page 7
2383+ B6B8              ;         Always:
2384+ B6B8              ;                 AF BC DE IX corrupt
2385+ B6B8              ;                 All other registers preserved
2386+ B6B8              ;
2387+ B6B8
2388+ B6B8              dd_l_on_motor: equ 0x0196 ; (406)
2389+ B6B8
2390+ B6B8              ; Turn on the motor.
2391+ B6B8              ;
2392+ B6B8              ; Wait for the motor on time as set by DD SETUP.
2393+ B6B8              ;
2394+ B6B8              ; ENTRY CONDITIONS
2395+ B6B8              ;         None
2396+ B6B8              ;
2397+ B6B8              ; EXIT CONDITIONS
2398+ B6B8              ;         Always:
2399+ B6B8              ;                 AF BC DE HL IX corrupt
2400+ B6B8              ;                 All other registers preserved
2401+ B6B8              ;
2402+ B6B8
2403+ B6B8              dd_l_t_off_motor: equ 0x0199 ; (409)
2404+ B6B8
2405+ B6B8              ; Start the motor off time-out.
2406+ B6B8              ;
2407+ B6B8              ; ENTRY CONDITIONS
2408+ B6B8              ;         None
2409+ B6B8              ;
2410+ B6B8              ; EXIT CONDITIONS
2411+ B6B8              ;         Always:
2412+ B6B8              ;                 AF BC DE HL IX corrupt
2413+ B6B8              ;                 All other registers preserved
2414+ B6B8              ;
2415+ B6B8
2416+ B6B8              dd_l_off_motor: equ 0x019c ; (412)
2417+ B6B8
2418+ B6B8              ; Turn off the motor.
2419+ B6B8              ;
2420+ B6B8              ; ENTRY CONDITIONS
2421+ B6B8              ;         None
2422+ B6B8              ;
2423+ B6B8              ; EXIT CONDITIONS
2424+ B6B8              ;         Always:
2425+ B6B8              ;                 AF BC DE HL IX corrupt
2426+ B6B8              ;                 All other registers preserved
2427+ B6B8
2428+ B6B8              ; +3DOS constants
2429+ B6B8              OPEN_ACTION_ERROR_EXISTS            equ 0
2430+ B6B8              OPEN_ACTION_READ_HEADER             equ 1
2431+ B6B8              OPEN_ACTION_IGNORE_HEADER           equ 2
2432+ B6B8              OPEN_ACTION_MAKE_BACKUP             equ 3
2433+ B6B8              OPEN_ACTION_OVERWRITE               equ 4
2434+ B6B8
2435+ B6B8              CREATE_ACTION_DONT_CREATE           equ 0
2436+ B6B8              CREATE_ACTION_WITH_HEADER           equ 1
2437+ B6B8              CREATE_ACTION_WITHOUT_HEADER        equ 2
2438+ B6B8
2439+ B6B8              FILE_TYPE_BASIC                     equ 0
2440+ B6B8              FILE_TYPE_NUM_ARRAY                 equ 1
2441+ B6B8              FILE_TYPE_CHR_ARRAY                 equ 2
2442+ B6B8              FILE_TYPE_BYTES                     equ 3
2443+ B6B8
2444+ B6B8              ACCESS_MODE_EXCLUSIVE_READ          equ 1
2445+ B6B8              ACCESS_MODE_EXCLUSIVE_WRITE         equ 2
2446+ B6B8              ACCESS_MODE_EXCLUSIVE_READ_WRITE    equ 3
2447+ B6B8              ACCESS_MODE_SHARED                  equ 5
2448+ B6B8
2449+ B6B8              ; +3E extensions
2450+ B6B8
2451+ B6B8              ide_version             equ     $00A0
2452+ B6B8              ide_interface           equ     $00A3
2453+ B6B8              ide_init                equ     $00A6
2454+ B6B8              ide_drive               equ     $00A9
2455+ B6B8              ide_sector_read         equ     $00AC
2456+ B6B8              ide_sector_write        equ     $00AF
2457+ B6B8              ide_format              equ     $00B2
2458+ B6B8              ide_partition_find      equ     $00B5
2459+ B6B8              ide_partition_new       equ     $00B8
2460+ B6B8              ide_partition_init      equ     $00BB
2461+ B6B8              ide_partition_erase     equ     $00BE
2462+ B6B8              ide_partition_rename    equ     $00C1
2463+ B6B8              ide_partition_read      equ     $00C4
2464+ B6B8              ide_partition_write     equ     $00C7
2465+ B6B8              ide_partition_winfo     equ     $00CA
2466+ B6B8              ide_partition_open      equ     $00CD
2467+ B6B8              ide_partition_close     equ     $00D0
2468+ B6B8              ide_partition_getinfo   equ     $00D3
2469+ B6B8              ide_partition_setinfo   equ     $00D6
2470+ B6B8              ide_swap_open           equ     $00D9
2471+ B6B8              ide_swap_close          equ     $00DC
2472+ B6B8              ide_swap_out            equ     $00DF
2473+ B6B8              ide_swap_in             equ     $00E2
2474+ B6B8              ide_swap_ex             equ     $00E5
2475+ B6B8              ide_swap_pos            equ     $00E8
2476+ B6B8              ide_swap_move           equ     $00EB
2477+ B6B8              ide_swap_resize         equ     $00EE
2478+ B6B8              ide_dos_map             equ     $00F1
2479+ B6B8              ide_dos_unmap           equ     $00F4
2480+ B6B8              ide_dos_mapping         equ     $00F7
2481+ B6B8              ide_dos_unpermanent     equ     $00FA
2482+ B6B8              ide_snapload            equ     $00FD
2483+ B6B8
2484+ B6B8              ide_access_data         equ     $019F
2485+ B6B8              ide_identify            equ     $01A2
2486+ B6B8              ide_partitiions         equ     $01A5
2487+ B6B8
# file closed: p3dos.asm
 422  B6B8                  include "prtwifi.asm"
# file opened: prtwifi.asm
   1+ B6B8              ; ==============================================================================================
   2+ B6B8              ; RS232 through +3 printer port, 57600, 8N1, +CTS, -RTS
   3+ B6B8              ; 57600bps (17,3611s)
   4+ B6B8              ; 61.57813T on ZX 128k, 61T will take 17.19811s, error -0.9% (58146bps)
   5+ B6B8              ; 60.76389T on ZX 48k,  61T will take 17.42857s, error +0.4% (57377bps)
   6+ B6B8              ;
   7+ B6B8              ; Based on some *amazing* work here: https://cygnus.speccy.cz/popis_zx-spectrum_dg192k_rs232.php
   8+ B6B8              ; ==============================================================================================
   9+ B6B8
  10+ B6B8              ; --------------------------------------
  11+ B6B8              ; 0xFFD: Printer port data latch (Write)
  12+ B6B8              ; --------------------------------------
  13+ B6B8              ;         Bit 7   TX
  14+ B6B8              ;         Bit 0   CTS
  15+ B6B8              ; --------------------------------------
  16+ B6B8              ; 0xFFD: Printer port busy (Read)
  17+ B6B8              ; --------------------------------------
  18+ B6B8              ;         Bit 0   RX
  19+ B6B8              ; --------------------------------------
  20+ B6B8
  21+ B6B8              uartBegin:
  22+ B6B8 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC
  23+ B6BB 3E 80            ld   a, 0x80                ; 7T    TX = 1, CTS = 0 (allow sending)
  24+ B6BD ED 79            out  (c), a                 ; 12T
  25+ B6BF
  26+ B6BF FB               ei                          ; Re-enable interrupts, just in case
  27+ B6C0 3E 32            ld   a, 50                  ; Flush anything left in TX buffer, by keeping CTS low
  28+ B6C2 76           1:  halt                        ; for ~1 second
  29+ B6C3 3D               dec  a
  30+ B6C4 20 FC            jr   nz, 1B
  31+ B6C6 F3               di                          ; Timing critical now, so diable interrupts
  32+ B6C7
  33+ B6C7 3E 81            ld   a, 0x81                ; 7T    TX = 1, CTS = 1 (stop sending)
  34+ B6C9 ED 79            out  (c), a                 ; 12T
  35+ B6CB
  36+ B6CB DD 7E 00         ld   a, (ix + 0)            ; 19T   Wait at least one bit
  37+ B6CE DD 7E 00         ld   a, (ix + 0)            ; 19T
  38+ B6D1 DD 7E 00         ld   a, (ix + 0)            ; 19T
  39+ B6D4 C9               ret                         ; 10T
  40+ B6D5
  41+ B6D5              uartWriteByte:
  42+ B6D5 F3               di
  43+ B6D6
  44+ B6D6 01 FD 0F         ld   bc, 0xFFD              ; 10T Printer port to BC
  45+ B6D9 26 08            ld   h, 8                   ; 7T H serves as an 8-bit counter
  46+ B6DB 6F               ld   l, a                   ; 4T copy data from A to L
  47+ B6DC
  48+ B6DC 00               nop                         ; 4T
  49+ B6DD 00               nop                         ; 4T
  50+ B6DE 00               nop                         ; 4T
  51+ B6DF 00               nop                         ; 4T
  52+ B6E0
  53+ B6E0              ; start bit
  54+ B6E0 3E 01            ld   a, 1                   ; TX = 1 (Start bit), CTS = 0 (allow sending - why, we're sending?! - maybe should be 0x81?)
  55+ B6E2 ED 79            out  (c), a                 ; 12T write to port
  56+ B6E4
  57+ B6E4 00               nop                         ; 4T
  58+ B6E5 00               nop                         ; 4T
  59+ B6E6 00               nop                         ; 4T
  60+ B6E7 00               nop                         ; 4T
  61+ B6E8
  62+ B6E8              ; data bits
  63+ B6E8              txLoop:
  64+ B6E8 3E 00            ld   a, 0                   ; 7T delay
  65+ B6EA 3E 00            ld   a, 0                   ; 7T delay
  66+ B6EC
  67+ B6EC CB 0D            rrc  l                      ; 8T next bit at bit position 7
  68+ B6EE 3E 01            ld   a, 1                   ; 7T prepare a mask
  69+ B6F0 B5               or   l                      ; 4T add a mask
  70+ B6F1
  71+ B6F1              ; from the beginning start bit 12 + 8 + 8 + 7 + 7 + 8 + 7 + 4 = 61T
  72+ B6F1              ; from last bit 12 + 4 + 12 + 7 + 7 + 8 + 7 + 4 = 61T
  73+ B6F1
  74+ B6F1 ED 79            out  (c), a                 ; 12T write to port
  75+ B6F3 25               dec  h                      ; 4T bit counter
  76+ B6F4 20 F2            jr   nz, txLoop             ; 12 / 7T repeat
  77+ B6F6
  78+ B6F6              ; stop bit
  79+ B6F6 DD 7E 00         ld   a, (ix + 0)            ; 19T delay
  80+ B6F9 23               inc  hl                     ; 6T delay
  81+ B6FA 2B               dec  hl                     ; 6T delay
  82+ B6FB 3E 81            ld   a, 0x81                ; 7T, keep bit 0 (CTS) and 7 (TX - stop bit) high (stop sending)
  83+ B6FD
  84+ B6FD              ; since the last out in the cycle 12 + 4 + 7 + 19 + 6 + 6 + 7 = 61T
  85+ B6FD
  86+ B6FD ED 79            out   (c), a                ; 12T write to port
  87+ B6FF FB               ei
  88+ B700 C9               ret                         ; 10T extends the stop bit duration
  89+ B701
  90+ B701              uartReadBlocking:
  91+ B701 F3               di
  92+ B702
  93+ B702 AF               xor  a                      ; Reset read error count
  94+ B703 32 51 B7         ld   (readErrors), a
  95+ B706
  96+ B706 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC
  97+ B709
  98+ B709              ; Check that RX is idle
  99+ B709
 100+ B709              rxRetry:
 101+ B709 ED 78            in   a, (c)                 ; 12T   reads the port, sets the sign flag according to MSB
 102+ B70B E6 01            and  1                      ; 7T
 103+ B70D CA 45 B7         jp   z, rxError             ; 10T   error, RxD should be in log. 1 (idle state / stop bit)
 104+ B710
 105+ B710              ; detection delay 12 + 7 + 10 = 29T
 106+ B710
 107+ B710 3E 80            ld   a, 0x80                ; 7T    TX = 1, CTS = 0
 108+ B712 ED 79            out  (c), a                 ; 12T   Assert CTS to get a byte from the ESP
 109+ B714
 110+ B714              ; Wait for the start bit
 111+ B714
 112+ B714              rxWFSB:
 113+ B714 ED 78        1:  in   a, (c)                 ; 12T   read port
 114+ B716 0F               rrca                        ; 4T    bit 0 to carry flag
 115+ B717 DA 14 B7         jp   c, 1B                  ; 10T   Repeat to start bit
 116+ B71A
 117+ B71A              ; waiting loop 12 + 4 + 10 = 26T
 118+ B71A
 119+ B71A              ; Immediately de-assert CTS to stop the ESP transmitting another byte
 120+ B71A              ; while we process this one
 121+ B71A
 122+ B71A 3E 81            ld   a, 0x81                ; 7T    TX = 1, CTS = 1
 123+ B71C ED 79            out  (c), a                 ; 12T
 124+ B71E
 125+ B71E              ; start bit started, waiting for bit 0
 126+ B71E              ; the wait length is chosen so that bit 0 is somewhere in its middle
 127+ B71E              ; at least 15T has passed from the edge of the start bit, at most 41T, we take an average of 28T
 128+ B71E              ; you still have to wait 1.5 x 61T - 28T = 63.5T (of which 11T for another IN instruction)
 129+ B71E
 130+ B71E D9               exx                         ; 4T    secondary set
 131+ B71F 01 FD 0F         ld   bc, 0xFFD              ; 10T   printer port to BC '(and delay at the same time)
 132+ B722 23               inc  hl                     ; 6T    delay
 133+ B723 2B               dec  hl                     ; 6T    delay
 134+ B724 26 07            ld   h, 7                   ; 7T    in the cycle will be read 7 bits and 8th at the end of the cycle
 135+ B726
 136+ B726              ; 6 + 6 + 4 + 10 + 6 + 6 + 7 + 7 = 52T
 137+ B726              ; now bit 0 is somewhere in the middle, we can read 8 times with a distance of 61T
 138+ B726
 139+ B726              rxLoop:
 140+ B726 ED 78            in   a, (c)                 ; 12T   load port
 141+ B728 0F               rrca                        ; 4T    bit 0 to carry flag
 142+ B729 CB 1D            rr   l                      ; 8T    build byte in L
 143+ B72B 3E 00            ld   a, 0                   ; 7T    delay
 144+ B72D 3E 00            ld   a, 0                   ; 7T    delay
 145+ B72F ED 5F            ld   a, r                   ; 9T    delay
 146+ B731 25               dec  h                      ; 4T    counter
 147+ B732 C2 26 B7         jp   nz, rxLoop             ; 10T   reads more bits
 148+ B735
 149+ B735              ; 12 + 4 + 8 + 7 + 7 + 9 + 4 + 10 = 61T if repeated (bits 0 to 6)
 150+ B735
 151+ B735              ; followed by reading the MSB, bit 7
 152+ B735
 153+ B735 ED 78            in   a, (c)                 ; 12T   read port (MSB is somewhere in the middle of the duration, to the stop bit approx. 31  13T  2T accuracy deviation 3%)
 154+ B737 0F               rrca                        ; 4T    bit 0 to carry flag
 155+ B738 7D               ld   a, l                   ; 4T    almost assembled byte to A
 156+ B739 1F               rra                         ; 4T    rotate the MSB to bit 7 in A
 157+ B73A
 158+ B73A              ; 12 + 4 + 4 + 4 = 24T
 159+ B73A
 160+ B73A D9               exx                         ; 4T    primary set
 161+ B73B
 162+ B73B              ; Delay for stop bit
 163+ B73B
 164+ B73B 08               ex   af, af'                ; 4T
 165+ B73C DD 7E 00         ld   a, (ix + 0)            ; 19T delay
 166+ B73F DD 7E 00         ld   a, (ix + 0)            ; 19T delay
 167+ B742              ;    xor  a                      ; 4T
 168+ B742              ;    out  (-2), a                ; 11T    Black border
 169+ B742 08               ex   af, af'                ; 4T
 170+ B743
 171+ B743 FB               ei                          ; 4T
 172+ B744 C9               ret                         ; 10T   Return with byte in A
 173+ B745
 174+ B745              ; 4 + 19 + 4 + 11 + 4 + 4 + 10 = 53T
 175+ B745
 176+ B745              rxError
 177+ B745 21 51 B7         ld   hl, readErrors         ; 3T
 178+ B748 34               inc  (hl)                   ; 11T
 179+ B749 C2 09 B7         jp   nz, rxRetry            ; 7/12T
 180+ B74C
 181+ B74C 3E 02            ld   a, 2                   ; 7T
 182+ B74E D3 FE            out  (-2), a                ; 11T
 183+ B750 C9               ret                         ; 10T
 184+ B751
 185+ B751              ; 3 + 11 + 12 = 26T
 186+ B751
 187+ B751              readErrors:
 188+ B751 00               db   0
 189+ B752
 190+ B752              ; saving the apartment takes 4 + 7 + 4 + 4 + 10 = 29T
 191+ B752              ; total 24 + 29 = 53T
 192+ B752              ; including line status detection, 75T with verification before start bit
 193+ B752              ; otherwise, you can directly wait for the next start bit
 194+ B752
# file closed: prtwifi.asm
 423  B752                  include "ring.asm"
# file opened: ring.asm
   1+ B752              ; Pushes A to ring buffer
   2+ B752              pushRing
   3+ B752 4F               ld   c, a                           ; Save byte in A to C
   4+ B753 06 20            ld   b, 32
   5+ B755
   6+ B755                  ; Copy bytes in buffer down one position
   7+ B755
   8+ B755 21 94 B7         ld   hl, ring_buffer + 1
   9+ B758 11 93 B7         ld   de, ring_buffer
  10+ B75B              1:
  11+ B75B 7E               ld   a, (hl)
  12+ B75C 12               ld   (de), a
  13+ B75D 23               inc  hl
  14+ B75E 13               inc  de
  15+ B75F 10 FA            djnz 1B
  16+ B761
  17+ B761 79               ld   a, c                           ; Get byte back from C
  18+ B762 21 B2 B7         ld   hl, ring_buffer + 31           ; Write byte to end of buffer
  19+ B765 77               ld   (hl), a
  20+ B766 C9               ret
  21+ B767
  22+ B767              ; Entry:
  23+ B767              ;   HL: Search string (null terminated)
  24+ B767              ; Exit:
  25+ B767              ;   Fc: 1 Found
  26+ B767              ;       0 Not found
  27+ B767              searchRing:
  28+ B767 E5               push hl
  29+ B768
  30+ B768 06 00            ld   b, 0
  31+ B76A 11 B3 B7         ld   de, ring_buffer + 32           ; Start at end of buffer
  32+ B76D
  33+ B76D              strlen:
  34+ B76D 7E               ld   a, (hl)                        ; Get the length of the string to compare
  35+ B76E 23               inc  hl                             ; Count bytes in B until we get to a 0
  36+ B76F 1B               dec  de                             ; Move ring buffer search position back
  37+ B770 04               inc  b
  38+ B771 A7               and  a
  39+ B772 C2 6D B7         jp   nz, strlen
  40+ B775
  41+ B775 05               dec  b                              ; Don't count 0 string terminator
  42+ B776 13               inc  de
  43+ B777
  44+ B777 E1               pop  hl
  45+ B778
  46+ B778              strcmp:                                 ; B = strlen (without 0 terminator)
  47+ B778 1A               ld   a, (de)
  48+ B779 BE               cp   (hl)
  49+ B77A C2 83 B7         jp   nz, .failed
  50+ B77D 13               inc  de
  51+ B77E 23               inc  hl
  52+ B77F 10 F7            djnz strcmp
  53+ B781 37               scf
  54+ B782 C9               ret
  55+ B783
  56+ B783              .failed
  57+ B783 AF               xor  a
  58+ B784 C9               ret
  59+ B785
  60+ B785              clearRing:
  61+ B785 AF               xor  a
  62+ B786 21 93 B7         ld   hl, ring_buffer
  63+ B789 11 94 B7         ld   de, ring_buffer + 1
  64+ B78C 01 20 00         ld   bc, 32
  65+ B78F 77               ld   (hl), a
  66+ B790 ED B0            ldir
  67+ B792 C9               ret
  68+ B793
  69+ B793              ; dumpRing:
  70+ B793              ;     push af
  71+ B793              ;
  72+ B793              ;     ld   b, 32
  73+ B793              ;     ld   hl, ring_buffer
  74+ B793              ; 1:
  75+ B793              ;     ld   a, (hl)
  76+ B793              ;     cp   31
  77+ B793              ;     jr   c, 1F
  78+ B793              ; 2:
  79+ B793              ;     push bc
  80+ B793              ;     push hl
  81+ B793              ;     call putc
  82+ B793              ;     pop  hl
  83+ B793              ;     pop  bc
  84+ B793              ;
  85+ B793              ;     inc  hl
  86+ B793              ;     djnz 1B
  87+ B793              ;
  88+ B793              ;     ld   a, 13
  89+ B793              ;     call putc
  90+ B793              ;
  91+ B793              ;     pop  af
  92+ B793              ;     ret
  93+ B793              ; 1:
  94+ B793              ;     ld   a, '.'
  95+ B793              ;     jr   2B
  96+ B793
  97+ B793              ring_buffer
  98+ B793 00 00 00...      ds  32, 0
  99+ B7B3
# file closed: ring.asm
 424  B7B3                  include "utils.asm"
# file opened: utils.asm
   1+ B7B3              ;    IFNDEF ZX48
   2+ B7B3              ; ; This routine checks availability of extended(128K) memory.
   3+ B7B3              ; ; Output:
   4+ B7B3              ; ; Flag: Z - High memory available
   5+ B7B3              ; checkHighMem:
   6+ B7B3              ;     xor a : call changeBank : ld hl, #c000 : xor a : ld (hl), a ; Let's write in zero page zero value
   7+ B7B3              ;     inc a : call changeBank : ld a, 13 : ld (hl), a             ; In other page - any other value. Let's write luck 13
   8+ B7B3              ;     xor a : call changeBank : ld a, (hl) : and a                ; When we back to zero page - still there zero?!
   9+ B7B3              ;     ret
  10+ B7B3              ;
  11+ B7B3              ; ; A - memory bank
  12+ B7B3              ; changeBank:
  13+ B7B3              ;     ld bc, #7ffd : or #18 : out (c), a : ld (bankm), a
  14+ B7B3              ;     re
  15+ B7B3              ;     ENDIF
  16+ B7B3
  17+ B7B3              uartWriteStringZ:
  18+ B7B3              ;     IFDEF DEBUG
  19+ B7B3              ;     push hl
  20+ B7B3              ;     call putstr
  21+ B7B3              ;     pop  hl
  22+ B7B3              ;     ENDIF
  23+ B7B3
  24+ B7B3 7E           1:  ld   a, (hl)
  25+ B7B4 A7               and  a
  26+ B7B5 28 0E            jr   z, 2F
  27+ B7B7 E5               push hl
  28+ B7B8 CD D5 B6         call uartWriteByte
  29+ B7BB E1               pop  hl
  30+ B7BC
  31+ B7BC ED 5F            ld   a, r
  32+ B7BE E6 07            and  7
  33+ B7C0 D3 FE            out  (-2), a
  34+ B7C2
  35+ B7C2 23               inc  hl
  36+ B7C3 18 EE            jr   1B
  37+ B7C5
  38+ B7C5 AF           2:  xor  a
  39+ B7C6 D3 FE            out  (-2), a
  40+ B7C8
  41+ B7C8 C9               ret
  42+ B7C9
  43+ B7C9              ; Print zero-terminated string
  44+ B7C9              ; HL - string pointer
  45+ B7C9              ; putStringZ:
  46+ B7C9              ; printZ64:
  47+ B7C9              ;     IFNDEF ZX48
  48+ B7C9              ;     ld a, 7 : call changeBank
  49+ B7C9              ;     ENDIF
  50+ B7C9              ;     ld   b, 41
  51+ B7C9              ; 1:
  52+ B7C9              ;     ld   a, (hl) : and a : ret z
  53+ B7C9              ;     push bc
  54+ B7C9              ;     push hl : call putC : pop hl
  55+ B7C9              ;     inc  hl
  56+ B7C9              ;     pop  bc
  57+ B7C9              ;
  58+ B7C9              ;     dec  b                              ; Limit string display length
  59+ B7C9              ;     ld   a, b
  60+ B7C9              ;     or   a
  61+ B7C9              ;     ret  z
  62+ B7C9              ;     jr  1B
  63+ B7C9              ;
  64+ B7C9              ; printT64:
  65+ B7C9              ;     ld   b, 41
  66+ B7C9              ; 1:
  67+ B7C9              ;     xor  a : or b : ret z
  68+ B7C9              ;
  69+ B7C9              ;     ld   a, (hl)
  70+ B7C9              ;
  71+ B7C9              ;     and  a : ret z
  72+ B7C9              ;     cp   09 : ret z
  73+ B7C9              ;
  74+ B7C9              ;     push bc
  75+ B7C9              ;
  76+ B7C9              ;     push hl : call putC : pop hl
  77+ B7C9              ;
  78+ B7C9              ;     inc  hl : pop bc : dec b
  79+ B7C9              ;     jr   1B
  80+ B7C9              ;
  81+ B7C9              ; printL64:
  82+ B7C9              ;
  83+ B7C9              ;     ld b, 41
  84+ B7C9              ; .loop
  85+ B7C9              ;     xor a : or b : ret z
  86+ B7C9              ;     ld a, (hl)
  87+ B7C9              ;
  88+ B7C9              ;     and a : ret z
  89+ B7C9              ;     cp #0A : ret z
  90+ B7C9              ;     cp #0D : ret z;
  91+ B7C9              ;
  92+ B7C9              ;     push hl, bc : call putC : pop bc, hl
  93+ B7C9              ;     dec b
  94+ B7C9              ;     inc hl
  95+ B7C9              ;     jr .loop
  96+ B7C9
  97+ B7C9              ; HL - string
  98+ B7C9              ; Return: bc - len
  99+ B7C9              getStringLength:
 100+ B7C9 01 00 00         ld bc, 0
 101+ B7CC              strLnLp
 102+ B7CC 7E               ld a, (hl)
 103+ B7CD A7               and a
 104+ B7CE C8               ret z
 105+ B7CF 03               inc bc
 106+ B7D0 23               inc hl
 107+ B7D1 18 F9            jr strLnLp
 108+ B7D3
 109+ B7D3              SkipWhitespace:
 110+ B7D3 7E               ld a, (hl)
 111+ B7D4 FE 20            cp ' '
 111+ B7D6 C0             ret nz
 112+ B7D7 23               inc hl
 113+ B7D8 18 F9            jr SkipWhitespace
 114+ B7DA
 115+ B7DA              ; DE <= StringZ
 116+ B7DA              ; HL => output
 117+ B7DA              atoi:
 118+ B7DA 21 00 00         ld   hl, 0
 119+ B7DD 1A           1:  ld   a, (de)
 120+ B7DE A7               and  a
 120+ B7DF C8             ret z
 121+ B7E0 FE 0D            cp   13
 121+ B7E2 C8             ret z
 122+ B7E3 FE 09            cp   9
 122+ B7E5 C8             ret z
 123+ B7E6 CD EC B7         call atoi2
 124+ B7E9 13               inc  de
 125+ B7EA 18 F1            jr 1B
 126+ B7EC
 127+ B7EC              atoi2:
 128+ B7EC D6 30            sub  0x30
 129+ B7EE 4D               ld   c, l
 130+ B7EF 44               ld   b, h
 131+ B7F0 29               add  hl, hl
 132+ B7F1 29               add  hl, hl
 133+ B7F2 09               add  hl, bc
 134+ B7F3 29               add  hl, hl
 135+ B7F4 4F               ld   c, a
 136+ B7F5 06 00            ld   b, 0
 137+ B7F7 09               add  hl, bc
 138+ B7F8 C9               ret
 139+ B7F9
 140+ B7F9              ;findEnd:
 141+ B7F9              ;    ld   a, (hl)
 142+ B7F9              ;    and  a
 143+ B7F9              ;    ret  z
 144+ B7F9              ;    inc  hl
 145+ B7F9              ;    jr   findEnd
 146+ B7F9
 147+ B7F9              ;;;;;;;;;;;;;;;;;;;;;;;;
 148+ B7F9
 149+ B7F9              ; Binary to decimal stuff
 150+ B7F9              ; From https://www.msx.org/forum/development/msx-development/32-bit-long-ascii
 151+ B7F9
 152+ B7F9              ; Combined routine for conversion of different sized binary numbers into
 153+ B7F9              ; directly printable ASCII(Z)-string
 154+ B7F9              ; Input value in registers, number size and -related to that- registers to fill
 155+ B7F9              ; is selected by calling the correct entry:
 156+ B7F9              ;
 157+ B7F9              ;  entry  inputregister(s)  decimal value 0 to:
 158+ B7F9              ;   B2D8             A                    255  (3 digits)
 159+ B7F9              ;   B2D16           HL                  65535   5   "
 160+ B7F9              ;   B2D24         E:HL               16777215   8   "
 161+ B7F9              ;   B2D32        DE:HL             4294967295  10   "
 162+ B7F9              ;   B2D48     BC:DE:HL        281474976710655  15   "
 163+ B7F9              ;   B2D64  IX:BC:DE:HL   18446744073709551615  20   "
 164+ B7F9              ;
 165+ B7F9              ; The resulting string is placed into a small buffer attached to this routine,
 166+ B7F9              ; this buffer needs no initialization and can be modified as desired.
 167+ B7F9              ; The number is aligned to the right, and leading 0's are replaced with spaces.
 168+ B7F9              ; On exit HL points to the first digit, (B)C = number of decimals
 169+ B7F9              ; This way any re-alignment / postprocessing is made easy.
 170+ B7F9              ; Changes: AF,BC,DE,HL,IX
 171+ B7F9              ; P.S. some examples below
 172+ B7F9
 173+ B7F9              ; by Alwin Henseler
 174+ B7F9
 175+ B7F9 26 00        B2D8:    LD H,0
 176+ B7FB 6F                    LD L,A
 177+ B7FC 1E 00        B2D16:   LD E,0
 178+ B7FE 16 00        B2D24:   LD D,0
 179+ B800 01 00 00     B2D32:   LD BC,0
 180+ B803 DD 21 00 00  B2D48:   LD IX,0          ; zero all non-used bits
 181+ B807 22 90 B8     B2D64:   LD (B2DINV),HL
 182+ B80A ED 53 92 B8           LD (B2DINV+2),DE
 183+ B80E ED 43 94 B8           LD (B2DINV+4),BC
 184+ B812 DD 22 96 B8           LD (B2DINV+6),IX ; place full 64-bit input value in buffer
 185+ B816 21 98 B8              LD HL,B2DBUF
 186+ B819 11 99 B8              LD DE,B2DBUF+1
 187+ B81C 36 20                 LD (HL)," "
 188+ B81E              B2DFILC: EQU $-1         ; address of fill-character
 189+ B81E 01 12 00              LD BC,18
 190+ B821 ED B0                 LDIR            ; fill 1st 19 bytes of buffer with spaces
 191+ B823 ED 43 AB B8           LD (B2DEND-1),BC ;set BCD value to "0" & place terminating 0
 192+ B827 1E 01                 LD E,1          ; no. of bytes in BCD value
 193+ B829 21 98 B8              LD HL,B2DINV+8  ; (address MSB input)+1
 194+ B82C 01 09 09              LD BC,0x0909
 195+ B82F AF                    XOR A
 196+ B830 05           B2DSKP0: DEC B
 197+ B831 28 29                 JR Z,B2DSIZ     ; all 0: continue with postprocessing
 198+ B833 2B                    DEC HL
 199+ B834 B6                    OR (HL)         ; find first byte <>0
 200+ B835 28 F9                 JR Z,B2DSKP0
 201+ B837 0D           B2DFND1: DEC C
 202+ B838 17                    RLA
 203+ B839 30 FC                 JR NC,B2DFND1   ; determine no. of most significant 1-bit
 204+ B83B 1F                    RRA
 205+ B83C 57                    LD D,A          ; byte from binary input value
 206+ B83D E5           B2DLUS2: PUSH HL
 207+ B83E C5                    PUSH BC
 208+ B83F 21 AB B8     B2DLUS1: LD HL,B2DEND-1  ; address LSB of BCD value
 209+ B842 43                    LD B,E          ; current length of BCD value in bytes
 210+ B843 CB 12                 RL D            ; highest bit from input value -> carry
 211+ B845 7E           B2DLUS0: LD A,(HL)
 212+ B846 8F                    ADC A,A
 213+ B847 27                    DAA
 214+ B848 77                    LD (HL),A       ; double 1 BCD byte from intermediate result
 215+ B849 2B                    DEC HL
 216+ B84A 10 F9                 DJNZ B2DLUS0    ; and go on to double entire BCD value (+carry!)
 217+ B84C 30 03                 JR NC,B2DNXT
 218+ B84E 1C                    INC E           ; carry at MSB -> BCD value grew 1 byte larger
 219+ B84F 36 01                 LD (HL),1       ; initialize new MSB of BCD value
 220+ B851 0D           B2DNXT:  DEC C
 221+ B852 20 EB                 JR NZ,B2DLUS1   ; repeat for remaining bits from 1 input byte
 222+ B854 C1                    POP BC          ; no. of remaining bytes in input value
 223+ B855 0E 08                 LD C,8          ; reset bit-counter
 224+ B857 E1                    POP HL          ; pointer to byte from input value
 225+ B858 2B                    DEC HL
 226+ B859 56                    LD D,(HL)       ; get next group of 8 bits
 227+ B85A 10 E1                 DJNZ B2DLUS2    ; and repeat until last byte from input value
 228+ B85C 21 AC B8     B2DSIZ:  LD HL,B2DEND    ; address of terminating 0
 229+ B85F 4B                    LD C,E          ; size of BCD value in bytes
 230+ B860 B7                    OR A
 231+ B861 ED 42                 SBC HL,BC       ; calculate address of MSB BCD
 232+ B863 54                    LD D,H
 233+ B864 5D                    LD E,L
 234+ B865 ED 42                 SBC HL,BC
 235+ B867 EB                    EX DE,HL        ; HL=address BCD value, DE=start of decimal value
 236+ B868 41                    LD B,C          ; no. of bytes BCD
 237+ B869 CB 21                 SLA C           ; no. of bytes decimal (possibly 1 too high)
 238+ B86B 3E 30                 LD A,"0"
 239+ B86D ED 6F                 RLD             ; shift bits 4-7 of (HL) into bit 0-3 of A
 240+ B86F FE 30                 CP "0"          ; (HL) was > 9h?
 241+ B871 20 06                 JR NZ,B2DEXPH   ; if yes, start with recording high digit
 242+ B873 0D                    DEC C           ; correct number of decimals
 243+ B874 13                    INC DE          ; correct start address
 244+ B875 18 04                 JR B2DEXPL      ; continue with converting low digit
 245+ B877 ED 6F        B2DEXP:  RLD             ; shift high digit (HL) into low digit of A
 246+ B879 12           B2DEXPH: LD (DE),A       ; record resulting ASCII-code
 247+ B87A 13                    INC DE
 248+ B87B ED 6F        B2DEXPL: RLD
 249+ B87D 12                    LD (DE),A
 250+ B87E 13                    INC DE
 251+ B87F 23                    INC HL          ; next BCD-byte
 252+ B880 10 F5                 DJNZ B2DEXP     ; and go on to convert each BCD-byte into 2 ASCII
 253+ B882 ED 42                 SBC HL,BC       ; return with HL pointing to 1st decimal
 254+ B884 C9                    RET
 255+ B885
 256+ B885              AppendB2D:
 257+ B885              ; Append results of B2D to string at HL
 258+ B885 EB               ex      de, hl  ; Get destination into DE
 259+ B886 21 98 B8         ld      hl, B2DBUF
 260+ B889 CD D3 B7         call        SkipWhitespace
 261+ B88C ED B0            ldir
 262+ B88E EB               ex      de, hl  ; Get destination into DE
 263+ B88F C9               ret
 264+ B890
 265+ B890 00 00 00...  B2DINV:  DS 8            ; space for 64-bit input value (LSB first)
 266+ B898 00 00 00...  B2DBUF:  DS 20           ; space for 20 decimal digits
 267+ B8AC 00           B2DEND:  DB 0 ; space for terminating 0
 268+ B8AD
# file closed: utils.asm
 425  B8AD                  include "wifi.asm"
# file opened: wifi.asm
   1+ B8AD              ROM_OPEN_CHANNEL        EQU  0x1601             ; Open a channel
   2+ B8AD              ROM_PRINT               EQU  0x203C             ; Print a string
   3+ B8AD
   4+ B8AD                  macro dodos n
   5+ B8AD ~                    ld   ix, n
   6+ B8AD ~                    call dos_ix
   7+ B8AD                  endm
   8+ B8AD
   9+ B8AD              loadWiFiConfig:
  10+ B8AD 3E 01            ld      a, 1
  11+ B8AF CD 01 16         call    ROM_OPEN_CHANNEL
  12+ B8B2 11 07 BB         ld      de, loadingMsg
  13+ B8B5 01 19 00         ld      bc, loadingMsgLen
  14+ B8B8 CD 3C 20         call    ROM_PRINT
  15+ B8BB
  16+ B8BB 06 01            ld      b, 1
  17+ B8BD 21 26 BC         ld      hl, conf_file
  18+ B8C0 0E 01            ld      c, ACCESS_MODE_EXCLUSIVE_READ
  19+ B8C2 16 00            ld      d, CREATE_ACTION_DONT_CREATE
  20+ B8C4 1E 01            ld      e, OPEN_ACTION_READ_HEADER
  21+ B8C6                  dodos   dos_open
  21+ B8C6 DD 21 06 01 >        ld   ix, dos_open
  21+ B8CA CD 9B B5    >        call dos_ix
  22+ B8CD 30 1D            jr      nc, .error
  23+ B8CF
  24+ B8CF 06 01            ld      b, 1
  25+ B8D1 0E 00            ld      c, 0
  26+ B8D3 11 A0 00         ld      de, 160
  27+ B8D6 21 33 BC         ld      hl, ssid
  28+ B8D9                  dodos   dos_read
  28+ B8D9 DD 21 12 01 >        ld   ix, dos_read
  28+ B8DD CD 9B B5    >        call dos_ix
  29+ B8E0 30 0A            jr      nc, .error
  30+ B8E2
  31+ B8E2 06 01            ld      b, 1
  32+ B8E4                  dodos   dos_close
  32+ B8E4 DD 21 09 01 >        ld   ix, dos_close
  32+ B8E8 CD 9B B5    >        call dos_ix
  33+ B8EB C9               ret
  34+ B8EC
  35+ B8EC              .error
  36+ B8EC 3E 02            ld      a, 2
  37+ B8EE D3 FE            out     (-2), a
  38+ B8F0 C9               ret
  39+ B8F1
  40+ B8F1              ; Initialize WiFi chip and connect to WiFi
  41+ B8F1              initWiFi
  42+ B8F1 3E 01            ld      a, 1
  43+ B8F3 CD 01 16         call    ROM_OPEN_CHANNEL
  44+ B8F6 11 20 BB         ld      de, connectingMsg
  45+ B8F9 01 19 00         ld      bc, connectingMsgLen
  46+ B8FC CD 3C 20         call    ROM_PRINT
  47+ B8FF
  48+ B8FF CD B8 B6         call    uartBegin
  49+ B902 21 25 BA         ld      hl, cmd_rst
  50+ B905 CD B3 B7         call    uartWriteStringZ
  51+ B908
  52+ B908              1
  53+ B908                  ; Flush ESP TX buffer
  54+ B908 CD B8 B6         call    uartBegin
  55+ B90B
  56+ B90B                  ; WiFi client mode
  57+ B90B 21 35 BA         ld      hl, cmd_mode
  58+ B90E CD 66 B9         call    okErrCmd
  59+ B911 E6 01            and     1
  60+ B913 28 4B            jr      z, errInit
  61+ B915
  62+ B915                  ; Disable ECHO. BTW Basic UART test
  63+ B915 21 2E BA         ld      hl, cmd_at
  64+ B918 CD 66 B9         call    okErrCmd
  65+ B91B E6 01            and     1
  66+ B91D 28 41            jr      z, errInit
  67+ B91F
  68+ B91F                  ; Lets disconnect from last AP
  69+ B91F 21 55 BA         ld      hl, cmd_cwqap
  70+ B922 CD 66 B9         call    okErrCmd
  71+ B925 E6 01            and     1
  72+ B927 28 37            jr      z, errInit
  73+ B929
  74+ B929                  ; Single connection mode
  75+ B929 21 47 BA         ld      hl, cmd_cmux
  76+ B92C CD 66 B9         call    okErrCmd
  77+ B92F E6 01            and     1
  78+ B931 28 2D            jr      z, errInit
  79+ B933
  80+ B933                  ; FTP enables this info? We doesn't need it :-)
  81+ B933 21 60 BA         ld      hl, cmd_inf_off
  82+ B936 CD 66 B9         call    okErrCmd
  83+ B939 E6 01            and     1
  84+ B93B 28 23            jr      z, errInit
  85+ B93D
  86+ B93D              ; Access Point connection
  87+ B93D 21 70 BA         ld      hl, cmd_cwjap1
  88+ B940 CD B3 B7         call    uartWriteStringZ
  89+ B943 21 33 BC         ld      hl, ssid
  90+ B946 CD B3 B7         call    uartWriteStringZ
  91+ B949 21 7F BA         ld      hl, cmd_cwjap2
  92+ B94C CD B3 B7         call    uartWriteStringZ
  93+ B94F 21 83 BC         ld      hl, pass
  94+ B952 CD B3 B7         call    uartWriteStringZ
  95+ B955 21 83 BA         ld      hl, cmd_cwjap3
  96+ B958 CD 66 B9         call    okErrCmd
  97+ B95B
  98+ B95B E6 01            and 1
  98+ B95D 28 01         jr z, errInit
  99+ B95F
 100+ B95F C9               ret
 101+ B960
 102+ B960              errInit
 103+ B960                  ; ld hl, log_err : call putStringZ
 104+ B960 3E 03            ld   a, 3
 105+ B962 D3 FE            out  (-2), a
 106+ B964 18 FE            jr $
 107+ B966
 108+ B966              ; Send AT-command and wait for result.
 109+ B966              ; HL - Z-terminated AT-command(with CR/LF)
 110+ B966              ; A:
 111+ B966              ;    1 - Success
 112+ B966              ;    0 - Failed
 113+ B966              okErrCmd
 114+ B966 CD B3 B7         call    uartWriteStringZ
 115+ B969              okErrCmdLp
 116+ B969 CD 01 B7         call    uartReadBlocking
 117+ B96C CD 52 B7         call    pushRing
 118+ B96F
 119+ B96F 21 E9 BA         ld      hl, response_ok
 120+ B972 CD 67 B7         call    searchRing
 121+ B975 38 13            jr      c, okErrOk
 122+ B977 21 EE BA         ld      hl, response_err
 123+ B97A CD 67 B7         call    searchRing
 124+ B97D 38 0E            jr      c, okErrErr
 125+ B97F 21 F8 BA         ld      hl, response_fail
 126+ B982 CD 67 B7         call    searchRing
 127+ B985 38 06            jr      c, okErrErr
 128+ B987
 129+ B987 C3 69 B9         jp      okErrCmdLp
 130+ B98A              okErrOk
 131+ B98A 3E 01            ld      a, 1
 132+ B98C C9               ret
 133+ B98D              okErrErr
 134+ B98D AF               xor     a
 135+ B98E C9               ret
 136+ B98F
 137+ B98F              ; Gets packet from network
 138+ B98F              ; packet will be in var 'output_buffer'
 139+ B98F              ; received packet size in var 'bytes_avail'
 140+ B98F              ;
 141+ B98F              ; If connection was closed it calls 'closed_callback'
 142+ B98F              getPacket
 143+ B98F AF               xor     a
 144+ B990 D3 FE            out     (-2), a
 145+ B992
 146+ B992 CD 01 B7         call    uartReadBlocking
 147+ B995 FE 2B            cp      '+'
 148+ B997 28 38            jr      z, .checkIpdStart
 149+ B999 FE 4F            cp      'O'
 150+ B99B 28 4E            jr      z, .checkClosed
 151+ B99D 18 F0            jr      getPacket
 152+ B99F
 153+ B99F              .readPacket
 154+ B99F 3E 05            ld      a, 5
 155+ B9A1 D3 FE            out     (-2), a
 156+ B9A3
 157+ B9A3 CD 10 BA         call    count_ipd_length
 158+ B9A6 22 01 BB         ld      (bytes_avail), hl
 159+ B9A9 E5               push    hl
 160+ B9AA C1               pop     bc                      ; BC = byte count
 161+ B9AB
 162+ B9AB 2A C3 BB         ld      hl, (data_pointer)
 163+ B9AE              .readByte
 164+ B9AE C5               push    bc
 165+ B9AF E5               push    hl
 166+ B9B0 CD 01 B7         call    uartReadBlocking
 167+ B9B3
 168+ B9B3 F3               di
 169+ B9B4
 170+ B9B4 F5               push    af
 171+ B9B5 3A F7 B5         ld      a, (ddl_parms)
 172+ B9B8 CD CB B5         call    ram_page_in
 173+ B9BB F1               pop     af
 174+ B9BC
 175+ B9BC E1               pop     hl
 176+ B9BD C1               pop     bc
 177+ B9BE
 178+ B9BE 77               ld      (hl), a
 179+ B9BF 23               inc     hl
 180+ B9C0 0B               dec     bc
 181+ B9C1
 182+ B9C1 C5               push    bc
 183+ B9C2 E5               push    hl
 184+ B9C3 CD D8 B5         call    ram_page_out
 185+ B9C6 E1               pop     hl
 186+ B9C7 C1               pop     bc
 187+ B9C8
 188+ B9C8 78               ld      a, b
 189+ B9C9 B1               or      c
 190+ B9CA 20 E2            jr      nz, .readByte
 191+ B9CC
 192+ B9CC 22 C3 BB         ld      (data_pointer), hl
 193+ B9CF FB               ei
 194+ B9D0 C9               ret
 195+ B9D1
 196+ B9D1              .checkIpdStart
 197+ B9D1 CD 01 B7         call uartReadBlocking
 197+ B9D4 FE 49          cp 'I'
 197+ B9D6 20 B7          jr nz, getPacket
 198+ B9D8 CD 01 B7         call uartReadBlocking
 198+ B9DB FE 50          cp 'P'
 198+ B9DD 20 B0          jr nz, getPacket
 199+ B9DF CD 01 B7         call uartReadBlocking
 199+ B9E2 FE 44          cp 'D'
 199+ B9E4 20 A9          jr nz, getPacket
 200+ B9E6 CD 01 B7         call uartReadBlocking ; Comma
 201+ B9E9 18 B4            jr   .readPacket
 202+ B9EB
 203+ B9EB              .checkClosed
 204+ B9EB CD 01 B7         call uartReadBlocking
 204+ B9EE FE 53          cp 'S'
 204+ B9F0 20 9D          jr nz, getPacket
 205+ B9F2 CD 01 B7         call uartReadBlocking
 205+ B9F5 FE 45          cp 'E'
 205+ B9F7 20 96          jr nz, getPacket
 206+ B9F9 CD 01 B7         call uartReadBlocking
 206+ B9FC FE 44          cp 'D'
 206+ B9FE 20 8F          jr nz, getPacket
 207+ BA00 CD 01 B7         call uartReadBlocking
 207+ BA03 FE 0D          cp 13
 207+ BA05 20 88          jr nz, getPacket
 208+ BA07 C3 0A BA         jp   closed_callback
 209+ BA0A
 210+ BA0A              closed_callback:
 211+ BA0A AF               xor  a
 212+ BA0B 32 1F BC         ld   (connectionOpen), a
 213+ BA0E FB               ei
 214+ BA0F C9               ret
 215+ BA10
 216+ BA10              count_ipd_length
 217+ BA10 21 00 00         ld   hl, 0          ; count length
 218+ BA13 E5           1:  push hl
 219+ BA14 CD 01 B7         call uartReadBlocking
 220+ BA17 F5               push af
 221+ BA18 CD 52 B7         call pushRing
 222+ BA1B F1               pop  af
 223+ BA1C E1               pop  hl
 224+ BA1D FE 3A            cp   ':'
 225+ BA1F C8               ret  z
 226+ BA20
 227+ BA20 CD EC B7         call atoi2
 228+ BA23 18 EE            jr   1B
 229+ BA25
 230+ BA25 41 54 2B 52  cmd_rst     defb "AT+RST",13, 10, 0
 230+ BA29 53 54 0D 0A
 230+ BA2D 00
 231+ BA2E 41 54 45 30  cmd_at      defb "ATE0", 13, 10, 0                  ; Disable echo - less to parse
 231+ BA32 0D 0A 00
 232+ BA35 41 54 2B 43  cmd_mode    defb "AT+CWMODE_DEF=1",13,10,0          ; Client mode
 232+ BA39 57 4D 4F 44
 232+ BA3D 45 5F 44 45
 232+ BA41 46 3D 31 0D
 232+ BA45 0A 00
 233+ BA47 41 54 2B 43  cmd_cmux    defb "AT+CIPMUX=0",13,10,0              ; Single connection mode
 233+ BA4B 49 50 4D 55
 233+ BA4F 58 3D 30 0D
 233+ BA53 0A 00
 234+ BA55 41 54 2B 43  cmd_cwqap   defb "AT+CWQAP",13,10,0                 ; Disconnect from AP
 234+ BA59 57 51 41 50
 234+ BA5D 0D 0A 00
 235+ BA60 41 54 2B 43  cmd_inf_off defb "AT+CIPDINFO=0",13,10,0            ; doesn't send me info about remote port and ip
 235+ BA64 49 50 44 49
 235+ BA68 4E 46 4F 3D
 235+ BA6C 30 0D 0A 00
 236+ BA70
 237+ BA70 41 54 2B 43  cmd_cwjap1  defb  "AT+CWJAP_CUR=", #22,0        ;Connect to AP. Send this -> SSID
 237+ BA74 57 4A 41 50
 237+ BA78 5F 43 55 52
 237+ BA7C 3D 22 00
 238+ BA7F 22 2C 22 00  cmd_cwjap2  defb #22,',',#22,0                  ; -> This -> Password
 239+ BA83 22 0D 0A 00  cmd_cwjap3  defb #22, 13, 10, 0                 ; -> And this
 240+ BA87
 241+ BA87 41 54 2B 43  cmd_open1   defb "AT+CIPSTART=", #22, "TCP", #22, ",", #22, 0
 241+ BA8B 49 50 53 54
 241+ BA8F 41 52 54 3D
 241+ BA93 22 54 43 50
 241+ BA97 22 2C 22 00
 242+ BA9B 22 2C 00     cmd_open2   defb #22, ",", 0
 243+ BA9E 0D 0A 00     cmd_open3   defb 13, 10, 0
 244+ BAA1 41 54 2B 43  cmd_send    defb "AT+CIPSEND=", 0
 244+ BAA5 49 50 53 45
 244+ BAA9 4E 44 3D 00
 245+ BAAD 41 54 2B 43  cmd_close   defb "AT+CIPCLOSE",13,10,0
 245+ BAB1 49 50 43 4C
 245+ BAB5 4F 53 45 0D
 245+ BAB9 0A 00
 246+ BABB 41 54 2B 43  cmd_send_b  defb "AT+CIPSEND=1", 13, 10,0
 246+ BABF 49 50 53 45
 246+ BAC3 4E 44 3D 31
 246+ BAC7 0D 0A 00
 247+ BACA 43 4C 4F 53  closed      defb "CLOSED", 13, 10, 0
 247+ BACE 45 44 0D 0A
 247+ BAD2 00
 248+ BAD3 0D 0A 2B 49  ipd         defb 13, 10, "+IPD,", 0
 248+ BAD7 50 44 2C 00
 249+ BADB
 250+ BADB 72 65 61 64  response_rdy        defb 'ready', 0
 250+ BADF 79 00
 251+ BAE1 69 6E 76 61  response_invalid    defb 'invalid', 0
 251+ BAE5 6C 69 64 00
 252+ BAE9 4F 4B 0D 0A  response_ok         defb 'OK', 13, 10, 0      ; Sucessful operation
 252+ BAED 00
 253+ BAEE 0D 0A 45 52  response_err        defb 13, 10, 'ERROR', 13, 10, 0      ; Failed operation
 253+ BAF2 52 4F 52 0D
 253+ BAF6 0A 00
 254+ BAF8 0D 0A 46 41  response_fail       defb 13, 10, 'FAIL', 13, 10, 0       ; Failed connection to WiFi. For us same as ERROR
 254+ BAFC 49 4C 0D 0A
 254+ BB00 00
 255+ BB01
 256+ BB01 00 00        bytes_avail   defw 0
 257+ BB03 00 00        sbyte_buff    defb 0, 0
 258+ BB05
 259+ BB05 3E 00        send_prompt defb ">",0
 260+ BB07
 261+ BB07              loadingMsg:
 262+ BB07 16 01 00 4C      defb 0x16, 1, 0, "Loading WiFi config..."
 262+ BB0B 6F 61 64 69
 262+ BB0F 6E 67 20 57
 262+ BB13 69 46 69 20
 262+ BB17 63 6F 6E 66
 262+ BB1B 69 67 2E 2E
 262+ BB1F 2E
 263+ BB20              loadingMsgLen: equ $-loadingMsg
 264+ BB20
 265+ BB20              connectingMsg:
 266+ BB20 16 01 00 43      defb 0x16, 1, 0, "Connecting...         "
 266+ BB24 6F 6E 6E 65
 266+ BB28 63 74 69 6E
 266+ BB2C 67 2E 2E 2E
 266+ BB30 20 20 20 20
 266+ BB34 20 20 20 20
 266+ BB38 20
 267+ BB39              connectingMsgLen equ $-connectingMsg
 268+ BB39
# file closed: wifi.asm
 426  BB39                  include "request.asm"
# file opened: request.asm
   1+ BB39              ; hl - server
   2+ BB39              ; de - path
   3+ BB39              ; bc - port
   4+ BB39              ; a - page
   5+ BB39              loadSector:
   6+ BB39 CD 3F BB         call    makeRequest
   7+ BB3C C3 B8 BB         jp      loadData
   8+ BB3F
   9+ BB3F              ; HL - domain stringZ
  10+ BB3F              ; DE - path stringZ
  11+ BB3F              ; BC - port stringZ
  12+ BB3F              makeRequest:
  13+ BB3F 22 20 BC         ld      (srv_ptr), hl
  14+ BB42 ED 53 22 BC      ld      (path_ptr), de
  15+ BB46 ED 43 24 BC      ld      (port_ptr), bc
  16+ BB4A
  17+ BB4A                  ; Open TCP connection
  18+ BB4A 21 87 BA         ld      hl, cmd_open1
  19+ BB4D CD B3 B7         call    uartWriteStringZ
  20+ BB50 2A 20 BC         ld      hl, (srv_ptr)
  21+ BB53 CD B3 B7         call    uartWriteStringZ
  22+ BB56 21 9B BA         ld      hl, cmd_open2
  23+ BB59 CD B3 B7         call    uartWriteStringZ
  24+ BB5C 2A 24 BC         ld      hl, (port_ptr)
  25+ BB5F CD B3 B7         call    uartWriteStringZ
  26+ BB62 21 9E BA         ld      hl, cmd_open3
  27+ BB65 CD 66 B9         call    okErrCmd
  28+ BB68
  29+ BB68                  ; call    dumpRing
  30+ BB68 FE 01            cp      1
  31+ BB6A C2 B3 BB         jp      nz, reqErr
  32+ BB6D
  33+ BB6D                  ; Send request
  34+ BB6D 21 A1 BA         ld      hl, cmd_send
  35+ BB70 CD B3 B7         call    uartWriteStringZ
  36+ BB73 2A 22 BC         ld      hl, (path_ptr)
  37+ BB76 CD C9 B7         call    getStringLength
  38+ BB79 C5               push    bc
  39+ BB7A E1               pop     hl
  40+ BB7B CD FC B7         call    B2D16
  41+ BB7E
  42+ BB7E 21 98 B8         ld      hl, B2DBUF
  43+ BB81 CD D3 B7         call    SkipWhitespace
  44+ BB84 CD B3 B7         call    uartWriteStringZ
  45+ BB87 21 C8 BB         ld      hl, crlf
  46+ BB8A CD 66 B9         call    okErrCmd
  47+ BB8D
  48+ BB8D                  ; call    dumpRing
  49+ BB8D FE 01            cp      1
  50+ BB8F C2 B3 BB         jp      nz, reqErr
  51+ BB92
  52+ BB92              wPrmt:
  53+ BB92 CD 01 B7         call    uartReadBlocking
  54+ BB95 CD 52 B7         call    pushRing
  55+ BB98 21 05 BB         ld      hl, send_prompt
  56+ BB9B CD 67 B7         call    searchRing
  57+ BB9E 30 F2            jr      nc, wPrmt
  58+ BBA0
  59+ BBA0 2A 22 BC         ld      hl, (path_ptr)
  60+ BBA3 CD B3 B7         call    uartWriteStringZ
  61+ BBA6
  62+ BBA6 21 C8 BB         ld      hl, crlf
  63+ BBA9 CD B3 B7         call    uartWriteStringZ
  64+ BBAC 3E 01            ld      a, 1
  65+ BBAE 32 1F BC         ld      (connectionOpen), a
  66+ BBB1 AF               xor     a
  67+ BBB2 C9               ret
  68+ BBB3
  69+ BBB3              reqErr:
  70+ BBB3 3E 02            ld      a, 2
  71+ BBB5 D3 FE            out     (-2), a
  72+ BBB7 C9               ret
  73+ BBB8
  74+ BBB8              ; HL - data pointer
  75+ BBB8              ; data_pointer = pointer to buffer
  76+ BBB8              loadData:
  77+ BBB8 CD 8F B9         call    getPacket                ; Fetch next data packet
  78+ BBBB
  79+ BBBB 3A 1F BC         ld      a, (connectionOpen)      ; Check connection status
  80+ BBBE B7               or      a                        ; Test if zero
  81+ BBBF C8               ret     z                        ; Exit loop if connection closed
  82+ BBC0
  83+ BBC0 C3 B8 BB         jp      loadData                 ; Process next packet
  84+ BBC3
  85+ BBC3 00 00        data_pointer    defw    0
  86+ BBC5 00 00        data_recv       defw    0
  87+ BBC7 00           fstream         defb    0
  88+ BBC8
  89+ BBC8 0D 0A 00     crlf            defb    13, 10, 0
  90+ BBCB
  91+ BBCB 00 00 00...  d_path          defs    32, 0
  92+ BBEB 31 39 32 2E  d_host          defb    '192.168.7.164', 0
  92+ BBEF 31 36 38 2E
  92+ BBF3 37 2E 31 36
  92+ BBF7 34 00
  93+ BBF9 00 00 00...                  defs    32
  94+ BC19 37 36 35 30  d_port          db      '7650', 0
  94+ BC1D 00
  95+ BC1E 00                           defs    1
  96+ BC1F
  97+ BC1F 00           connectionOpen  db      0
  98+ BC20
  99+ BC20 00 00        srv_ptr         dw  0
 100+ BC22 00 00        path_ptr        dw  0
 101+ BC24 00 00        port_ptr        dw  0
 102+ BC26
# file closed: request.asm
 427  BC26              ;    include "screen42.asm"
 428  BC26              ;    include "font42.asm"
 429  BC26
 430  BC26              conf_file
 431  BC26 69 77 2E 63      defb "iw.cfg",0xff
 431  BC2A 66 67 FF
 432  BC2D FF FF FF...      defs 13-($-conf_file), 0xff
 433  BC33
 434  BC33              ssid:
 435  BC33 00 00 00...      defs    80
 436  BC83              pass:
 437  BC83 00 00 00...      defs    80
 438  BCD3
 439  BCD3              end:
 440  BCD3
 441  BCD3              ; ddl_parms layout
 442  BCD3
 443  BCD3              ; Off.    Size  Desc
 444  BCD3              ; +$00    1     Buffer page
 445  BCD3              ; +$01    2     Buffer address
 446  BCD3              ; +$03    2     Sector size in bytes
 447  BCD3              ; +$05    1     # Command bytes
 448  BCD3
 449  BCD3              ; READ
 450  BCD3
 451  BCD3              ; +$06    1     Command byte
 452  BCD3              ; +$07    1     Unit byte                   x x x x x H U1 U0
 453  BCD3              ; +$08    1     Track
 454  BCD3              ; +$09    1     Side
 455  BCD3              ; +$0A    1     1st sector id
 456  BCD3              ; +$0B    1     Sector size
 457  BCD3              ; +$0C    1     Last sector id (=1st)
 458  BCD3              ; +$0D    1     Gap size
 459  BCD3              ; +$0E    1     Dummy data length ($ff)
 460  BCD3
 461  BCD3                  save3dos "driven.bin", start, end-start
 462  BCD3                  savebin  "drvn.bin", start, end-start
 463  BCD3
# file closed: drive_n.asm
